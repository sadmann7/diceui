{
  "name": "scroller",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/scroller.tsx",
      "content": "\"use client\";\n\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { type VariantProps, cva } from \"class-variance-authority\";\nimport {\n  ChevronDown,\n  ChevronLeft,\n  ChevronRight,\n  ChevronUp,\n} from \"lucide-react\";\nimport * as React from \"react\";\n\nconst DATA_TOP_SCROLL = \"data-top-scroll\";\nconst DATA_BOTTOM_SCROLL = \"data-bottom-scroll\";\nconst DATA_LEFT_SCROLL = \"data-left-scroll\";\nconst DATA_RIGHT_SCROLL = \"data-right-scroll\";\nconst DATA_TOP_BOTTOM_SCROLL = \"data-top-bottom-scroll\";\nconst DATA_LEFT_RIGHT_SCROLL = \"data-left-right-scroll\";\n\nconst scrollerVariants = cva(\"\", {\n  variants: {\n    orientation: {\n      vertical: [\n        \"overflow-y-auto\",\n        \"data-[top-scroll=true]:[mask-image:linear-gradient(0deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\n        \"data-[bottom-scroll=true]:[mask-image:linear-gradient(180deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\n        \"data-[top-bottom-scroll=true]:[mask-image:linear-gradient(#000,#000,transparent_0,#000_var(--scroll-shadow-size),#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\n      ],\n      horizontal: [\n        \"overflow-x-auto\",\n        \"data-[left-scroll=true]:[mask-image:linear-gradient(270deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\n        \"data-[right-scroll=true]:[mask-image:linear-gradient(90deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\n        \"data-[left-right-scroll=true]:[mask-image:linear-gradient(to_right,#000,#000,transparent_0,#000_var(--scroll-shadow-size),#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\n      ],\n    },\n    hideScrollbar: {\n      true: \"[-ms-overflow-style:none] [scrollbar-width:none] [&::-webkit-scrollbar]:hidden\",\n      false: \"\",\n    },\n  },\n  defaultVariants: {\n    orientation: \"vertical\",\n    hideScrollbar: false,\n  },\n});\n\ntype ScrollDirection = \"up\" | \"down\" | \"left\" | \"right\";\n\ntype ScrollVisibility = {\n  [key in ScrollDirection]: boolean;\n};\n\ninterface ScrollerProps\n  extends VariantProps<typeof scrollerVariants>,\n    React.ComponentPropsWithoutRef<\"div\"> {\n  size?: number;\n  offset?: number;\n  asChild?: boolean;\n  withNavigation?: boolean;\n  scrollStep?: number;\n  scrollTriggerMode?: \"press\" | \"hover\" | \"click\";\n}\n\nconst Scroller = React.forwardRef<HTMLDivElement, ScrollerProps>(\n  (props, forwardedRef) => {\n    const {\n      orientation = \"vertical\",\n      hideScrollbar,\n      className,\n      size = 40,\n      offset = 0,\n      scrollStep = 40,\n      style,\n      asChild,\n      withNavigation = false,\n      scrollTriggerMode = \"press\",\n      ...scrollerProps\n    } = props;\n\n    const containerRef = React.useRef<HTMLDivElement | null>(null);\n    const composedRef = useComposedRefs(forwardedRef, containerRef);\n    const [scrollVisibility, setScrollVisibility] =\n      React.useState<ScrollVisibility>({\n        up: false,\n        down: false,\n        left: false,\n        right: false,\n      });\n\n    const onScrollBy = React.useCallback(\n      (direction: ScrollDirection) => {\n        const container = containerRef.current;\n        if (!container) return;\n\n        const scrollMap: Record<ScrollDirection, () => void> = {\n          up: () => (container.scrollTop -= scrollStep),\n          down: () => (container.scrollTop += scrollStep),\n          left: () => (container.scrollLeft -= scrollStep),\n          right: () => (container.scrollLeft += scrollStep),\n        };\n\n        scrollMap[direction]();\n      },\n      [scrollStep],\n    );\n\n    const scrollHandlers = React.useMemo(\n      () => ({\n        up: () => onScrollBy(\"up\"),\n        down: () => onScrollBy(\"down\"),\n        left: () => onScrollBy(\"left\"),\n        right: () => onScrollBy(\"right\"),\n      }),\n      [onScrollBy],\n    );\n\n    React.useLayoutEffect(() => {\n      const container = containerRef.current;\n      if (!container) return;\n\n      function onScroll() {\n        if (!container) return;\n\n        const isVertical = orientation === \"vertical\";\n\n        if (isVertical) {\n          const scrollTop = container.scrollTop;\n          const clientHeight = container.clientHeight;\n          const scrollHeight = container.scrollHeight;\n\n          if (withNavigation) {\n            setScrollVisibility((prev) => {\n              const newUp = scrollTop > offset;\n              const newDown = scrollTop + clientHeight < scrollHeight;\n\n              if (prev.up !== newUp || prev.down !== newDown) {\n                return {\n                  ...prev,\n                  up: newUp,\n                  down: newDown,\n                };\n              }\n              return prev;\n            });\n          }\n\n          const hasTopScroll = scrollTop > offset;\n          const hasBottomScroll =\n            scrollTop + clientHeight + offset < scrollHeight;\n          const isVerticallyScrollable = scrollHeight > clientHeight;\n\n          if (hasTopScroll && hasBottomScroll && isVerticallyScrollable) {\n            container.setAttribute(DATA_TOP_BOTTOM_SCROLL, \"true\");\n            container.removeAttribute(DATA_TOP_SCROLL);\n            container.removeAttribute(DATA_BOTTOM_SCROLL);\n          } else {\n            container.removeAttribute(DATA_TOP_BOTTOM_SCROLL);\n            if (hasTopScroll) container.setAttribute(DATA_TOP_SCROLL, \"true\");\n            else container.removeAttribute(DATA_TOP_SCROLL);\n            if (hasBottomScroll && isVerticallyScrollable)\n              container.setAttribute(DATA_BOTTOM_SCROLL, \"true\");\n            else container.removeAttribute(DATA_BOTTOM_SCROLL);\n          }\n        }\n\n        const scrollLeft = container.scrollLeft;\n        const clientWidth = container.clientWidth;\n        const scrollWidth = container.scrollWidth;\n\n        if (withNavigation) {\n          setScrollVisibility((prev) => {\n            const newLeft = scrollLeft > offset;\n            const newRight = scrollLeft + clientWidth < scrollWidth;\n\n            if (prev.left !== newLeft || prev.right !== newRight) {\n              return {\n                ...prev,\n                left: newLeft,\n                right: newRight,\n              };\n            }\n            return prev;\n          });\n        }\n\n        const hasLeftScroll = scrollLeft > offset;\n        const hasRightScroll = scrollLeft + clientWidth + offset < scrollWidth;\n        const isHorizontallyScrollable = scrollWidth > clientWidth;\n\n        if (hasLeftScroll && hasRightScroll && isHorizontallyScrollable) {\n          container.setAttribute(DATA_LEFT_RIGHT_SCROLL, \"true\");\n          container.removeAttribute(DATA_LEFT_SCROLL);\n          container.removeAttribute(DATA_RIGHT_SCROLL);\n        } else {\n          container.removeAttribute(DATA_LEFT_RIGHT_SCROLL);\n          if (hasLeftScroll) container.setAttribute(DATA_LEFT_SCROLL, \"true\");\n          else container.removeAttribute(DATA_LEFT_SCROLL);\n          if (hasRightScroll && isHorizontallyScrollable)\n            container.setAttribute(DATA_RIGHT_SCROLL, \"true\");\n          else container.removeAttribute(DATA_RIGHT_SCROLL);\n        }\n      }\n\n      onScroll();\n      container.addEventListener(\"scroll\", onScroll);\n      window.addEventListener(\"resize\", onScroll);\n\n      return () => {\n        container.removeEventListener(\"scroll\", onScroll);\n        window.removeEventListener(\"resize\", onScroll);\n      };\n    }, [orientation, offset, withNavigation]);\n\n    const composedStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        \"--scroll-shadow-size\": `${size}px`,\n        ...style,\n      }),\n      [size, style],\n    );\n\n    const activeDirections = React.useMemo<ScrollDirection[]>(() => {\n      if (!withNavigation) return [];\n      return orientation === \"vertical\" ? [\"up\", \"down\"] : [\"left\", \"right\"];\n    }, [orientation, withNavigation]);\n\n    const ScrollerPrimitive = asChild ? Slot : \"div\";\n\n    const ScrollerImpl = (\n      <ScrollerPrimitive\n        data-slot=\"scroller\"\n        {...scrollerProps}\n        ref={composedRef}\n        style={composedStyle}\n        className={cn(\n          scrollerVariants({ orientation, hideScrollbar, className }),\n        )}\n      />\n    );\n\n    const navigationButtons = React.useMemo(() => {\n      if (!withNavigation) return null;\n\n      return activeDirections\n        .filter((direction) => scrollVisibility[direction])\n        .map((direction) => (\n          <ScrollButton\n            key={direction}\n            data-slot=\"scroll-button\"\n            direction={direction}\n            onClick={scrollHandlers[direction]}\n            triggerMode={scrollTriggerMode}\n          />\n        ));\n    }, [\n      activeDirections,\n      scrollVisibility,\n      scrollHandlers,\n      scrollTriggerMode,\n      withNavigation,\n    ]);\n\n    if (withNavigation) {\n      return (\n        <div className=\"relative w-full\">\n          {navigationButtons}\n          {ScrollerImpl}\n        </div>\n      );\n    }\n\n    return ScrollerImpl;\n  },\n);\nScroller.displayName = \"Scroller\";\n\nconst scrollButtonVariants = cva(\n  \"absolute z-10 transition-opacity [&>svg]:size-4 [&>svg]:opacity-80 hover:[&>svg]:opacity-100\",\n  {\n    variants: {\n      direction: {\n        up: \"-translate-x-1/2 top-2 left-1/2\",\n        down: \"-translate-x-1/2 bottom-2 left-1/2\",\n        left: \"-translate-y-1/2 top-1/2 left-2\",\n        right: \"-translate-y-1/2 top-1/2 right-2\",\n      },\n    },\n    defaultVariants: {\n      direction: \"up\",\n    },\n  },\n);\n\nconst directionToIcon: Record<ScrollDirection, React.ElementType> = {\n  up: ChevronUp,\n  down: ChevronDown,\n  left: ChevronLeft,\n  right: ChevronRight,\n} as const;\n\ninterface ScrollButtonProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  direction: ScrollDirection;\n  triggerMode?: \"press\" | \"hover\" | \"click\";\n}\n\nconst ScrollButton = React.forwardRef<HTMLButtonElement, ScrollButtonProps>(\n  (props, forwardedRef) => {\n    const {\n      direction,\n      className,\n      triggerMode = \"press\",\n      onClick,\n      ...buttonProps\n    } = props;\n\n    const [autoScrollTimer, setAutoScrollTimer] = React.useState<number | null>(\n      null,\n    );\n\n    const onAutoScrollStart = React.useCallback(\n      (event?: React.MouseEvent<HTMLButtonElement>) => {\n        if (autoScrollTimer !== null) return;\n\n        if (triggerMode === \"press\") {\n          const timer = window.setInterval(onClick ?? (() => {}), 50);\n          setAutoScrollTimer(timer);\n        } else if (triggerMode === \"hover\") {\n          const timer = window.setInterval(() => {\n            if (event) onClick?.(event);\n          }, 50);\n          setAutoScrollTimer(timer);\n        }\n      },\n      [autoScrollTimer, onClick, triggerMode],\n    );\n\n    const onAutoScrollStop = React.useCallback(() => {\n      if (autoScrollTimer === null) return;\n\n      window.clearInterval(autoScrollTimer);\n      setAutoScrollTimer(null);\n    }, [autoScrollTimer]);\n\n    const eventHandlers = React.useMemo(() => {\n      const triggerModeHandlers: Record<\n        NonNullable<ScrollerProps[\"scrollTriggerMode\"]>,\n        React.ComponentPropsWithoutRef<\"button\">\n      > = {\n        press: {\n          onPointerDown: onAutoScrollStart,\n          onPointerUp: onAutoScrollStop,\n          onPointerLeave: onAutoScrollStop,\n          onClick: () => {},\n        },\n        hover: {\n          onPointerEnter: onAutoScrollStart,\n          onPointerLeave: onAutoScrollStop,\n          onClick: () => {},\n        },\n        click: {\n          onClick,\n        },\n      } as const;\n\n      return triggerModeHandlers[triggerMode] ?? {};\n    }, [triggerMode, onAutoScrollStart, onAutoScrollStop, onClick]);\n\n    React.useEffect(() => {\n      return () => onAutoScrollStop();\n    }, [onAutoScrollStop]);\n\n    const Icon = directionToIcon[direction];\n\n    return (\n      <button\n        type=\"button\"\n        {...buttonProps}\n        {...eventHandlers}\n        ref={forwardedRef}\n        className={cn(scrollButtonVariants({ direction, className }))}\n      >\n        <Icon />\n      </button>\n    );\n  },\n);\nScrollButton.displayName = \"ScrollButton\";\n\nexport { Scroller };\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}