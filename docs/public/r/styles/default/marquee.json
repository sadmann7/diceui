{
  "name": "marquee",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "class-variance-authority"
  ],
  "files": [
    {
      "path": "ui/marquee.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"Marquee\";\nconst CONTENT_NAME = \"MarqueeContent\";\n\ntype Side = \"left\" | \"right\" | \"top\" | \"bottom\";\ntype Orientation = \"horizontal\" | \"vertical\";\n\ntype RootElement = React.ComponentRef<typeof MarqueeRoot>;\ntype ContentElement = React.ComponentRef<typeof MarqueeContent>;\n\ninterface Dimensions {\n  width: number;\n  height: number;\n}\n\ninterface ElementDimensions {\n  rootSize: number;\n  contentSize: number;\n}\n\nfunction createResizeObserverStore() {\n  const listeners = new Set<() => void>();\n  let observer: ResizeObserver | null = null;\n  const elements = new Map<Element, Dimensions>();\n  const refCounts = new Map<Element, number>();\n  const isSupported = typeof ResizeObserver !== \"undefined\";\n  let notificationScheduled = false;\n\n  const snapshotCache = new WeakMap<\n    Element,\n    WeakMap<\n      Element,\n      { horizontal: ElementDimensions; vertical: ElementDimensions }\n    >\n  >();\n\n  function notify() {\n    if (notificationScheduled) return;\n    notificationScheduled = true;\n    queueMicrotask(() => {\n      notificationScheduled = false;\n      for (const callback of listeners) {\n        callback();\n      }\n    });\n  }\n\n  function cleanup() {\n    if (observer) {\n      observer.disconnect();\n      observer = null;\n    }\n    elements.clear();\n    refCounts.clear();\n  }\n\n  function subscribe(callback: () => void) {\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      if (listeners.size === 0) {\n        cleanup();\n      }\n    };\n  }\n\n  function getSnapshot(\n    rootElement: RootElement | null,\n    contentElement: ContentElement | null,\n    orientation: Orientation,\n  ): ElementDimensions | null {\n    if (!rootElement || !contentElement) return null;\n\n    const rootDims = elements.get(rootElement);\n    const contentDims = elements.get(contentElement);\n\n    if (!rootDims || !contentDims) return null;\n\n    const rootSize =\n      orientation === \"vertical\" ? rootDims.height : rootDims.width;\n    const contentSize =\n      orientation === \"vertical\" ? contentDims.height : contentDims.width;\n\n    let rootCache = snapshotCache.get(rootElement);\n    if (!rootCache) {\n      rootCache = new WeakMap();\n      snapshotCache.set(rootElement, rootCache);\n    }\n\n    let contentCache = rootCache.get(contentElement);\n    if (!contentCache) {\n      contentCache = {\n        horizontal: { rootSize: -1, contentSize: -1 },\n        vertical: { rootSize: -1, contentSize: -1 },\n      };\n      rootCache.set(contentElement, contentCache);\n    }\n\n    const cached = contentCache[orientation];\n    if (cached.rootSize === rootSize && cached.contentSize === contentSize) {\n      return cached;\n    }\n\n    const snapshot = { rootSize, contentSize };\n    contentCache[orientation] = snapshot;\n    return snapshot;\n  }\n\n  function observe(\n    rootElement: RootElement | null,\n    contentElement: Element | null,\n  ) {\n    if (!isSupported || !rootElement || !contentElement) return;\n\n    if (!observer) {\n      observer = new ResizeObserver((entries) => {\n        let hasChanged = false;\n\n        for (const entry of entries) {\n          const element = entry.target;\n          const { width, height } = entry.contentRect;\n\n          const currentData = elements.get(element);\n\n          if (\n            !currentData ||\n            currentData.width !== width ||\n            currentData.height !== height\n          ) {\n            elements.set(element, { width, height });\n            hasChanged = true;\n          }\n        }\n\n        if (hasChanged) {\n          notify();\n        }\n      });\n    }\n\n    refCounts.set(rootElement, (refCounts.get(rootElement) ?? 0) + 1);\n    refCounts.set(contentElement, (refCounts.get(contentElement) ?? 0) + 1);\n\n    observer.observe(rootElement);\n    observer.observe(contentElement);\n\n    const rootRect = rootElement.getBoundingClientRect();\n    const contentRect = contentElement.getBoundingClientRect();\n\n    elements.set(rootElement, {\n      width: rootRect.width,\n      height: rootRect.height,\n    });\n    elements.set(contentElement, {\n      width: contentRect.width,\n      height: contentRect.height,\n    });\n  }\n\n  function unobserve(\n    rootElement: RootElement | null,\n    contentElement: Element | null,\n  ) {\n    if (!observer || !rootElement || !contentElement) return;\n\n    const rootCount = (refCounts.get(rootElement) ?? 1) - 1;\n    const contentCount = (refCounts.get(contentElement) ?? 1) - 1;\n\n    if (rootCount <= 0) {\n      observer.unobserve(rootElement);\n      elements.delete(rootElement);\n      refCounts.delete(rootElement);\n    } else {\n      refCounts.set(rootElement, rootCount);\n    }\n\n    if (contentCount <= 0) {\n      observer.unobserve(contentElement);\n      elements.delete(contentElement);\n      refCounts.delete(contentElement);\n    } else {\n      refCounts.set(contentElement, contentCount);\n    }\n  }\n\n  return {\n    subscribe,\n    getSnapshot,\n    observe,\n    unobserve,\n  };\n}\n\nconst resizeObserverStore = createResizeObserverStore();\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface MarqueeContextValue {\n  side: Side;\n  orientation: Orientation;\n  loopCount: number;\n  contentRef: React.RefObject<ContentElement | null>;\n  dimensions: ElementDimensions | null;\n  autoFill: boolean;\n  pauseOnHover: boolean;\n  reverse: boolean;\n}\n\nconst MarqueeContext = React.createContext<MarqueeContextValue | null>(null);\n\nfunction useMarqueeContext(consumerName: string) {\n  const context = React.useContext(MarqueeContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface MarqueeRootProps extends DivProps {\n  side?: Side;\n  speed?: number;\n  loopCount?: number;\n  gap?: string;\n  autoFill?: boolean;\n  pauseOnHover?: boolean;\n  reverse?: boolean;\n}\n\nfunction MarqueeRoot(props: MarqueeRootProps) {\n  const {\n    side = \"left\",\n    speed = 50,\n    loopCount = 0,\n    gap = \"1rem\",\n    autoFill = false,\n    pauseOnHover = false,\n    reverse = false,\n    className,\n    style,\n    children,\n    asChild,\n    ref,\n    ...marqueeProps\n  } = props;\n\n  const orientation: Orientation =\n    side === \"top\" || side === \"bottom\" ? \"vertical\" : \"horizontal\";\n\n  const rootRef = React.useRef<RootElement>(null);\n  const contentRef = React.useRef<ContentElement>(null);\n  const composedRef = useComposedRefs(ref, rootRef);\n\n  const onSubscribe = React.useCallback(\n    (callback: () => void) => resizeObserverStore.subscribe(callback),\n    [],\n  );\n\n  const getSnapshot = React.useCallback(\n    () =>\n      resizeObserverStore.getSnapshot(\n        rootRef.current,\n        contentRef.current,\n        orientation,\n      ),\n    [orientation],\n  );\n\n  const dimensions = React.useSyncExternalStore(\n    onSubscribe,\n    getSnapshot,\n    getSnapshot,\n  );\n\n  const duration = React.useMemo(() => {\n    if (!dimensions) {\n      const safeSpeed = Math.max(0.001, speed);\n      const defaultDistance = 2000;\n      return defaultDistance / safeSpeed;\n    }\n\n    const { rootSize, contentSize } = dimensions;\n    const distance = contentSize + rootSize;\n    const safeSpeed = Math.max(0.001, speed);\n    return distance / safeSpeed;\n  }, [dimensions, speed]);\n\n  React.useEffect(() => {\n    if (rootRef.current && contentRef.current) {\n      resizeObserverStore.observe(rootRef.current, contentRef.current);\n\n      return () => {\n        resizeObserverStore.unobserve(rootRef.current, contentRef.current);\n      };\n    }\n  }, []);\n\n  const marqueeStyle = React.useMemo<React.CSSProperties>(\n    () => ({\n      \"--duration\": `${duration}s`,\n      \"--gap\": gap,\n      \"--loop-count\":\n        loopCount === 0 || loopCount === Infinity\n          ? \"infinite\"\n          : loopCount.toString(),\n      ...style,\n    }),\n    [duration, gap, loopCount, style],\n  );\n\n  const contextValue = React.useMemo<MarqueeContextValue>(\n    () => ({\n      side,\n      orientation,\n      loopCount,\n      contentRef,\n      dimensions,\n      autoFill,\n      pauseOnHover,\n      reverse,\n    }),\n    [side, pauseOnHover, reverse, orientation, loopCount, autoFill, dimensions],\n  );\n\n  const MarqueePrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <MarqueeContext.Provider value={contextValue}>\n      <MarqueePrimitive\n        aria-live=\"off\"\n        data-slot=\"marquee\"\n        data-orientation={orientation}\n        {...marqueeProps}\n        ref={composedRef}\n        style={marqueeStyle}\n        className={cn(\n          \"relative flex overflow-hidden [--duration:40s] [--gap:1rem] [--loop-count:infinite] motion-reduce:animate-none\",\n          orientation === \"vertical\" && \"h-full flex-col\",\n          orientation === \"horizontal\" && \"w-full\",\n          pauseOnHover && \"group\",\n          className,\n        )}\n      >\n        {children}\n      </MarqueePrimitive>\n    </MarqueeContext.Provider>\n  );\n}\n\nconst marqueeContentVariants = cva(\"flex shrink-0\", {\n  variants: {\n    side: {\n      left: \"animate-marquee-left\",\n      right: \"animate-marquee-right\",\n      top: \"animate-marquee-up flex-col\",\n      bottom: \"animate-marquee-down flex-col\",\n    },\n    pauseOnHover: {\n      true: \"group-hover:[animation-play-state:paused]\",\n      false: \"\",\n    },\n    reverse: {\n      true: \"[animation-direction:reverse]\",\n      false: \"\",\n    },\n  },\n  defaultVariants: {\n    side: \"left\",\n    pauseOnHover: false,\n    reverse: false,\n  },\n});\n\nfunction MarqueeContent(props: DivProps) {\n  const { className, asChild, ref, children, style, ...contentProps } = props;\n\n  const context = useMarqueeContext(CONTENT_NAME);\n\n  const composedRef = useComposedRefs(ref, context.contentRef);\n  const ContentPrimitive = asChild ? Slot : \"div\";\n  const isVertical = context.orientation === \"vertical\";\n\n  const multiplier = React.useMemo(() => {\n    if (!context.autoFill || !context.dimensions) return 1;\n\n    const { rootSize, contentSize } = context.dimensions;\n    if (contentSize === 0) return 1;\n\n    return Math.ceil(rootSize / contentSize);\n  }, [context.autoFill, context.dimensions]);\n\n  const onContentRender = React.useCallback(\n    (withRef: boolean = true) => (\n      <div\n        className={cn(\n          \"flex shrink-0 [gap:var(--gap)]\",\n          isVertical && \"flex-col\",\n          isVertical\n            ? \"[margin-bottom:var(--gap)]\"\n            : \"[margin-right:var(--gap)]\",\n        )}\n        ref={withRef ? composedRef : undefined}\n      >\n        {Array.from({ length: multiplier }).map((_, index) => (\n          <React.Fragment key={index}>{children}</React.Fragment>\n        ))}\n      </div>\n    ),\n    [children, multiplier, isVertical, composedRef],\n  );\n\n  return (\n    <>\n      <ContentPrimitive\n        data-slot=\"marquee-content\"\n        {...contentProps}\n        style={style}\n        className={cn(\n          marqueeContentVariants({\n            side: context.side,\n            pauseOnHover: context.pauseOnHover,\n            reverse: context.reverse,\n            className,\n          }),\n        )}\n      >\n        {onContentRender()}\n      </ContentPrimitive>\n      <ContentPrimitive\n        role=\"presentation\"\n        aria-hidden=\"true\"\n        {...contentProps}\n        style={style}\n        className={cn(\n          marqueeContentVariants({\n            side: context.side,\n            pauseOnHover: context.pauseOnHover,\n            reverse: context.reverse,\n            className,\n          }),\n        )}\n      >\n        {onContentRender(false)}\n      </ContentPrimitive>\n    </>\n  );\n}\n\nfunction MarqueeItem(props: DivProps) {\n  const { className, asChild, ...itemProps } = props;\n\n  const ItemPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemPrimitive\n      data-slot=\"marquee-item\"\n      {...itemProps}\n      className={cn(\"shrink-0\", className)}\n    />\n  );\n}\n\nconst marqueeEdgeVariants = cva(\"pointer-events-none absolute z-10\", {\n  variants: {\n    side: {\n      left: \"top-0 left-0 h-full w-1/3 bg-gradient-to-r from-background to-transparent\",\n      right:\n        \"top-0 right-0 h-full w-1/3 bg-gradient-to-l from-background to-transparent\",\n      top: \"top-0 left-0 h-1/3 w-full bg-gradient-to-b from-background to-transparent\",\n      bottom:\n        \"bottom-0 left-0 h-1/3 w-full bg-gradient-to-t from-background to-transparent\",\n    },\n  },\n});\n\ninterface MarqueeEdgeProps\n  extends VariantProps<typeof marqueeEdgeVariants>,\n    DivProps {}\n\nfunction MarqueeEdge(props: MarqueeEdgeProps) {\n  const { side, className, asChild, ...edgeProps } = props;\n\n  const EdgePrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <EdgePrimitive\n      data-slot=\"marquee-edge\"\n      {...edgeProps}\n      className={cn(marqueeEdgeVariants({ side, className }))}\n    />\n  );\n}\n\nexport {\n  MarqueeRoot as Marquee,\n  MarqueeContent as Content,\n  MarqueeItem as Item,\n  MarqueeEdge as Edge,\n  //\n  MarqueeRoot as Root,\n  MarqueeContent,\n  MarqueeItem,\n  MarqueeEdge,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "cssVars": {
    "theme": {
      "--animate-marquee-left": "marquee-left var(--duration) linear var(--loop-count)",
      "--animate-marquee-right": "marquee-right var(--duration) linear var(--loop-count)",
      "--animate-marquee-up": "marquee-up var(--duration) linear var(--loop-count)",
      "--animate-marquee-down": "marquee-down var(--duration) linear var(--loop-count)"
    }
  },
  "css": {
    "@keyframes marquee-left": {
      "0%": {
        "transform": "translateX(0%)"
      },
      "100%": {
        "transform": "translateX(-100%)"
      }
    },
    "@keyframes marquee-right": {
      "0%": {
        "transform": "translateX(-100%)"
      },
      "100%": {
        "transform": "translateX(0%)"
      }
    },
    "@keyframes marquee-up": {
      "0%": {
        "transform": "translateY(0%)"
      },
      "100%": {
        "transform": "translateY(-100%)"
      }
    },
    "@keyframes marquee-down": {
      "0%": {
        "transform": "translateY(-100%)"
      },
      "100%": {
        "transform": "translateY(0%)"
      }
    }
  }
}