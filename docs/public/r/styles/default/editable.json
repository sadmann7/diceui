{
  "name": "editable",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/editable.tsx",
      "content": "\"use client\";\r\n\r\nimport { composeEventHandlers, useComposedRefs } from \"@/lib/composition\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\n\r\nconst DATA_ACTION_ATTR = \"data-action\";\r\n\r\nconst ROOT_NAME = \"Editable\";\r\nconst AREA_NAME = \"EditableArea\";\r\nconst PREVIEW_NAME = \"EditablePreview\";\r\nconst INPUT_NAME = \"EditableInput\";\r\nconst TRIGGER_NAME = \"EditableTrigger\";\r\nconst LABEL_NAME = \"EditableLabel\";\r\nconst TOOLBAR_NAME = \"EditableToolbar\";\r\nconst CANCEL_NAME = \"EditableCancel\";\r\nconst SUBMIT_NAME = \"EditableSubmit\";\r\n\r\nconst EDITABLE_ERROR = {\r\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` components must be within \\`${ROOT_NAME}\\``,\r\n  [AREA_NAME]: `\\`${AREA_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [PREVIEW_NAME]: `\\`${PREVIEW_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [INPUT_NAME]: `\\`${INPUT_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [TRIGGER_NAME]: `\\`${TRIGGER_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [LABEL_NAME]: `\\`${LABEL_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [TOOLBAR_NAME]: `\\`${TOOLBAR_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [CANCEL_NAME]: `\\`${CANCEL_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [SUBMIT_NAME]: `\\`${SUBMIT_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n} as const;\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\r\n\r\nfunction useDirection(dirProp?: Direction): Direction {\r\n  const contextDir = React.useContext(DirectionContext);\r\n  return dirProp ?? contextDir ?? \"ltr\";\r\n}\r\n\r\ninterface EditableContextValue {\r\n  id: string;\r\n  inputId: string;\r\n  labelId: string;\r\n  defaultValue: string;\r\n  value: string;\r\n  onValueChange: (value: string) => void;\r\n  editing: boolean;\r\n  onCancel: () => void;\r\n  onEdit: () => void;\r\n  onSubmit: (value: string) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  maxLength?: number;\r\n  placeholder?: string;\r\n  triggerMode: \"click\" | \"dblclick\" | \"focus\";\r\n  autosize: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  invalid?: boolean;\r\n}\r\n\r\nconst EditableContext = React.createContext<EditableContextValue | null>(null);\r\nEditableContext.displayName = ROOT_NAME;\r\n\r\nfunction useEditableContext(name: keyof typeof EDITABLE_ERROR) {\r\n  const context = React.useContext(EditableContext);\r\n  if (!context) {\r\n    throw new Error(EDITABLE_ERROR[name]);\r\n  }\r\n  return context;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof Editable>;\r\n\r\ninterface EditableRootProps\r\n  extends Omit<React.ComponentPropsWithoutRef<\"div\">, \"onSubmit\"> {\r\n  id?: string;\r\n  defaultValue?: string;\r\n  value?: string;\r\n  onValueChange?: (value: string) => void;\r\n  defaultEditing?: boolean;\r\n  editing?: boolean;\r\n  onEditingChange?: (editing: boolean) => void;\r\n  onCancel?: () => void;\r\n  onEdit?: () => void;\r\n  onSubmit?: (value: string) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  maxLength?: number;\r\n  name?: string;\r\n  placeholder?: string;\r\n  triggerMode?: EditableContextValue[\"triggerMode\"];\r\n  asChild?: boolean;\r\n  autosize?: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  invalid?: boolean;\r\n}\r\n\r\nconst EditableRoot = React.forwardRef<HTMLDivElement, EditableRootProps>(\r\n  (props, forwardedRef) => {\r\n    const {\r\n      id = React.useId(),\r\n      defaultValue = \"\",\r\n      value: valueProp,\r\n      onValueChange: onValueChangeProp,\r\n      defaultEditing = false,\r\n      editing: editingProp,\r\n      onEditingChange: onEditingChangeProp,\r\n      onCancel: onCancelProp,\r\n      onEdit: onEditProp,\r\n      onSubmit: onSubmitProp,\r\n      onEscapeKeyDown,\r\n      dir: dirProp,\r\n      maxLength,\r\n      name,\r\n      placeholder,\r\n      triggerMode = \"click\",\r\n      asChild,\r\n      autosize = false,\r\n      disabled,\r\n      required,\r\n      readOnly,\r\n      invalid,\r\n      className,\r\n      ...rootProps\r\n    } = props;\r\n\r\n    const inputId = React.useId();\r\n    const labelId = React.useId();\r\n\r\n    const dir = useDirection(dirProp);\r\n\r\n    const isControlled = valueProp !== undefined;\r\n    const [uncontrolledValue, setUncontrolledValue] =\r\n      React.useState(defaultValue);\r\n    const value = isControlled ? valueProp : uncontrolledValue;\r\n    const previousValueRef = React.useRef(value);\r\n    const onValueChangeRef = React.useRef(onValueChangeProp);\r\n\r\n    const isEditingControlled = editingProp !== undefined;\r\n    const [uncontrolledEditing, setUncontrolledEditing] =\r\n      React.useState(defaultEditing);\r\n    const editing = isEditingControlled ? editingProp : uncontrolledEditing;\r\n    const onEditingChangeRef = React.useRef(onEditingChangeProp);\r\n\r\n    React.useEffect(() => {\r\n      onValueChangeRef.current = onValueChangeProp;\r\n      onEditingChangeRef.current = onEditingChangeProp;\r\n    });\r\n\r\n    const onValueChange = React.useCallback(\r\n      (nextValue: string) => {\r\n        if (!isControlled) {\r\n          setUncontrolledValue(nextValue);\r\n        }\r\n        onValueChangeRef.current?.(nextValue);\r\n      },\r\n      [isControlled],\r\n    );\r\n\r\n    const onEditingChange = React.useCallback(\r\n      (nextEditing: boolean) => {\r\n        if (!isEditingControlled) {\r\n          setUncontrolledEditing(nextEditing);\r\n        }\r\n        onEditingChangeRef.current?.(nextEditing);\r\n      },\r\n      [isEditingControlled],\r\n    );\r\n\r\n    React.useEffect(() => {\r\n      if (isControlled && valueProp !== previousValueRef.current) {\r\n        previousValueRef.current = valueProp;\r\n      }\r\n    }, [isControlled, valueProp]);\r\n\r\n    const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n      null,\r\n    );\r\n    const composedRef = useComposedRefs(forwardedRef, (node) =>\r\n      setFormTrigger(node),\r\n    );\r\n    const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n    const onCancel = React.useCallback(() => {\r\n      const prevValue = previousValueRef.current;\r\n      onValueChange(prevValue);\r\n      onEditingChange(false);\r\n      onCancelProp?.();\r\n    }, [onValueChange, onCancelProp, onEditingChange]);\r\n\r\n    const onEdit = React.useCallback(() => {\r\n      previousValueRef.current = value;\r\n      onEditingChange(true);\r\n      onEditProp?.();\r\n    }, [value, onEditProp, onEditingChange]);\r\n\r\n    const onSubmit = React.useCallback(\r\n      (newValue: string) => {\r\n        onValueChange(newValue);\r\n        onEditingChange(false);\r\n        onSubmitProp?.(newValue);\r\n      },\r\n\r\n      [onValueChange, onSubmitProp, onEditingChange],\r\n    );\r\n\r\n    const contextValue = React.useMemo<EditableContextValue>(\r\n      () => ({\r\n        id,\r\n        inputId,\r\n        labelId,\r\n        defaultValue,\r\n        value,\r\n        onValueChange,\r\n        editing,\r\n        onSubmit,\r\n        onEdit,\r\n        onCancel,\r\n        onEscapeKeyDown,\r\n        dir,\r\n        maxLength,\r\n        placeholder,\r\n        triggerMode,\r\n        autosize,\r\n        disabled,\r\n        readOnly,\r\n        required,\r\n        invalid,\r\n      }),\r\n      [\r\n        id,\r\n        inputId,\r\n        labelId,\r\n        defaultValue,\r\n        value,\r\n        onValueChange,\r\n        editing,\r\n        onSubmit,\r\n        onCancel,\r\n        onEdit,\r\n        onEscapeKeyDown,\r\n        dir,\r\n        maxLength,\r\n        placeholder,\r\n        triggerMode,\r\n        autosize,\r\n        disabled,\r\n        required,\r\n        readOnly,\r\n        invalid,\r\n      ],\r\n    );\r\n\r\n    const RootSlot = asChild ? Slot : \"div\";\r\n\r\n    return (\r\n      <EditableContext.Provider value={contextValue}>\r\n        <RootSlot\r\n          data-slot=\"editable\"\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\"flex min-w-0 flex-col gap-2\", className)}\r\n        />\r\n        {isFormControl && (\r\n          <VisuallyHiddenInput\r\n            type=\"hidden\"\r\n            control={formTrigger}\r\n            name={name}\r\n            value={value}\r\n            disabled={disabled}\r\n            readOnly={readOnly}\r\n            required={required}\r\n          />\r\n        )}\r\n      </EditableContext.Provider>\r\n    );\r\n  },\r\n);\r\nEditableRoot.displayName = ROOT_NAME;\r\n\r\ninterface EditableLabelProps extends React.ComponentPropsWithoutRef<\"label\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst EditableLabel = React.forwardRef<HTMLLabelElement, EditableLabelProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, className, children, ...labelProps } = props;\r\n    const context = useEditableContext(LABEL_NAME);\r\n\r\n    const LabelSlot = asChild ? Slot : \"label\";\r\n\r\n    return (\r\n      <LabelSlot\r\n        data-disabled={context.disabled ? \"\" : undefined}\r\n        data-invalid={context.invalid ? \"\" : undefined}\r\n        data-required={context.required ? \"\" : undefined}\r\n        data-slot=\"editable-label\"\r\n        {...labelProps}\r\n        ref={forwardedRef}\r\n        id={context.labelId}\r\n        htmlFor={context.inputId}\r\n        className={cn(\r\n          \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 data-required:after:ml-0.5 data-required:after:text-destructive data-required:after:content-['*']\",\r\n          className,\r\n        )}\r\n      >\r\n        {children}\r\n      </LabelSlot>\r\n    );\r\n  },\r\n);\r\nEditableLabel.displayName = LABEL_NAME;\r\n\r\ninterface EditableAreaProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst EditableArea = React.forwardRef<HTMLDivElement, EditableAreaProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, className, ...areaProps } = props;\r\n    const context = useEditableContext(AREA_NAME);\r\n\r\n    const AreaSlot = asChild ? Slot : \"div\";\r\n\r\n    return (\r\n      <AreaSlot\r\n        role=\"group\"\r\n        data-disabled={context.disabled ? \"\" : undefined}\r\n        data-editing={context.editing ? \"\" : undefined}\r\n        data-slot=\"editable-area\"\r\n        dir={context.dir}\r\n        {...areaProps}\r\n        ref={forwardedRef}\r\n        className={cn(\r\n          \"relative inline-block min-w-0 data-disabled:cursor-not-allowed data-disabled:opacity-50\",\r\n          className,\r\n        )}\r\n      />\r\n    );\r\n  },\r\n);\r\nEditableArea.displayName = AREA_NAME;\r\n\r\ninterface EditablePreviewProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst EditablePreview = React.forwardRef<HTMLDivElement, EditablePreviewProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, className, ...previewProps } = props;\r\n    const context = useEditableContext(PREVIEW_NAME);\r\n\r\n    const onTrigger = React.useCallback(() => {\r\n      if (context.disabled || context.readOnly) return;\r\n      context.onEdit();\r\n    }, [context.disabled, context.readOnly, context.onEdit]);\r\n\r\n    const PreviewSlot = asChild ? Slot : \"div\";\r\n\r\n    if (context.editing || context.readOnly) return null;\r\n\r\n    return (\r\n      <PreviewSlot\r\n        role=\"button\"\r\n        aria-disabled={context.disabled || context.readOnly}\r\n        data-empty={!context.value ? \"\" : undefined}\r\n        data-disabled={context.disabled ? \"\" : undefined}\r\n        data-readonly={context.readOnly ? \"\" : undefined}\r\n        data-slot=\"editable-preview\"\r\n        tabIndex={context.disabled || context.readOnly ? undefined : 0}\r\n        {...previewProps}\r\n        ref={forwardedRef}\r\n        onClick={composeEventHandlers(\r\n          previewProps.onClick,\r\n          context.triggerMode === \"click\" ? onTrigger : undefined,\r\n        )}\r\n        onDoubleClick={composeEventHandlers(\r\n          previewProps.onDoubleClick,\r\n          context.triggerMode === \"dblclick\" ? onTrigger : undefined,\r\n        )}\r\n        onFocus={composeEventHandlers(\r\n          previewProps.onFocus,\r\n          context.triggerMode === \"focus\" ? onTrigger : undefined,\r\n        )}\r\n        className={cn(\r\n          \"cursor-text truncate rounded-sm border border-transparent py-1 text-base focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring data-disabled:cursor-not-allowed data-readonly:cursor-default data-empty:text-muted-foreground data-disabled:opacity-50 md:text-sm\",\r\n          className,\r\n        )}\r\n      >\r\n        {context.value || context.placeholder}\r\n      </PreviewSlot>\r\n    );\r\n  },\r\n);\r\nEditablePreview.displayName = PREVIEW_NAME;\r\n\r\ntype InputElement = React.ComponentRef<typeof EditableInput>;\r\n\r\ninterface EditableInputProps extends React.ComponentPropsWithoutRef<\"input\"> {\r\n  asChild?: boolean;\r\n  maxLength?: number;\r\n}\r\n\r\nconst EditableInput = React.forwardRef<HTMLInputElement, EditableInputProps>(\r\n  (props, forwardedRef) => {\r\n    const {\r\n      asChild,\r\n      className,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      maxLength,\r\n      ...inputProps\r\n    } = props;\r\n    const context = useEditableContext(INPUT_NAME);\r\n    const inputRef = React.useRef<InputElement>(null);\r\n    const composedRef = useComposedRefs(forwardedRef, inputRef);\r\n\r\n    const isDisabled = disabled || context.disabled;\r\n    const isReadOnly = readOnly || context.readOnly;\r\n    const isRequired = required || context.required;\r\n\r\n    const onAutosize = React.useCallback(\r\n      (target: HTMLInputElement | HTMLTextAreaElement) => {\r\n        if (!context.autosize) return;\r\n\r\n        if (target instanceof HTMLTextAreaElement) {\r\n          target.style.height = \"0\";\r\n          target.style.height = `${target.scrollHeight}px`;\r\n        } else {\r\n          target.style.width = \"0\";\r\n          target.style.width = `${target.scrollWidth + 4}px`;\r\n        }\r\n      },\r\n      [context.autosize],\r\n    );\r\n    const onBlur = React.useCallback(\r\n      (event: React.FocusEvent<InputElement>) => {\r\n        if (isReadOnly) return;\r\n        const relatedTarget = event.relatedTarget;\r\n\r\n        const isAction =\r\n          relatedTarget instanceof HTMLElement &&\r\n          relatedTarget.closest(`[${DATA_ACTION_ATTR}=\"\"]`);\r\n\r\n        if (!isAction) {\r\n          context.onSubmit(context.value);\r\n        }\r\n      },\r\n      [context.value, context.onSubmit, isReadOnly],\r\n    );\r\n\r\n    const onChange = React.useCallback(\r\n      (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\r\n        if (isReadOnly) return;\r\n        context.onValueChange(event.target.value);\r\n        onAutosize(event.target);\r\n      },\r\n      [context.onValueChange, isReadOnly, onAutosize],\r\n    );\r\n\r\n    const onKeyDown = React.useCallback(\r\n      (event: React.KeyboardEvent<InputElement>) => {\r\n        if (isReadOnly) return;\r\n        if (event.key === \"Escape\") {\r\n          const nativeEvent = event.nativeEvent;\r\n          if (context.onEscapeKeyDown) {\r\n            context.onEscapeKeyDown(nativeEvent);\r\n            if (nativeEvent.defaultPrevented) return;\r\n          }\r\n          context.onCancel();\r\n        } else if (event.key === \"Enter\") {\r\n          context.onSubmit(context.value);\r\n        }\r\n      },\r\n      [\r\n        context.value,\r\n        context.onSubmit,\r\n        context.onCancel,\r\n        context.onEscapeKeyDown,\r\n        isReadOnly,\r\n      ],\r\n    );\r\n\r\n    const useIsomorphicLayoutEffect =\r\n      typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\n    useIsomorphicLayoutEffect(() => {\r\n      if (!context.editing || isReadOnly || !inputRef.current) return;\r\n\r\n      const frameId = window.requestAnimationFrame(() => {\r\n        if (!inputRef.current) return;\r\n\r\n        inputRef.current.focus();\r\n        inputRef.current.select();\r\n        onAutosize(inputRef.current);\r\n      });\r\n\r\n      return () => {\r\n        window.cancelAnimationFrame(frameId);\r\n      };\r\n    }, [context.editing, isReadOnly, onAutosize]);\r\n\r\n    const InputSlot = asChild ? Slot : \"input\";\r\n\r\n    if (!context.editing && !isReadOnly) return null;\r\n\r\n    return (\r\n      <InputSlot\r\n        aria-required={isRequired}\r\n        aria-invalid={context.invalid}\r\n        data-slot=\"editable-input\"\r\n        dir={context.dir}\r\n        disabled={isDisabled}\r\n        readOnly={isReadOnly}\r\n        required={isRequired}\r\n        {...inputProps}\r\n        id={context.inputId}\r\n        aria-labelledby={context.labelId}\r\n        ref={composedRef}\r\n        maxLength={maxLength}\r\n        placeholder={context.placeholder}\r\n        value={context.value}\r\n        onBlur={composeEventHandlers(inputProps.onBlur, onBlur)}\r\n        onChange={composeEventHandlers(inputProps.onChange, onChange)}\r\n        onKeyDown={composeEventHandlers(inputProps.onKeyDown, onKeyDown)}\r\n        className={cn(\r\n          \"flex rounded-sm border border-input bg-transparent py-1 text-base shadow-xs transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n          context.autosize ? \"w-auto\" : \"w-full\",\r\n          className,\r\n        )}\r\n      />\r\n    );\r\n  },\r\n);\r\nEditableInput.displayName = INPUT_NAME;\r\n\r\ninterface EditableTriggerProps\r\n  extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n  forceMount?: boolean;\r\n}\r\n\r\nconst EditableTrigger = React.forwardRef<\r\n  HTMLButtonElement,\r\n  EditableTriggerProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, forceMount = false, ...triggerProps } = props;\r\n  const context = useEditableContext(TRIGGER_NAME);\r\n\r\n  const onTrigger = React.useCallback(() => {\r\n    if (context.disabled || context.readOnly) return;\r\n    context.onEdit();\r\n  }, [context.disabled, context.readOnly, context.onEdit]);\r\n\r\n  const TriggerSlot = asChild ? Slot : \"button\";\r\n\r\n  if (!forceMount && (context.editing || context.readOnly)) return null;\r\n\r\n  return (\r\n    <TriggerSlot\r\n      type=\"button\"\r\n      aria-controls={context.id}\r\n      aria-disabled={context.disabled || context.readOnly}\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-readonly={context.readOnly ? \"\" : undefined}\r\n      data-slot=\"editable-trigger\"\r\n      {...triggerProps}\r\n      ref={forwardedRef}\r\n      onClick={context.triggerMode === \"click\" ? onTrigger : undefined}\r\n      onDoubleClick={context.triggerMode === \"dblclick\" ? onTrigger : undefined}\r\n    />\r\n  );\r\n});\r\nEditableTrigger.displayName = TRIGGER_NAME;\r\n\r\ninterface EditableToolbarProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n  orientation?: \"horizontal\" | \"vertical\";\r\n}\r\n\r\nconst EditableToolbar = React.forwardRef<HTMLDivElement, EditableToolbarProps>(\r\n  (props, forwardedRef) => {\r\n    const {\r\n      asChild,\r\n      className,\r\n      orientation = \"horizontal\",\r\n      ...toolbarProps\r\n    } = props;\r\n    const context = useEditableContext(TOOLBAR_NAME);\r\n\r\n    const ToolbarSlot = asChild ? Slot : \"div\";\r\n\r\n    return (\r\n      <ToolbarSlot\r\n        role=\"toolbar\"\r\n        aria-controls={context.id}\r\n        aria-orientation={orientation}\r\n        data-slot=\"editable-toolbar\"\r\n        dir={context.dir}\r\n        {...toolbarProps}\r\n        ref={forwardedRef}\r\n        className={cn(\r\n          \"flex items-center gap-2\",\r\n          orientation === \"vertical\" && \"flex-col\",\r\n          className,\r\n        )}\r\n      />\r\n    );\r\n  },\r\n);\r\nEditableToolbar.displayName = TOOLBAR_NAME;\r\n\r\ninterface EditableCancelProps extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst EditableCancel = React.forwardRef<HTMLButtonElement, EditableCancelProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, ...cancelProps } = props;\r\n    const context = useEditableContext(CANCEL_NAME);\r\n\r\n    const CancelSlot = asChild ? Slot : \"button\";\r\n\r\n    if (!context.editing && !context.readOnly) return null;\r\n\r\n    return (\r\n      <CancelSlot\r\n        type=\"button\"\r\n        aria-controls={context.id}\r\n        data-slot=\"editable-cancel\"\r\n        {...{ [DATA_ACTION_ATTR]: \"\" }}\r\n        {...cancelProps}\r\n        onClick={composeEventHandlers(cancelProps.onClick, () => {\r\n          context.onCancel();\r\n        })}\r\n        ref={forwardedRef}\r\n      />\r\n    );\r\n  },\r\n);\r\nEditableCancel.displayName = CANCEL_NAME;\r\n\r\ninterface EditableSubmitProps extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst EditableSubmit = React.forwardRef<HTMLButtonElement, EditableSubmitProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, ...submitProps } = props;\r\n    const context = useEditableContext(SUBMIT_NAME);\r\n\r\n    const SubmitSlot = asChild ? Slot : \"button\";\r\n\r\n    if (!context.editing && !context.readOnly) return null;\r\n\r\n    return (\r\n      <SubmitSlot\r\n        type=\"button\"\r\n        aria-controls={context.id}\r\n        data-slot=\"editable-submit\"\r\n        {...{ [DATA_ACTION_ATTR]: \"\" }}\r\n        {...submitProps}\r\n        ref={forwardedRef}\r\n        onClick={composeEventHandlers(submitProps.onClick, () => {\r\n          context.onSubmit(context.value);\r\n        })}\r\n      />\r\n    );\r\n  },\r\n);\r\nEditableSubmit.displayName = SUBMIT_NAME;\r\n\r\n/**\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/checkbox/src/checkbox.tsx#L165-L212\r\n */\r\n\r\ninterface VisuallyHiddenInputProps<T extends HTMLElement>\r\n  extends React.ComponentPropsWithoutRef<\"input\"> {\r\n  control: T | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T extends HTMLElement>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    ...inputProps\r\n  } = props;\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const previousRef = React.useRef({ value, previous: value });\r\n  const previousValue = React.useMemo(() => {\r\n    if (inputRef.current?.value !== value) {\r\n      previousRef.current.previous = previousRef.current.value;\r\n      previousRef.current.value = value;\r\n    }\r\n    return previousRef.current.previous;\r\n  }, [value]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n\r\n    const propertyKey = \"value\";\r\n    const eventType = \"input\";\r\n    const currentValue = JSON.stringify(value);\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(\r\n      inputProto,\r\n      propertyKey,\r\n    ) as PropertyDescriptor;\r\n    const setter = descriptor.set;\r\n\r\n    if (previousValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, currentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [previousValue, value, bubbles]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      style={{\r\n        ...props.style,\r\n        border: 0,\r\n        clip: \"rect(0 0 0 0)\",\r\n        clipPath: \"inset(50%)\",\r\n        height: \"1px\",\r\n        margin: \"-1px\",\r\n        overflow: \"hidden\",\r\n        padding: 0,\r\n        position: \"absolute\",\r\n        whiteSpace: \"nowrap\",\r\n        width: \"1px\",\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\nconst Editable = EditableRoot;\r\nconst Root = EditableRoot;\r\nconst Label = EditableLabel;\r\nconst Area = EditableArea;\r\nconst Preview = EditablePreview;\r\nconst Input = EditableInput;\r\nconst Trigger = EditableTrigger;\r\nconst Toolbar = EditableToolbar;\r\nconst Cancel = EditableCancel;\r\nconst Submit = EditableSubmit;\r\n\r\nexport {\r\n  Editable,\r\n  EditableLabel,\r\n  EditableArea,\r\n  EditablePreview,\r\n  EditableInput,\r\n  EditableToolbar,\r\n  EditableCancel,\r\n  EditableSubmit,\r\n  EditableTrigger,\r\n  //\r\n  Root,\r\n  Label,\r\n  Area,\r\n  Preview,\r\n  Input,\r\n  Toolbar,\r\n  Cancel,\r\n  Submit,\r\n  Trigger,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/composition.ts",
      "content": "import * as React from \"react\";\n\n/**\n * A utility to compose multiple event handlers into a single event handler.\n * Run originalEventHandler first, then ourEventHandler unless prevented.\n */\nfunction composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (\n      checkForDefaultPrevented === false ||\n      !(event as unknown as Event).defaultPrevented\n    ) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value.\n * This utility takes care of different types of refs: callback refs and RefObject(s).\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together.\n * Accepts callback refs and RefObject(s).\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs.\n * Accepts callback refs and RefObject(s).\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeEventHandlers, composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}