{
  "name": "editable",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/editable.tsx",
      "content": "\"use client\";\n\nimport { composeEventHandlers, useComposedRefs } from \"@/lib/composition\";\nimport { cn } from \"@/lib/utils\";\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\n\nconst DATA_ACTION_ATTR = \"data-action\";\n\nconst ROOT_NAME = \"Editable\";\nconst AREA_NAME = \"EditableArea\";\nconst PREVIEW_NAME = \"EditablePreview\";\nconst INPUT_NAME = \"EditableInput\";\nconst TRIGGER_NAME = \"EditableTrigger\";\nconst LABEL_NAME = \"EditableLabel\";\nconst TOOLBAR_NAME = \"EditableToolbar\";\nconst CANCEL_NAME = \"EditableCancel\";\nconst SUBMIT_NAME = \"EditableSubmit\";\n\nconst EDITABLE_ERRORS = {\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` components must be within \\`${ROOT_NAME}\\``,\n  [AREA_NAME]: `\\`${AREA_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [PREVIEW_NAME]: `\\`${PREVIEW_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [INPUT_NAME]: `\\`${INPUT_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [TRIGGER_NAME]: `\\`${TRIGGER_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [LABEL_NAME]: `\\`${LABEL_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [TOOLBAR_NAME]: `\\`${TOOLBAR_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [CANCEL_NAME]: `\\`${CANCEL_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [SUBMIT_NAME]: `\\`${SUBMIT_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n} as const;\n\ntype Direction = \"ltr\" | \"rtl\";\n\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\nfunction useDirection(dirProp?: Direction): Direction {\n  const contextDir = React.useContext(DirectionContext);\n  return dirProp ?? contextDir ?? \"ltr\";\n}\n\ninterface EditableContextValue {\n  id: string;\n  inputId: string;\n  labelId: string;\n  defaultValue: string;\n  value: string;\n  onValueChange: (value: string) => void;\n  editing: boolean;\n  onCancel: () => void;\n  onEdit: () => void;\n  onSubmit: (value: string) => void;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  dir?: Direction;\n  maxLength?: number;\n  placeholder?: string;\n  triggerMode: \"click\" | \"dblclick\" | \"focus\";\n  autosize: boolean;\n  disabled?: boolean;\n  readOnly?: boolean;\n  required?: boolean;\n  invalid?: boolean;\n}\n\nconst EditableContext = React.createContext<EditableContextValue | null>(null);\nEditableContext.displayName = ROOT_NAME;\n\nfunction useEditableContext(name: keyof typeof EDITABLE_ERRORS) {\n  const context = React.useContext(EditableContext);\n  if (!context) {\n    throw new Error(EDITABLE_ERRORS[name]);\n  }\n  return context;\n}\n\ntype RootElement = React.ComponentRef<typeof Editable>;\n\ninterface EditableRootProps\n  extends Omit<React.ComponentPropsWithoutRef<\"div\">, \"onSubmit\"> {\n  id?: string;\n  defaultValue?: string;\n  value?: string;\n  onValueChange?: (value: string) => void;\n  defaultEditing?: boolean;\n  editing?: boolean;\n  onEditingChange?: (editing: boolean) => void;\n  onCancel?: () => void;\n  onEdit?: () => void;\n  onSubmit?: (value: string) => void;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  dir?: Direction;\n  maxLength?: number;\n  name?: string;\n  placeholder?: string;\n  triggerMode?: EditableContextValue[\"triggerMode\"];\n  asChild?: boolean;\n  autosize?: boolean;\n  disabled?: boolean;\n  readOnly?: boolean;\n  required?: boolean;\n  invalid?: boolean;\n}\n\nconst EditableRoot = React.forwardRef<HTMLDivElement, EditableRootProps>(\n  (props, forwardedRef) => {\n    const {\n      defaultValue = \"\",\n      value: valueProp,\n      onValueChange: onValueChangeProp,\n      defaultEditing = false,\n      editing: editingProp,\n      onEditingChange: onEditingChangeProp,\n      onCancel: onCancelProp,\n      onEdit: onEditProp,\n      onSubmit: onSubmitProp,\n      onEscapeKeyDown,\n      dir: dirProp,\n      maxLength,\n      name,\n      placeholder,\n      triggerMode = \"click\",\n      asChild,\n      autosize = false,\n      disabled,\n      required,\n      readOnly,\n      invalid,\n      className,\n      ...rootProps\n    } = props;\n\n    const id = React.useId();\n    const inputId = React.useId();\n    const labelId = React.useId();\n\n    const dir = useDirection(dirProp);\n\n    const isControlled = valueProp !== undefined;\n    const [uncontrolledValue, setUncontrolledValue] =\n      React.useState(defaultValue);\n    const value = isControlled ? valueProp : uncontrolledValue;\n    const previousValueRef = React.useRef(value);\n    const onValueChangeRef = React.useRef(onValueChangeProp);\n\n    const isEditingControlled = editingProp !== undefined;\n    const [uncontrolledEditing, setUncontrolledEditing] =\n      React.useState(defaultEditing);\n    const editing = isEditingControlled ? editingProp : uncontrolledEditing;\n    const onEditingChangeRef = React.useRef(onEditingChangeProp);\n\n    React.useEffect(() => {\n      onValueChangeRef.current = onValueChangeProp;\n      onEditingChangeRef.current = onEditingChangeProp;\n    });\n\n    const onValueChange = React.useCallback(\n      (nextValue: string) => {\n        if (!isControlled) {\n          setUncontrolledValue(nextValue);\n        }\n        onValueChangeRef.current?.(nextValue);\n      },\n      [isControlled],\n    );\n\n    const onEditingChange = React.useCallback(\n      (nextEditing: boolean) => {\n        if (!isEditingControlled) {\n          setUncontrolledEditing(nextEditing);\n        }\n        onEditingChangeRef.current?.(nextEditing);\n      },\n      [isEditingControlled],\n    );\n\n    React.useEffect(() => {\n      if (isControlled && valueProp !== previousValueRef.current) {\n        previousValueRef.current = valueProp;\n      }\n    }, [isControlled, valueProp]);\n\n    const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\n      null,\n    );\n    const composedRef = useComposedRefs(forwardedRef, (node) =>\n      setFormTrigger(node),\n    );\n    const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\n\n    const onCancel = React.useCallback(() => {\n      const prevValue = previousValueRef.current;\n      onValueChange(prevValue);\n      onEditingChange(false);\n      onCancelProp?.();\n    }, [onValueChange, onCancelProp, onEditingChange]);\n\n    const onEdit = React.useCallback(() => {\n      previousValueRef.current = value;\n      onEditingChange(true);\n      onEditProp?.();\n    }, [value, onEditProp, onEditingChange]);\n\n    const onSubmit = React.useCallback(\n      (newValue: string) => {\n        onValueChange(newValue);\n        onEditingChange(false);\n        onSubmitProp?.(newValue);\n      },\n\n      [onValueChange, onSubmitProp, onEditingChange],\n    );\n\n    const contextValue = React.useMemo<EditableContextValue>(\n      () => ({\n        id,\n        inputId,\n        labelId,\n        defaultValue,\n        value,\n        onValueChange,\n        editing,\n        onSubmit,\n        onEdit,\n        onCancel,\n        onEscapeKeyDown,\n        dir,\n        maxLength,\n        placeholder,\n        triggerMode,\n        autosize,\n        disabled,\n        readOnly,\n        required,\n        invalid,\n      }),\n      [\n        id,\n        inputId,\n        labelId,\n        defaultValue,\n        value,\n        onValueChange,\n        editing,\n        onSubmit,\n        onCancel,\n        onEdit,\n        onEscapeKeyDown,\n        dir,\n        maxLength,\n        placeholder,\n        triggerMode,\n        autosize,\n        disabled,\n        required,\n        readOnly,\n        invalid,\n      ],\n    );\n\n    const RootPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <EditableContext.Provider value={contextValue}>\n        <RootPrimitive\n          data-slot=\"editable\"\n          {...rootProps}\n          id={id}\n          ref={composedRef}\n          className={cn(\"flex min-w-0 flex-col gap-2\", className)}\n        />\n        {isFormControl && (\n          <VisuallyHiddenInput\n            type=\"hidden\"\n            control={formTrigger}\n            name={name}\n            value={value}\n            disabled={disabled}\n            readOnly={readOnly}\n            required={required}\n          />\n        )}\n      </EditableContext.Provider>\n    );\n  },\n);\nEditableRoot.displayName = ROOT_NAME;\n\ninterface EditableLabelProps extends React.ComponentPropsWithoutRef<\"label\"> {\n  asChild?: boolean;\n}\n\nconst EditableLabel = React.forwardRef<HTMLLabelElement, EditableLabelProps>(\n  (props, forwardedRef) => {\n    const { asChild, className, children, ...labelProps } = props;\n    const context = useEditableContext(LABEL_NAME);\n\n    const LabelPrimitive = asChild ? Slot : \"label\";\n\n    return (\n      <LabelPrimitive\n        data-disabled={context.disabled ? \"\" : undefined}\n        data-invalid={context.invalid ? \"\" : undefined}\n        data-required={context.required ? \"\" : undefined}\n        data-slot=\"editable-label\"\n        {...labelProps}\n        ref={forwardedRef}\n        id={context.labelId}\n        htmlFor={context.inputId}\n        className={cn(\n          \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 data-required:after:ml-0.5 data-required:after:text-destructive data-required:after:content-['*']\",\n          className,\n        )}\n      >\n        {children}\n      </LabelPrimitive>\n    );\n  },\n);\nEditableLabel.displayName = LABEL_NAME;\n\ninterface EditableAreaProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst EditableArea = React.forwardRef<HTMLDivElement, EditableAreaProps>(\n  (props, forwardedRef) => {\n    const { asChild, className, ...areaProps } = props;\n    const context = useEditableContext(AREA_NAME);\n\n    const AreaPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <AreaPrimitive\n        role=\"group\"\n        data-disabled={context.disabled ? \"\" : undefined}\n        data-editing={context.editing ? \"\" : undefined}\n        data-slot=\"editable-area\"\n        dir={context.dir}\n        {...areaProps}\n        ref={forwardedRef}\n        className={cn(\n          \"relative inline-block min-w-0 data-disabled:cursor-not-allowed data-disabled:opacity-50\",\n          className,\n        )}\n      />\n    );\n  },\n);\nEditableArea.displayName = AREA_NAME;\n\ninterface EditablePreviewProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst EditablePreview = React.forwardRef<HTMLDivElement, EditablePreviewProps>(\n  (props, forwardedRef) => {\n    const { asChild, className, ...previewProps } = props;\n    const context = useEditableContext(PREVIEW_NAME);\n\n    const onTrigger = React.useCallback(() => {\n      if (context.disabled || context.readOnly) return;\n      context.onEdit();\n    }, [context.disabled, context.readOnly, context.onEdit]);\n\n    const PreviewPrimitive = asChild ? Slot : \"div\";\n\n    if (context.editing || context.readOnly) return null;\n\n    return (\n      <PreviewPrimitive\n        role=\"button\"\n        aria-disabled={context.disabled || context.readOnly}\n        data-empty={!context.value ? \"\" : undefined}\n        data-disabled={context.disabled ? \"\" : undefined}\n        data-readonly={context.readOnly ? \"\" : undefined}\n        data-slot=\"editable-preview\"\n        tabIndex={context.disabled || context.readOnly ? undefined : 0}\n        {...previewProps}\n        ref={forwardedRef}\n        onClick={composeEventHandlers(\n          previewProps.onClick,\n          context.triggerMode === \"click\" ? onTrigger : undefined,\n        )}\n        onDoubleClick={composeEventHandlers(\n          previewProps.onDoubleClick,\n          context.triggerMode === \"dblclick\" ? onTrigger : undefined,\n        )}\n        onFocus={composeEventHandlers(\n          previewProps.onFocus,\n          context.triggerMode === \"focus\" ? onTrigger : undefined,\n        )}\n        className={cn(\n          \"cursor-text truncate rounded-sm border border-transparent py-1 text-base focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring data-disabled:cursor-not-allowed data-readonly:cursor-default data-empty:text-muted-foreground data-disabled:opacity-50 md:text-sm\",\n          className,\n        )}\n      >\n        {context.value || context.placeholder}\n      </PreviewPrimitive>\n    );\n  },\n);\nEditablePreview.displayName = PREVIEW_NAME;\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\ntype InputElement = React.ComponentRef<typeof EditableInput>;\n\ninterface EditableInputProps extends React.ComponentPropsWithoutRef<\"input\"> {\n  asChild?: boolean;\n  maxLength?: number;\n}\n\nconst EditableInput = React.forwardRef<HTMLInputElement, EditableInputProps>(\n  (props, forwardedRef) => {\n    const {\n      asChild,\n      className,\n      disabled,\n      readOnly,\n      required,\n      maxLength,\n      ...inputProps\n    } = props;\n    const context = useEditableContext(INPUT_NAME);\n    const inputRef = React.useRef<InputElement>(null);\n    const composedRef = useComposedRefs(forwardedRef, inputRef);\n\n    const isDisabled = disabled || context.disabled;\n    const isReadOnly = readOnly || context.readOnly;\n    const isRequired = required || context.required;\n\n    const onAutosize = React.useCallback(\n      (target: HTMLInputElement | HTMLTextAreaElement) => {\n        if (!context.autosize) return;\n\n        if (target instanceof HTMLTextAreaElement) {\n          target.style.height = \"0\";\n          target.style.height = `${target.scrollHeight}px`;\n        } else {\n          target.style.width = \"0\";\n          target.style.width = `${target.scrollWidth + 4}px`;\n        }\n      },\n      [context.autosize],\n    );\n    const onBlur = React.useCallback(\n      (event: React.FocusEvent<InputElement>) => {\n        if (isReadOnly) return;\n        const relatedTarget = event.relatedTarget;\n\n        const isAction =\n          relatedTarget instanceof HTMLElement &&\n          relatedTarget.closest(`[${DATA_ACTION_ATTR}=\"\"]`);\n\n        if (!isAction) {\n          context.onSubmit(context.value);\n        }\n      },\n      [context.value, context.onSubmit, isReadOnly],\n    );\n\n    const onChange = React.useCallback(\n      (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n        if (isReadOnly) return;\n        context.onValueChange(event.target.value);\n        onAutosize(event.target);\n      },\n      [context.onValueChange, isReadOnly, onAutosize],\n    );\n\n    const onKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<InputElement>) => {\n        if (isReadOnly) return;\n        if (event.key === \"Escape\") {\n          const nativeEvent = event.nativeEvent;\n          if (context.onEscapeKeyDown) {\n            context.onEscapeKeyDown(nativeEvent);\n            if (nativeEvent.defaultPrevented) return;\n          }\n          context.onCancel();\n        } else if (event.key === \"Enter\") {\n          context.onSubmit(context.value);\n        }\n      },\n      [\n        context.value,\n        context.onSubmit,\n        context.onCancel,\n        context.onEscapeKeyDown,\n        isReadOnly,\n      ],\n    );\n\n    useIsomorphicLayoutEffect(() => {\n      if (!context.editing || isReadOnly || !inputRef.current) return;\n\n      const frameId = window.requestAnimationFrame(() => {\n        if (!inputRef.current) return;\n\n        inputRef.current.focus();\n        inputRef.current.select();\n        onAutosize(inputRef.current);\n      });\n\n      return () => {\n        window.cancelAnimationFrame(frameId);\n      };\n    }, [context.editing, isReadOnly, onAutosize]);\n\n    const InputPrimitive = asChild ? Slot : \"input\";\n\n    if (!context.editing && !isReadOnly) return null;\n\n    return (\n      <InputPrimitive\n        aria-required={isRequired}\n        aria-invalid={context.invalid}\n        data-slot=\"editable-input\"\n        dir={context.dir}\n        disabled={isDisabled}\n        readOnly={isReadOnly}\n        required={isRequired}\n        {...inputProps}\n        id={context.inputId}\n        aria-labelledby={context.labelId}\n        ref={composedRef}\n        maxLength={maxLength}\n        placeholder={context.placeholder}\n        value={context.value}\n        onBlur={composeEventHandlers(inputProps.onBlur, onBlur)}\n        onChange={composeEventHandlers(inputProps.onChange, onChange)}\n        onKeyDown={composeEventHandlers(inputProps.onKeyDown, onKeyDown)}\n        className={cn(\n          \"flex rounded-sm border border-input bg-transparent py-1 text-base shadow-xs transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          context.autosize ? \"w-auto\" : \"w-full\",\n          className,\n        )}\n      />\n    );\n  },\n);\nEditableInput.displayName = INPUT_NAME;\n\ninterface EditableTriggerProps\n  extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n  forceMount?: boolean;\n}\n\nconst EditableTrigger = React.forwardRef<\n  HTMLButtonElement,\n  EditableTriggerProps\n>((props, forwardedRef) => {\n  const { asChild, forceMount = false, ...triggerProps } = props;\n  const context = useEditableContext(TRIGGER_NAME);\n\n  const onTrigger = React.useCallback(() => {\n    if (context.disabled || context.readOnly) return;\n    context.onEdit();\n  }, [context.disabled, context.readOnly, context.onEdit]);\n\n  const TriggerPrimitive = asChild ? Slot : \"button\";\n\n  if (!forceMount && (context.editing || context.readOnly)) return null;\n\n  return (\n    <TriggerPrimitive\n      type=\"button\"\n      aria-controls={context.id}\n      aria-disabled={context.disabled || context.readOnly}\n      data-disabled={context.disabled ? \"\" : undefined}\n      data-readonly={context.readOnly ? \"\" : undefined}\n      data-slot=\"editable-trigger\"\n      {...triggerProps}\n      ref={forwardedRef}\n      onClick={context.triggerMode === \"click\" ? onTrigger : undefined}\n      onDoubleClick={context.triggerMode === \"dblclick\" ? onTrigger : undefined}\n    />\n  );\n});\nEditableTrigger.displayName = TRIGGER_NAME;\n\ninterface EditableToolbarProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n  orientation?: \"horizontal\" | \"vertical\";\n}\n\nconst EditableToolbar = React.forwardRef<HTMLDivElement, EditableToolbarProps>(\n  (props, forwardedRef) => {\n    const {\n      asChild,\n      className,\n      orientation = \"horizontal\",\n      ...toolbarProps\n    } = props;\n    const context = useEditableContext(TOOLBAR_NAME);\n\n    const ToolbarPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <ToolbarPrimitive\n        role=\"toolbar\"\n        aria-controls={context.id}\n        aria-orientation={orientation}\n        data-slot=\"editable-toolbar\"\n        dir={context.dir}\n        {...toolbarProps}\n        ref={forwardedRef}\n        className={cn(\n          \"flex items-center gap-2\",\n          orientation === \"vertical\" && \"flex-col\",\n          className,\n        )}\n      />\n    );\n  },\n);\nEditableToolbar.displayName = TOOLBAR_NAME;\n\ninterface EditableCancelProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst EditableCancel = React.forwardRef<HTMLButtonElement, EditableCancelProps>(\n  (props, forwardedRef) => {\n    const { asChild, ...cancelProps } = props;\n    const context = useEditableContext(CANCEL_NAME);\n\n    const CancelPrimitive = asChild ? Slot : \"button\";\n\n    if (!context.editing && !context.readOnly) return null;\n\n    return (\n      <CancelPrimitive\n        type=\"button\"\n        aria-controls={context.id}\n        data-slot=\"editable-cancel\"\n        {...{ [DATA_ACTION_ATTR]: \"\" }}\n        {...cancelProps}\n        onClick={composeEventHandlers(cancelProps.onClick, () => {\n          context.onCancel();\n        })}\n        ref={forwardedRef}\n      />\n    );\n  },\n);\nEditableCancel.displayName = CANCEL_NAME;\n\ninterface EditableSubmitProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst EditableSubmit = React.forwardRef<HTMLButtonElement, EditableSubmitProps>(\n  (props, forwardedRef) => {\n    const { asChild, ...submitProps } = props;\n    const context = useEditableContext(SUBMIT_NAME);\n\n    const SubmitPrimitive = asChild ? Slot : \"button\";\n\n    if (!context.editing && !context.readOnly) return null;\n\n    return (\n      <SubmitPrimitive\n        type=\"button\"\n        aria-controls={context.id}\n        data-slot=\"editable-submit\"\n        {...{ [DATA_ACTION_ATTR]: \"\" }}\n        {...submitProps}\n        ref={forwardedRef}\n        onClick={composeEventHandlers(submitProps.onClick, () => {\n          context.onSubmit(context.value);\n        })}\n      />\n    );\n  },\n);\nEditableSubmit.displayName = SUBMIT_NAME;\n\nconst Editable = EditableRoot;\nconst Root = EditableRoot;\nconst Label = EditableLabel;\nconst Area = EditableArea;\nconst Preview = EditablePreview;\nconst Input = EditableInput;\nconst Trigger = EditableTrigger;\nconst Toolbar = EditableToolbar;\nconst Cancel = EditableCancel;\nconst Submit = EditableSubmit;\n\nexport {\n  Editable,\n  EditableLabel,\n  EditableArea,\n  EditablePreview,\n  EditableInput,\n  EditableToolbar,\n  EditableCancel,\n  EditableSubmit,\n  EditableTrigger,\n  //\n  Root,\n  Label,\n  Area,\n  Preview,\n  Input,\n  Toolbar,\n  Cancel,\n  Submit,\n  Trigger,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/composition.ts",
      "content": "import * as React from \"react\";\n\n/**\n * A utility to compose multiple event handlers into a single event handler.\n * Run originalEventHandler first, then ourEventHandler unless prevented.\n */\nfunction composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (\n      checkForDefaultPrevented === false ||\n      !(event as unknown as Event).defaultPrevented\n    ) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value.\n * This utility takes care of different types of refs: callback refs and RefObject(s).\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together.\n * Accepts callback refs and RefObject(s).\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs.\n * Accepts callback refs and RefObject(s).\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeEventHandlers, composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}