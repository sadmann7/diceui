{
  "name": "editable",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/editable.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\r\n\r\nconst ROOT_NAME = \"Editable\";\r\nconst LABEL_NAME = \"EditableLabel\";\r\nconst AREA_NAME = \"EditableArea\";\r\nconst PREVIEW_NAME = \"EditablePreview\";\r\nconst INPUT_NAME = \"EditableInput\";\r\nconst TRIGGER_NAME = \"EditableTrigger\";\r\nconst TOOLBAR_NAME = \"EditableToolbar\";\r\nconst CANCEL_NAME = \"EditableCancel\";\r\nconst SUBMIT_NAME = \"EditableSubmit\";\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\r\n\r\nfunction useDirection(dirProp?: Direction): Direction {\r\n  const contextDir = React.useContext(DirectionContext);\r\n  return dirProp ?? contextDir ?? \"ltr\";\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\ninterface StoreState {\r\n  value: string;\r\n  editing: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nfunction createStore(\r\n  listenersRef: React.RefObject<Set<() => void>>,\r\n  stateRef: React.RefObject<StoreState>,\r\n  onValueChange?: (value: string) => void,\r\n  onEditingChange?: (editing: boolean) => void,\r\n): Store {\r\n  const store: Store = {\r\n    subscribe: (cb) => {\r\n      if (listenersRef.current) {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current?.delete(cb);\r\n      }\r\n      return () => {};\r\n    },\r\n    getState: () =>\r\n      stateRef.current ?? {\r\n        value: \"\",\r\n        editing: false,\r\n      },\r\n    setState: (key, value) => {\r\n      const state = stateRef.current;\r\n      if (!state || Object.is(state[key], value)) return;\r\n\r\n      if (key === \"value\" && typeof value === \"string\") {\r\n        state.value = value;\r\n        onValueChange?.(value);\r\n      } else if (key === \"editing\" && typeof value === \"boolean\") {\r\n        state.editing = value;\r\n        onEditingChange?.(value);\r\n      } else {\r\n        state[key] = value;\r\n      }\r\n\r\n      store.notify();\r\n    },\r\n    notify: () => {\r\n      if (listenersRef.current) {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      }\r\n    },\r\n  };\r\n\r\n  return store;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface EditableContextValue {\r\n  id: string;\r\n  inputId: string;\r\n  labelId: string;\r\n  defaultValue: string;\r\n  onCancel: () => void;\r\n  onEdit: () => void;\r\n  onSubmit: (value: string) => void;\r\n  onEnterKeyDown?: (event: KeyboardEvent) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  maxLength?: number;\r\n  placeholder?: string;\r\n  triggerMode: \"click\" | \"dblclick\" | \"focus\";\r\n  autosize: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  invalid?: boolean;\r\n}\r\n\r\nconst EditableContext = React.createContext<EditableContextValue | null>(null);\r\n\r\nfunction useEditableContext(consumerName: string) {\r\n  const context = React.useContext(EditableContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof EditableRoot>;\r\n\r\ninterface EditableRootProps\r\n  extends Omit<React.ComponentProps<\"div\">, \"onSubmit\"> {\r\n  id?: string;\r\n  defaultValue?: string;\r\n  value?: string;\r\n  onValueChange?: (value: string) => void;\r\n  defaultEditing?: boolean;\r\n  editing?: boolean;\r\n  onEditingChange?: (editing: boolean) => void;\r\n  onCancel?: () => void;\r\n  onEdit?: () => void;\r\n  onSubmit?: (value: string) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  onEnterKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  maxLength?: number;\r\n  name?: string;\r\n  placeholder?: string;\r\n  triggerMode?: EditableContextValue[\"triggerMode\"];\r\n  asChild?: boolean;\r\n  autosize?: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  invalid?: boolean;\r\n}\r\n\r\nfunction EditableRoot(props: EditableRootProps) {\r\n  const {\r\n    value,\r\n    defaultValue,\r\n    defaultEditing,\r\n    editing,\r\n    onValueChange,\r\n    onEditingChange,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    value: value ?? defaultValue ?? \"\",\r\n    editing: editing ?? defaultEditing ?? false,\r\n  }));\r\n\r\n  const store = React.useMemo(\r\n    () => createStore(listenersRef, stateRef, onValueChange, onEditingChange),\r\n    [listenersRef, stateRef, onValueChange, onEditingChange],\r\n  );\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <EditableRootImpl\r\n        value={value}\r\n        defaultValue={defaultValue}\r\n        editing={editing}\r\n        {...rootProps}\r\n      />\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nfunction EditableRootImpl(\r\n  props: Omit<EditableRootProps, \"onValueChange\" | \"onEditingChange\">,\r\n) {\r\n  const {\r\n    defaultValue = \"\",\r\n    value: valueProp,\r\n    editing: editingProp,\r\n    onCancel: onCancelProp,\r\n    onEdit: onEditProp,\r\n    onSubmit: onSubmitProp,\r\n    onEscapeKeyDown,\r\n    onEnterKeyDown,\r\n    id: idProp,\r\n    dir: dirProp,\r\n    maxLength,\r\n    name,\r\n    placeholder,\r\n    triggerMode = \"click\",\r\n    asChild,\r\n    autosize = false,\r\n    disabled,\r\n    required,\r\n    readOnly,\r\n    invalid,\r\n    className,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const rootId = React.useId();\r\n  const inputId = React.useId();\r\n  const labelId = React.useId();\r\n\r\n  const id = idProp ?? rootId;\r\n\r\n  const dir = useDirection(dirProp);\r\n  const store = useStoreContext(ROOT_NAME);\r\n\r\n  const previousValueRef = React.useRef(defaultValue);\r\n\r\n  React.useEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp, store]);\r\n\r\n  React.useEffect(() => {\r\n    if (editingProp !== undefined) {\r\n      store.setState(\"editing\", editingProp);\r\n    }\r\n  }, [editingProp, store]);\r\n\r\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\r\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n  const onCancel = React.useCallback(() => {\r\n    const prevValue = previousValueRef.current;\r\n    store.setState(\"value\", prevValue);\r\n    store.setState(\"editing\", false);\r\n    onCancelProp?.();\r\n  }, [store, onCancelProp]);\r\n\r\n  const onEdit = React.useCallback(() => {\r\n    const currentValue = store.getState().value;\r\n    previousValueRef.current = currentValue;\r\n    store.setState(\"editing\", true);\r\n    onEditProp?.();\r\n  }, [store, onEditProp]);\r\n\r\n  const onSubmit = React.useCallback(\r\n    (newValue: string) => {\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"editing\", false);\r\n      onSubmitProp?.(newValue);\r\n    },\r\n    [store, onSubmitProp],\r\n  );\r\n\r\n  const contextValue = React.useMemo<EditableContextValue>(\r\n    () => ({\r\n      id,\r\n      inputId,\r\n      labelId,\r\n      defaultValue,\r\n      onSubmit,\r\n      onEdit,\r\n      onCancel,\r\n      onEscapeKeyDown,\r\n      onEnterKeyDown,\r\n      dir,\r\n      maxLength,\r\n      placeholder,\r\n      triggerMode,\r\n      autosize,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      invalid,\r\n    }),\r\n    [\r\n      id,\r\n      inputId,\r\n      labelId,\r\n      defaultValue,\r\n      onSubmit,\r\n      onCancel,\r\n      onEdit,\r\n      onEscapeKeyDown,\r\n      onEnterKeyDown,\r\n      dir,\r\n      maxLength,\r\n      placeholder,\r\n      triggerMode,\r\n      autosize,\r\n      disabled,\r\n      required,\r\n      readOnly,\r\n      invalid,\r\n    ],\r\n  );\r\n\r\n  const value = useStore((state) => state.value);\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <EditableContext.Provider value={contextValue}>\r\n      <RootPrimitive\r\n        data-slot=\"editable\"\r\n        {...rootProps}\r\n        id={id}\r\n        ref={composedRef}\r\n        className={cn(\"flex min-w-0 flex-col gap-2\", className)}\r\n      />\r\n      {isFormControl && (\r\n        <VisuallyHiddenInput\r\n          type=\"hidden\"\r\n          control={formTrigger}\r\n          name={name}\r\n          value={value}\r\n          disabled={disabled}\r\n          readOnly={readOnly}\r\n          required={required}\r\n        />\r\n      )}\r\n    </EditableContext.Provider>\r\n  );\r\n}\r\n\r\ninterface EditableLabelProps extends React.ComponentProps<\"label\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableLabel(props: EditableLabelProps) {\r\n  const { asChild, className, children, ref, ...labelProps } = props;\r\n  const context = useEditableContext(LABEL_NAME);\r\n\r\n  const LabelPrimitive = asChild ? Slot : \"label\";\r\n\r\n  return (\r\n    <LabelPrimitive\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-invalid={context.invalid ? \"\" : undefined}\r\n      data-required={context.required ? \"\" : undefined}\r\n      data-slot=\"editable-label\"\r\n      {...labelProps}\r\n      ref={ref}\r\n      id={context.labelId}\r\n      htmlFor={context.inputId}\r\n      className={cn(\r\n        \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 data-required:after:ml-0.5 data-required:after:text-destructive data-required:after:content-['*']\",\r\n        className,\r\n      )}\r\n    >\r\n      {children}\r\n    </LabelPrimitive>\r\n  );\r\n}\r\n\r\ninterface EditableAreaProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableArea(props: EditableAreaProps) {\r\n  const { asChild, className, ref, ...areaProps } = props;\r\n  const context = useEditableContext(AREA_NAME);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const AreaPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <AreaPrimitive\r\n      role=\"group\"\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-editing={editing ? \"\" : undefined}\r\n      data-slot=\"editable-area\"\r\n      dir={context.dir}\r\n      {...areaProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"relative inline-block min-w-0 data-disabled:cursor-not-allowed data-disabled:opacity-50\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditablePreviewProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditablePreview(props: EditablePreviewProps) {\r\n  const { asChild, className, ref, ...previewProps } = props;\r\n  const context = useEditableContext(PREVIEW_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const onTrigger = React.useCallback(() => {\r\n    if (context.disabled || context.readOnly) return;\r\n    context.onEdit();\r\n  }, [context.onEdit, context.disabled, context.readOnly]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      previewProps.onClick?.(event);\r\n      if (event.defaultPrevented || context.triggerMode !== \"click\") return;\r\n\r\n      onTrigger();\r\n    },\r\n    [previewProps.onClick, onTrigger, context.triggerMode],\r\n  );\r\n\r\n  const onDoubleClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      previewProps.onDoubleClick?.(event);\r\n      if (event.defaultPrevented || context.triggerMode !== \"dblclick\") return;\r\n\r\n      onTrigger();\r\n    },\r\n    [previewProps.onDoubleClick, onTrigger, context.triggerMode],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<HTMLDivElement>) => {\r\n      previewProps.onFocus?.(event);\r\n      if (event.defaultPrevented || context.triggerMode !== \"focus\") return;\r\n\r\n      onTrigger();\r\n    },\r\n    [previewProps.onFocus, onTrigger, context.triggerMode],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      previewProps.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Enter\") {\r\n        const nativeEvent = event.nativeEvent;\r\n        if (context.onEnterKeyDown) {\r\n          context.onEnterKeyDown(nativeEvent);\r\n          if (nativeEvent.defaultPrevented) return;\r\n        }\r\n        onTrigger();\r\n      }\r\n    },\r\n    [previewProps.onKeyDown, onTrigger, context.onEnterKeyDown],\r\n  );\r\n\r\n  const PreviewPrimitive = asChild ? Slot : \"div\";\r\n\r\n  if (editing || context.readOnly) return null;\r\n\r\n  return (\r\n    <PreviewPrimitive\r\n      role=\"button\"\r\n      aria-disabled={context.disabled || context.readOnly}\r\n      data-empty={!value ? \"\" : undefined}\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-readonly={context.readOnly ? \"\" : undefined}\r\n      data-slot=\"editable-preview\"\r\n      tabIndex={context.disabled || context.readOnly ? undefined : 0}\r\n      {...previewProps}\r\n      ref={ref}\r\n      onClick={onClick}\r\n      onDoubleClick={onDoubleClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n      className={cn(\r\n        \"cursor-text truncate rounded-sm border border-transparent py-1 text-base focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring data-disabled:cursor-not-allowed data-readonly:cursor-default data-empty:text-muted-foreground data-disabled:opacity-50 md:text-sm\",\r\n        className,\r\n      )}\r\n    >\r\n      {value || context.placeholder}\r\n    </PreviewPrimitive>\r\n  );\r\n}\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\ntype InputElement = React.ComponentRef<typeof EditableInput>;\r\n\r\ninterface EditableInputProps extends React.ComponentProps<\"input\"> {\r\n  asChild?: boolean;\r\n  maxLength?: number;\r\n}\r\n\r\nfunction EditableInput(props: EditableInputProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    disabled,\r\n    readOnly,\r\n    required,\r\n    maxLength,\r\n    ref,\r\n    ...inputProps\r\n  } = props;\r\n  const context = useEditableContext(INPUT_NAME);\r\n  const store = useStoreContext(INPUT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const editing = useStore((state) => state.editing);\r\n  const inputRef = React.useRef<InputElement>(null);\r\n  const composedRef = useComposedRefs(ref, inputRef);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isReadOnly = readOnly || context.readOnly;\r\n  const isRequired = required || context.required;\r\n\r\n  const onAutosize = React.useCallback(\r\n    (target: InputElement) => {\r\n      if (!context.autosize) return;\r\n\r\n      if (target instanceof HTMLTextAreaElement) {\r\n        target.style.height = \"0\";\r\n        target.style.height = `${target.scrollHeight}px`;\r\n      } else {\r\n        target.style.width = \"0\";\r\n        target.style.width = `${target.scrollWidth + 4}px`;\r\n      }\r\n    },\r\n    [context.autosize],\r\n  );\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<InputElement>) => {\r\n      if (isDisabled || isReadOnly) return;\r\n\r\n      inputProps.onBlur?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const relatedTarget = event.relatedTarget;\r\n\r\n      const isAction =\r\n        relatedTarget instanceof HTMLElement &&\r\n        (relatedTarget.closest(`[data-slot=\"editable-trigger\"]`) ||\r\n          relatedTarget.closest(`[data-slot=\"editable-cancel\"]`));\r\n\r\n      if (!isAction) {\r\n        context.onSubmit(value);\r\n      }\r\n    },\r\n    [value, context.onSubmit, inputProps.onBlur, isDisabled, isReadOnly],\r\n  );\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      if (isDisabled || isReadOnly) return;\r\n\r\n      inputProps.onChange?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"value\", event.target.value);\r\n      onAutosize(event.target);\r\n    },\r\n    [store, inputProps.onChange, onAutosize, isDisabled, isReadOnly],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<InputElement>) => {\r\n      if (isDisabled || isReadOnly) return;\r\n\r\n      inputProps.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Escape\") {\r\n        const nativeEvent = event.nativeEvent;\r\n        if (context.onEscapeKeyDown) {\r\n          context.onEscapeKeyDown(nativeEvent);\r\n          if (nativeEvent.defaultPrevented) return;\r\n        }\r\n        context.onCancel();\r\n      } else if (event.key === \"Enter\") {\r\n        context.onSubmit(value);\r\n      }\r\n    },\r\n    [\r\n      value,\r\n      context.onSubmit,\r\n      context.onCancel,\r\n      context.onEscapeKeyDown,\r\n      inputProps.onKeyDown,\r\n      isDisabled,\r\n      isReadOnly,\r\n    ],\r\n  );\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (!editing || isDisabled || isReadOnly || !inputRef.current) return;\r\n\r\n    const frameId = window.requestAnimationFrame(() => {\r\n      if (!inputRef.current) return;\r\n\r\n      inputRef.current.focus();\r\n      inputRef.current.select();\r\n      onAutosize(inputRef.current);\r\n    });\r\n\r\n    return () => {\r\n      window.cancelAnimationFrame(frameId);\r\n    };\r\n  }, [editing, onAutosize, isDisabled, isReadOnly]);\r\n\r\n  const InputPrimitive = asChild ? Slot : \"input\";\r\n\r\n  if (!editing && !isReadOnly) return null;\r\n\r\n  return (\r\n    <InputPrimitive\r\n      aria-required={isRequired}\r\n      aria-invalid={context.invalid}\r\n      data-slot=\"editable-input\"\r\n      dir={context.dir}\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      required={isRequired}\r\n      {...inputProps}\r\n      id={context.inputId}\r\n      aria-labelledby={context.labelId}\r\n      ref={composedRef}\r\n      maxLength={maxLength}\r\n      placeholder={context.placeholder}\r\n      value={value}\r\n      onBlur={onBlur}\r\n      onChange={onChange}\r\n      onKeyDown={onKeyDown}\r\n      className={cn(\r\n        \"flex rounded-sm border border-input bg-transparent py-1 text-base shadow-xs transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n        context.autosize ? \"w-auto\" : \"w-full\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableTriggerProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction EditableTrigger(props: EditableTriggerProps) {\r\n  const { asChild, forceMount = false, ref, ...triggerProps } = props;\r\n  const context = useEditableContext(TRIGGER_NAME);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const onTrigger = React.useCallback(() => {\r\n    if (context.disabled || context.readOnly) return;\r\n    context.onEdit();\r\n  }, [context.disabled, context.readOnly, context.onEdit]);\r\n\r\n  const TriggerPrimitive = asChild ? Slot : \"button\";\r\n\r\n  if (!forceMount && (editing || context.readOnly)) return null;\r\n\r\n  return (\r\n    <TriggerPrimitive\r\n      type=\"button\"\r\n      aria-controls={context.id}\r\n      aria-disabled={context.disabled || context.readOnly}\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-readonly={context.readOnly ? \"\" : undefined}\r\n      data-slot=\"editable-trigger\"\r\n      {...triggerProps}\r\n      ref={ref}\r\n      onClick={context.triggerMode === \"click\" ? onTrigger : undefined}\r\n      onDoubleClick={context.triggerMode === \"dblclick\" ? onTrigger : undefined}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableToolbarProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n  orientation?: \"horizontal\" | \"vertical\";\r\n}\r\n\r\nfunction EditableToolbar(props: EditableToolbarProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    orientation = \"horizontal\",\r\n    ref,\r\n    ...toolbarProps\r\n  } = props;\r\n  const context = useEditableContext(TOOLBAR_NAME);\r\n\r\n  const ToolbarPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ToolbarPrimitive\r\n      role=\"toolbar\"\r\n      aria-controls={context.id}\r\n      aria-orientation={orientation}\r\n      data-slot=\"editable-toolbar\"\r\n      dir={context.dir}\r\n      {...toolbarProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"flex items-center gap-2\",\r\n        orientation === \"vertical\" && \"flex-col\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableCancelProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableCancel(props: EditableCancelProps) {\r\n  const { asChild, ref, ...cancelProps } = props;\r\n  const context = useEditableContext(CANCEL_NAME);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      if (context.disabled || context.readOnly) return;\r\n\r\n      cancelProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      context.onCancel();\r\n    },\r\n    [cancelProps.onClick, context.onCancel, context.disabled, context.readOnly],\r\n  );\r\n\r\n  const CancelPrimitive = asChild ? Slot : \"button\";\r\n\r\n  if (!editing && !context.readOnly) return null;\r\n\r\n  return (\r\n    <CancelPrimitive\r\n      type=\"button\"\r\n      aria-controls={context.id}\r\n      data-slot=\"editable-cancel\"\r\n      {...cancelProps}\r\n      onClick={onClick}\r\n      ref={ref}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableSubmitProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableSubmit(props: EditableSubmitProps) {\r\n  const { asChild, ref, ...submitProps } = props;\r\n  const context = useEditableContext(SUBMIT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      if (context.disabled || context.readOnly) return;\r\n\r\n      submitProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      context.onSubmit(value);\r\n    },\r\n    [\r\n      submitProps.onClick,\r\n      context.onSubmit,\r\n      value,\r\n      context.disabled,\r\n      context.readOnly,\r\n    ],\r\n  );\r\n\r\n  const SubmitPrimitive = asChild ? Slot : \"button\";\r\n\r\n  if (!editing && !context.readOnly) return null;\r\n\r\n  return (\r\n    <SubmitPrimitive\r\n      type=\"button\"\r\n      aria-controls={context.id}\r\n      data-slot=\"editable-submit\"\r\n      {...submitProps}\r\n      ref={ref}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  EditableRoot as Editable,\r\n  EditableLabel,\r\n  EditableArea,\r\n  EditablePreview,\r\n  EditableInput,\r\n  EditableTrigger,\r\n  EditableToolbar,\r\n  EditableCancel,\r\n  EditableSubmit,\r\n  //\r\n  EditableRoot as Root,\r\n  EditableLabel as Label,\r\n  EditableArea as Area,\r\n  EditablePreview as Preview,\r\n  EditableInput as Input,\r\n  EditableTrigger as Trigger,\r\n  EditableToolbar as Toolbar,\r\n  EditableCancel as Cancel,\r\n  EditableSubmit as Submit,\r\n  //\r\n  useStore as useEditable,\r\n  //\r\n  type EditableRootProps as EditableProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}