{
  "name": "image-crop",
  "type": "registry:ui",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "slider"
  ],
  "files": [
    {
      "path": "ui/image-crop.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { Crop, RefreshCw, RotateCcw, RotateCw } from \"lucide-react\";\nimport * as React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { cn } from \"@/lib/utils\";\nimport type {\n  Area,\n  ControlsProps,\n  CropAreaProps,\n  CropButtonProps,\n  CropValue,\n  ImageProps,\n  Point,\n  ResetButtonProps,\n  RootProps,\n  RotateButtonProps,\n  ZoomSliderProps,\n} from \"@/types/docs/image-crop\";\n\ninterface ImageCropContextValue {\n  src?: string;\n  alt?: string;\n  aspect: number;\n  value?: CropValue;\n  onValueChange?: (value: CropValue) => void;\n  zoom: number;\n  onZoomChange?: (zoom: number) => void;\n  rotation: number;\n  onRotationChange?: (rotation: number) => void;\n  disabled: boolean;\n  readOnly: boolean;\n  cropShape: \"rect\" | \"round\";\n  showGrid: boolean;\n  quality: number;\n  outputFormat: \"image/jpeg\" | \"image/png\" | \"image/webp\";\n  minZoom: number;\n  maxZoom: number;\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void;\n  onMediaLoaded?: (mediaSize: { width: number; height: number }) => void;\n  mediaSize: { width: number; height: number } | null;\n  isDragging: boolean;\n  setIsDragging: (dragging: boolean) => void;\n}\n\nconst ImageCropContext = React.createContext<ImageCropContextValue | null>(\n  null,\n);\n\nfunction useImageCrop() {\n  const context = React.useContext(ImageCropContext);\n  if (!context) {\n    throw new Error(\"useImageCrop must be used within ImageCrop.Root\");\n  }\n  return context;\n}\n\nfunction Root(props: RootProps) {\n  const {\n    src,\n    alt = \"Crop image\",\n    aspect = 1,\n    value,\n    defaultValue,\n    onValueChange,\n    zoom,\n    defaultZoom = 1,\n    onZoomChange,\n    rotation,\n    defaultRotation = 0,\n    onRotationChange,\n    disabled = false,\n    readOnly = false,\n    cropShape = \"rect\",\n    showGrid = true,\n    quality = 0.92,\n    outputFormat = \"image/jpeg\",\n    minZoom = 1,\n    maxZoom = 3,\n    onCropComplete,\n    onMediaLoaded,\n    asChild,\n    className,\n    children,\n    ...rootProps\n  } = props;\n  const [internalValue, setInternalValue] = React.useState<CropValue>(\n    defaultValue || { x: 0, y: 0, width: 100, height: 100 },\n  );\n  const [internalZoom, setInternalZoom] = React.useState(defaultZoom);\n  const [internalRotation, setInternalRotation] =\n    React.useState(defaultRotation);\n  const [mediaSize, setMediaSize] = React.useState<{\n    width: number;\n    height: number;\n  } | null>(null);\n  const [isDragging, setIsDragging] = React.useState(false);\n\n  const cropValue = value !== undefined ? value : internalValue;\n  const zoomValue = zoom !== undefined ? zoom : internalZoom;\n  const rotationValue = rotation !== undefined ? rotation : internalRotation;\n\n  const handleValueChange = React.useCallback(\n    (newValue: CropValue) => {\n      if (readOnly) return;\n\n      if (value === undefined) {\n        setInternalValue(newValue);\n      }\n      onValueChange?.(newValue);\n    },\n    [onValueChange, readOnly, value],\n  );\n\n  const handleZoomChange = React.useCallback(\n    (newZoom: number) => {\n      if (disabled || readOnly) return;\n\n      if (zoom === undefined) {\n        setInternalZoom(newZoom);\n      }\n      onZoomChange?.(newZoom);\n    },\n    [disabled, onZoomChange, readOnly, zoom],\n  );\n\n  const handleRotationChange = React.useCallback(\n    (newRotation: number) => {\n      if (disabled || readOnly) return;\n\n      if (rotation === undefined) {\n        setInternalRotation(newRotation);\n      }\n      onRotationChange?.(newRotation);\n    },\n    [disabled, onRotationChange, readOnly, rotation],\n  );\n\n  const handleMediaLoaded = React.useCallback(\n    (size: { width: number; height: number }) => {\n      setMediaSize(size);\n      onMediaLoaded?.(size);\n    },\n    [onMediaLoaded],\n  );\n\n  const contextValue: ImageCropContextValue = {\n    src,\n    alt,\n    aspect,\n    value: cropValue,\n    onValueChange: handleValueChange,\n    zoom: zoomValue,\n    onZoomChange: handleZoomChange,\n    rotation: rotationValue,\n    onRotationChange: handleRotationChange,\n    disabled,\n    readOnly,\n    cropShape,\n    showGrid,\n    quality,\n    outputFormat,\n    minZoom,\n    maxZoom,\n    onCropComplete,\n    onMediaLoaded: handleMediaLoaded,\n    mediaSize,\n    isDragging,\n    setIsDragging,\n  };\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ImageCropContext.Provider value={contextValue}>\n      <RootPrimitive\n        className={cn(\n          \"relative flex flex-col gap-4 rounded-lg border bg-background p-4\",\n          disabled && \"pointer-events-none opacity-50\",\n          className,\n        )}\n        {...rootProps}\n      >\n        {children}\n      </RootPrimitive>\n    </ImageCropContext.Provider>\n  );\n}\n\nfunction CropArea(props: CropAreaProps) {\n  const { className, children, asChild, ...cropAreaProps } = props;\n  const {\n    src,\n    alt,\n    value,\n    onValueChange,\n    zoom,\n    rotation,\n    disabled,\n    readOnly,\n    cropShape,\n    showGrid,\n    onCropComplete,\n    onMediaLoaded,\n    mediaSize,\n    isDragging,\n    setIsDragging,\n  } = useImageCrop();\n\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const imageRef = React.useRef<HTMLImageElement>(null);\n  const [dragStart, setDragStart] = React.useState<Point | null>(null);\n  const [initialCrop, setInitialCrop] = React.useState<CropValue | null>(null);\n\n  const handleMouseDown = React.useCallback(\n    (e: React.MouseEvent<HTMLButtonElement>) => {\n      if (disabled || readOnly || !value) return;\n\n      e.preventDefault();\n      setIsDragging(true);\n      setDragStart({ x: e.clientX, y: e.clientY });\n      setInitialCrop(value);\n    },\n    [disabled, readOnly, value, setIsDragging],\n  );\n\n  const handleMouseMove = React.useCallback(\n    (e: MouseEvent) => {\n      if (!isDragging || !dragStart || !initialCrop || !containerRef.current)\n        return;\n\n      const container = containerRef.current.getBoundingClientRect();\n      const deltaX = ((e.clientX - dragStart.x) / container.width) * 100;\n      const deltaY = ((e.clientY - dragStart.y) / container.height) * 100;\n\n      const newValue: CropValue = {\n        ...initialCrop,\n        x: Math.max(\n          0,\n          Math.min(100 - initialCrop.width, initialCrop.x + deltaX),\n        ),\n        y: Math.max(\n          0,\n          Math.min(100 - initialCrop.height, initialCrop.y + deltaY),\n        ),\n      };\n\n      onValueChange?.(newValue);\n    },\n    [isDragging, dragStart, initialCrop, onValueChange],\n  );\n\n  const handleMouseUp = React.useCallback(() => {\n    setIsDragging(false);\n    setDragStart(null);\n    setInitialCrop(null);\n\n    if (value && mediaSize && onCropComplete) {\n      const croppedArea: Area = {\n        x: value.x,\n        y: value.y,\n        width: value.width,\n        height: value.height,\n      };\n\n      const croppedAreaPixels: Area = {\n        x: (value.x / 100) * mediaSize.width,\n        y: (value.y / 100) * mediaSize.height,\n        width: (value.width / 100) * mediaSize.width,\n        height: (value.height / 100) * mediaSize.height,\n      };\n\n      onCropComplete(croppedArea, croppedAreaPixels);\n    }\n  }, [value, mediaSize, onCropComplete, setIsDragging]);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n      return () => {\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n      };\n    }\n  }, [isDragging, handleMouseMove, handleMouseUp]);\n\n  const handleImageLoad = React.useCallback(\n    (e: React.SyntheticEvent<HTMLImageElement>) => {\n      const img = e.target as HTMLImageElement;\n      onMediaLoaded?.({ width: img.naturalWidth, height: img.naturalHeight });\n    },\n    [onMediaLoaded],\n  );\n\n  if (!src) {\n    const EmptyPrimitive = asChild ? Slot : \"div\";\n    return (\n      <EmptyPrimitive\n        className={cn(\n          \"relative flex aspect-square w-full max-w-md items-center justify-center rounded-lg border-2 border-muted-foreground/25 border-dashed bg-muted/50 text-muted-foreground\",\n          className,\n        )}\n        {...cropAreaProps}\n      >\n        <div className=\"text-center\">\n          <Crop className=\"mx-auto mb-2 h-8 w-8\" />\n          <p className=\"text-sm\">No image selected</p>\n        </div>\n      </EmptyPrimitive>\n    );\n  }\n\n  const CropAreaPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <CropAreaPrimitive\n      ref={containerRef}\n      className={cn(\n        \"relative aspect-square w-full max-w-md overflow-hidden rounded-lg bg-black\",\n        className,\n      )}\n      {...cropAreaProps}\n    >\n      {/** biome-ignore lint/performance/noImgElement: dynamic image URLs from crop area don't work well with Next.js Image optimization */}\n      <img\n        ref={imageRef}\n        src={src}\n        alt={alt}\n        className={cn(\n          \"absolute inset-0 h-full w-full object-contain transition-transform duration-200\",\n          isDragging && \"cursor-grabbing\",\n        )}\n        style={{\n          transform: `scale(${zoom}) rotate(${rotation}deg)`,\n        }}\n        onLoad={handleImageLoad}\n        draggable={false}\n      />\n\n      {value && (\n        <button\n          type=\"button\"\n          className={cn(\n            \"absolute cursor-grab border-2 border-white shadow-lg\",\n            isDragging && \"cursor-grabbing\",\n            cropShape === \"round\" && \"rounded-full\",\n          )}\n          style={{\n            left: `${value.x}%`,\n            top: `${value.y}%`,\n            width: `${value.width}%`,\n            height: `${value.height}%`,\n          }}\n          onMouseDown={handleMouseDown}\n          aria-label=\"Drag to move crop area\"\n        >\n          {showGrid && (\n            <div className=\"absolute inset-0 grid grid-cols-3 grid-rows-3\">\n              {Array.from({ length: 9 }).map((_, i) => (\n                <div key={i} className=\"border border-white/30\" />\n              ))}\n            </div>\n          )}\n\n          {/* Resize handles */}\n          <button\n            type=\"button\"\n            className=\"-top-1 -left-1 absolute h-3 w-3 cursor-nw-resize border border-gray-300 bg-white\"\n            aria-label=\"Resize crop area\"\n          />\n          <button\n            type=\"button\"\n            className=\"-top-1 -right-1 absolute h-3 w-3 cursor-ne-resize border border-gray-300 bg-white\"\n            aria-label=\"Resize crop area\"\n          />\n          <button\n            type=\"button\"\n            className=\"-bottom-1 -left-1 absolute h-3 w-3 cursor-sw-resize border border-gray-300 bg-white\"\n            aria-label=\"Resize crop area\"\n          />\n          <button\n            type=\"button\"\n            className=\"-bottom-1 -right-1 absolute h-3 w-3 cursor-se-resize border border-gray-300 bg-white\"\n            aria-label=\"Resize crop area\"\n          />\n        </button>\n      )}\n\n      {/* Overlay to darken non-crop areas */}\n      {value && (\n        <>\n          {/* Top overlay */}\n          <div\n            className=\"absolute top-0 right-0 left-0 bg-black/50\"\n            style={{ height: `${value.y}%` }}\n          />\n          {/* Bottom overlay */}\n          <div\n            className=\"absolute right-0 bottom-0 left-0 bg-black/50\"\n            style={{ height: `${100 - value.y - value.height}%` }}\n          />\n          {/* Left overlay */}\n          <div\n            className=\"absolute left-0 bg-black/50\"\n            style={{\n              top: `${value.y}%`,\n              height: `${value.height}%`,\n              width: `${value.x}%`,\n            }}\n          />\n          {/* Right overlay */}\n          <div\n            className=\"absolute right-0 bg-black/50\"\n            style={{\n              top: `${value.y}%`,\n              height: `${value.height}%`,\n              width: `${100 - value.x - value.width}%`,\n            }}\n          />\n        </>\n      )}\n\n      {children}\n    </CropAreaPrimitive>\n  );\n}\n\nfunction Image(props: ImageProps) {\n  const { className, asChild, ...imageProps } = props;\n  const { src, alt, zoom, rotation } = useImageCrop();\n\n  if (!src) return null;\n\n  const ImagePrimitive = asChild ? Slot : \"img\";\n\n  return (\n    <ImagePrimitive\n      src={src}\n      alt={alt}\n      className={cn(\n        \"absolute inset-0 h-full w-full object-contain transition-transform duration-200\",\n        className,\n      )}\n      style={{\n        transform: `scale(${zoom}) rotate(${rotation}deg)`,\n      }}\n      draggable={false}\n      {...imageProps}\n    />\n  );\n}\n\nfunction Controls(props: ControlsProps) {\n  const { className, children, asChild, ...controlsProps } = props;\n\n  const ControlsPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ControlsPrimitive\n      className={cn(\"flex items-center gap-2\", className)}\n      {...controlsProps}\n    >\n      {children}\n    </ControlsPrimitive>\n  );\n}\n\nfunction ZoomSlider(props: ZoomSliderProps) {\n  const { min, max, step = 0.1, className, asChild, ...sliderProps } = props;\n  const { zoom, onZoomChange, minZoom, maxZoom, disabled, readOnly } =\n    useImageCrop();\n\n  const handleValueChange = React.useCallback(\n    (value: number[]) => {\n      onZoomChange?.(value[0] ?? minZoom);\n    },\n    [onZoomChange, minZoom],\n  );\n\n  const SliderPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <SliderPrimitive\n      className={cn(\"flex flex-1 items-center gap-2\", className)}\n      {...sliderProps}\n    >\n      <span className=\"text-muted-foreground text-sm\">1x</span>\n      <Slider\n        value={[zoom]}\n        onValueChange={handleValueChange}\n        min={min ?? minZoom}\n        max={max ?? maxZoom}\n        step={step}\n        disabled={disabled || readOnly}\n        className=\"flex-1\"\n      />\n      <span className=\"text-muted-foreground text-sm\">{maxZoom}x</span>\n    </SliderPrimitive>\n  );\n}\n\nfunction RotateButton(props: RotateButtonProps) {\n  const {\n    direction = \"left\",\n    variant = \"outline\",\n    size = \"sm\",\n    className,\n    onClick,\n    asChild,\n    ...buttonProps\n  } = props;\n  const { rotation, onRotationChange, disabled, readOnly } = useImageCrop();\n\n  const handleClick = React.useCallback(\n    (e: React.MouseEvent<HTMLButtonElement>) => {\n      onClick?.(e);\n      if (e.defaultPrevented) return;\n\n      const newRotation = direction === \"left\" ? rotation - 90 : rotation + 90;\n      onRotationChange?.(newRotation);\n    },\n    [direction, rotation, onRotationChange, onClick],\n  );\n\n  const Icon = direction === \"left\" ? RotateCcw : RotateCw;\n\n  return (\n    <Button\n      variant={variant}\n      size={size}\n      onClick={handleClick}\n      disabled={disabled || readOnly}\n      className={className}\n      asChild={asChild}\n      {...buttonProps}\n    >\n      <Icon className=\"h-4 w-4\" />\n    </Button>\n  );\n}\n\nfunction ResetButton(props: ResetButtonProps) {\n  const {\n    variant = \"outline\",\n    size = \"sm\",\n    className,\n    onClick,\n    asChild,\n    ...buttonProps\n  } = props;\n  const { onZoomChange, onRotationChange, onValueChange, disabled, readOnly } =\n    useImageCrop();\n\n  const handleReset = React.useCallback(\n    (e: React.MouseEvent<HTMLButtonElement>) => {\n      onClick?.(e);\n      if (e.defaultPrevented) return;\n\n      onZoomChange?.(1);\n      onRotationChange?.(0);\n      onValueChange?.({ x: 0, y: 0, width: 100, height: 100 });\n    },\n    [onZoomChange, onRotationChange, onValueChange, onClick],\n  );\n\n  return (\n    <Button\n      variant={variant}\n      size={size}\n      onClick={handleReset}\n      disabled={disabled || readOnly}\n      className={className}\n      asChild={asChild}\n      {...buttonProps}\n    >\n      <RefreshCw className=\"h-4 w-4\" />\n    </Button>\n  );\n}\n\nfunction CropButton(props: CropButtonProps) {\n  const {\n    variant = \"default\",\n    size = \"sm\",\n    className,\n    children,\n    onClick,\n    asChild,\n    ...buttonProps\n  } = props;\n  const { src, value, zoom, rotation, quality, outputFormat, mediaSize } =\n    useImageCrop();\n\n  const handleCrop = React.useCallback(async () => {\n    if (!src || !value || !mediaSize) return;\n\n    // Create a canvas to perform the crop\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Create an image element\n    const img = new window.Image();\n    img.crossOrigin = \"anonymous\";\n\n    return new Promise<void>((resolve) => {\n      img.onload = () => {\n        // Calculate the actual crop dimensions\n        const cropX = (value.x / 100) * img.naturalWidth;\n        const cropY = (value.y / 100) * img.naturalHeight;\n        const cropWidth = (value.width / 100) * img.naturalWidth;\n        const cropHeight = (value.height / 100) * img.naturalHeight;\n\n        canvas.width = cropWidth;\n        canvas.height = cropHeight;\n\n        // Apply transformations\n        ctx.save();\n        ctx.translate(cropWidth / 2, cropHeight / 2);\n        ctx.rotate((rotation * Math.PI) / 180);\n        ctx.scale(zoom, zoom);\n        ctx.translate(-cropWidth / 2, -cropHeight / 2);\n\n        // Draw the cropped image\n        ctx.drawImage(\n          img,\n          cropX,\n          cropY,\n          cropWidth,\n          cropHeight,\n          0,\n          0,\n          cropWidth,\n          cropHeight,\n        );\n\n        ctx.restore();\n\n        // Convert to blob and trigger download or callback\n        canvas.toBlob(\n          (blob) => {\n            if (blob) {\n              const url = URL.createObjectURL(blob);\n              const a = document.createElement(\"a\");\n              a.href = url;\n              a.download = \"cropped-image.\" + outputFormat.split(\"/\")[1];\n              a.click();\n              URL.revokeObjectURL(url);\n            }\n            resolve();\n          },\n          outputFormat,\n          quality,\n        );\n      };\n\n      img.src = src;\n    });\n  }, [src, value, zoom, rotation, quality, outputFormat, mediaSize]);\n\n  const handleClick = React.useCallback(\n    (e: React.MouseEvent<HTMLButtonElement>) => {\n      onClick?.(e);\n      if (e.defaultPrevented) return;\n\n      handleCrop();\n    },\n    [onClick, handleCrop],\n  );\n\n  return (\n    <Button\n      variant={variant}\n      size={size}\n      onClick={handleClick}\n      disabled={!src || !value}\n      className={className}\n      asChild={asChild}\n      {...buttonProps}\n    >\n      {children || (\n        <>\n          <Crop className=\"mr-2 h-4 w-4\" />\n          Crop Image\n        </>\n      )}\n    </Button>\n  );\n}\n\nexport {\n  Root,\n  CropArea,\n  Image,\n  Controls,\n  ZoomSlider,\n  RotateButton,\n  ResetButton,\n  CropButton,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}