{
  "name": "action-bar",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/action-bar.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { Portal } from \"@/registry/default/components/portal\";\n\nconst ROOT_NAME = \"ActionBar\";\nconst ITEM_NAME = \"ActionBarItem\";\nconst CLOSE_NAME = \"ActionBarClose\";\nconst ITEM_SELECT = \"actionbar.itemSelect\";\n\ninterface PointerDownOutsideEvent {\n  target: Node;\n  preventDefault: () => void;\n  defaultPrevented: boolean;\n}\n\ninterface FocusOutsideEvent {\n  target: Node;\n  preventDefault: () => void;\n  defaultPrevented: boolean;\n}\n\ntype RootElement = React.ComponentRef<typeof ActionBarRoot>;\ntype ItemElement = React.ComponentRef<typeof ActionBarItem>; // eslint-disable-line @typescript-eslint/no-unused-vars\ntype CloseElement = React.ComponentRef<typeof ActionBarClose>;\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\ntype OnOpenChange = ((open: boolean) => void) | undefined;\n\nconst ActionBarContext = React.createContext<OnOpenChange>(undefined);\n\nfunction useActionBarContext(consumerName: string) {\n  const onOpenChange = React.useContext(ActionBarContext);\n  if (onOpenChange === undefined) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return onOpenChange;\n}\n\ninterface ActionBarRootProps extends React.ComponentProps<\"div\"> {\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  side?: \"top\" | \"bottom\";\n  align?: \"start\" | \"center\" | \"end\";\n  sideOffset?: number;\n  asChild?: boolean;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  onInteractOutside?: (\n    event: PointerDownOutsideEvent | FocusOutsideEvent,\n  ) => void;\n}\n\nfunction ActionBarRoot(props: ActionBarRootProps) {\n  const {\n    open = false,\n    onOpenChange,\n    side = \"bottom\",\n    align = \"center\",\n    sideOffset = 16,\n    asChild,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    className,\n    style,\n    onPointerDownCapture,\n    onFocusCapture,\n    onBlurCapture,\n    ref,\n    ...rootProps\n  } = props;\n\n  const rootRef = React.useRef<RootElement>(null);\n  const isPointerInsideRef = React.useRef(false);\n  const isFocusInsideRef = React.useRef(false);\n  const onClickRef = React.useRef(() => {});\n\n  const composedRef = useComposedRefs(ref, rootRef);\n\n  const propsRef = useAsRef({\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onOpenChange,\n  });\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (event.key === \"Escape\") {\n        propsRef.current.onEscapeKeyDown?.(event);\n        if (!event.defaultPrevented) {\n          onOpenChange?.(false);\n        }\n      }\n    }\n\n    document.addEventListener(\"keydown\", onKeyDown);\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\n  }, [open, onOpenChange, propsRef]);\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    const ownerDocument = rootRef.current?.ownerDocument ?? document;\n\n    function onPointerDown(event: PointerEvent) {\n      const target = event.target as Node | null;\n\n      if (target && !isPointerInsideRef.current) {\n        const root = rootRef.current;\n        if (root && !root.contains(target)) {\n          const outsideEvent: PointerDownOutsideEvent = {\n            target,\n            defaultPrevented: false,\n            preventDefault: () => {\n              outsideEvent.defaultPrevented = true;\n            },\n          };\n\n          function onPointerDownOutside() {\n            propsRef.current.onPointerDownOutside?.(outsideEvent);\n            propsRef.current.onInteractOutside?.(outsideEvent);\n\n            if (!outsideEvent.defaultPrevented) {\n              onOpenChange?.(false);\n            }\n          }\n\n          if (event.pointerType === \"touch\") {\n            ownerDocument.removeEventListener(\"click\", onClickRef.current);\n            onClickRef.current = onPointerDownOutside;\n            ownerDocument.addEventListener(\"click\", onClickRef.current, {\n              once: true,\n            });\n          } else {\n            onPointerDownOutside();\n          }\n        }\n      } else {\n        ownerDocument.removeEventListener(\"click\", onClickRef.current);\n      }\n\n      isPointerInsideRef.current = false;\n    }\n\n    const timeoutId = window.setTimeout(() => {\n      ownerDocument.addEventListener(\"pointerdown\", onPointerDown);\n    }, 0);\n\n    return () => {\n      window.clearTimeout(timeoutId);\n      ownerDocument.removeEventListener(\"pointerdown\", onPointerDown);\n      ownerDocument.removeEventListener(\"click\", onClickRef.current);\n    };\n  }, [open, propsRef, onOpenChange]);\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    function onFocusIn(event: FocusEvent) {\n      const target = event.target as Node | null;\n      if (!target) return;\n\n      const root = rootRef.current;\n      if (!root || root.contains(target) || isFocusInsideRef.current) return;\n\n      const outsideEvent: FocusOutsideEvent = {\n        target,\n        defaultPrevented: false,\n        preventDefault: () => {\n          outsideEvent.defaultPrevented = true;\n        },\n      };\n\n      propsRef.current.onFocusOutside?.(outsideEvent);\n      propsRef.current.onInteractOutside?.(outsideEvent);\n\n      if (!outsideEvent.defaultPrevented) {\n        onOpenChange?.(false);\n      }\n    }\n\n    document.addEventListener(\"focusin\", onFocusIn);\n    return () => document.removeEventListener(\"focusin\", onFocusIn);\n  }, [open, onOpenChange, propsRef]);\n\n  const onRootPointerDownCapture = React.useCallback(\n    (event: React.PointerEvent<RootElement>) => {\n      onPointerDownCapture?.(event);\n      isPointerInsideRef.current = true;\n    },\n    [onPointerDownCapture],\n  );\n\n  const onRootFocusCapture = React.useCallback(\n    (event: React.FocusEvent<RootElement>) => {\n      onFocusCapture?.(event);\n      isFocusInsideRef.current = true;\n    },\n    [onFocusCapture],\n  );\n\n  const onRootBlurCapture = React.useCallback(\n    (event: React.FocusEvent<RootElement>) => {\n      onBlurCapture?.(event);\n      isFocusInsideRef.current = false;\n    },\n    [onBlurCapture],\n  );\n\n  if (!open) return null;\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ActionBarContext.Provider value={onOpenChange}>\n      <Portal>\n        <RootPrimitive\n          data-slot=\"action-bar\"\n          data-state={open ? \"open\" : \"closed\"}\n          data-side={side}\n          data-align={align}\n          {...rootProps}\n          ref={composedRef}\n          onPointerDownCapture={onRootPointerDownCapture}\n          onFocusCapture={onRootFocusCapture}\n          onBlurCapture={onRootBlurCapture}\n          className={cn(\n            \"fixed z-50 flex items-center gap-1 rounded-lg border bg-card px-2 py-1.5 shadow-lg\",\n            \"data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:animate-in data-[state=open]:duration-250\",\n            \"data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:animate-out data-[state=closed]:duration-200\",\n            \"data-[side=bottom]:data-[state=open]:slide-in-from-bottom-4 data-[side=bottom]:data-[state=closed]:slide-out-to-bottom-4\",\n            \"data-[side=top]:data-[state=open]:slide-in-from-top-4 data-[side=top]:data-[state=closed]:slide-out-to-top-4\",\n            \"motion-reduce:animate-none motion-reduce:transition-none\",\n            className,\n          )}\n          style={{\n            [side]: `${sideOffset}px`,\n            ...(align === \"center\" && {\n              left: \"50%\",\n              translate: \"-50% 0\",\n            }),\n            ...(align === \"start\" && { left: `${sideOffset}px` }),\n            ...(align === \"end\" && { right: `${sideOffset}px` }),\n            animationTimingFunction: \"cubic-bezier(0.16, 1, 0.3, 1)\",\n            ...style,\n          }}\n        />\n      </Portal>\n    </ActionBarContext.Provider>\n  );\n}\n\ninterface ActionBarSelectionProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction ActionBarSelection(props: ActionBarSelectionProps) {\n  const { asChild, className, ...selectionProps } = props;\n\n  const SelectionPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <SelectionPrimitive\n      data-slot=\"action-bar-selection\"\n      {...selectionProps}\n      className={cn(\n        \"flex items-center gap-2 rounded-sm border border-dotted px-2 py-1 font-medium text-sm\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface ActionBarItemProps\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\n  onSelect?: (event: Event) => void;\n}\n\nfunction ActionBarItem(props: ActionBarItemProps) {\n  const { onSelect, onClick, ref, ...itemProps } = props;\n\n  const itemRef = React.useRef<ItemElement>(null);\n  const composedRef = useComposedRefs(ref, itemRef);\n\n  const onOpenChange = useActionBarContext(ITEM_NAME);\n\n  const onItemSelect = React.useCallback(() => {\n    const item = itemRef.current;\n    if (!item) return;\n\n    const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\n      bubbles: true,\n      cancelable: true,\n    });\n\n    item.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), {\n      once: true,\n    });\n\n    item.dispatchEvent(itemSelectEvent);\n\n    if (!itemSelectEvent.defaultPrevented) {\n      onOpenChange?.(false);\n    }\n  }, [onOpenChange, onSelect]);\n\n  const onItemClick = React.useCallback(\n    (event: React.MouseEvent<ItemElement>) => {\n      onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      if (onSelect) {\n        onItemSelect();\n      }\n    },\n    [onClick, onSelect, onItemSelect],\n  );\n\n  return (\n    <Button\n      type=\"button\"\n      data-slot=\"action-bar-item\"\n      variant=\"secondary\"\n      size=\"sm\"\n      {...itemProps}\n      ref={composedRef}\n      onClick={onItemClick}\n    />\n  );\n}\n\ninterface ActionBarCloseProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\nfunction ActionBarClose(props: ActionBarCloseProps) {\n  const { asChild, className, onClick, ...closeProps } = props;\n\n  const onOpenChange = useActionBarContext(CLOSE_NAME);\n\n  const onCloseClick = React.useCallback(\n    (event: React.MouseEvent<CloseElement>) => {\n      onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      onOpenChange?.(false);\n    },\n    [onOpenChange, onClick],\n  );\n\n  const ClosePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ClosePrimitive\n      type=\"button\"\n      data-slot=\"action-bar-close\"\n      {...closeProps}\n      className={cn(\n        \"rounded-xs opacity-70 outline-none hover:opacity-100 focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring/50 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-3.5 [&_svg]:pointer-events-none [&_svg]:shrink-0\",\n        className,\n      )}\n      onClick={onCloseClick}\n    />\n  );\n}\n\ninterface ActionBarSeparatorProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction ActionBarSeparator(props: ActionBarSeparatorProps) {\n  const { asChild, className, ...separatorProps } = props;\n\n  const SeparatorPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <SeparatorPrimitive\n      role=\"separator\"\n      aria-orientation=\"vertical\"\n      data-slot=\"action-bar-separator\"\n      {...separatorProps}\n      className={cn(\"mx-1 h-6 w-px bg-border\", className)}\n    />\n  );\n}\n\nexport {\n  ActionBarRoot as Root,\n  ActionBarSelection as Selection,\n  ActionBarItem as Item,\n  ActionBarClose as Close,\n  ActionBarSeparator as Separator,\n  //\n  ActionBarRoot as ActionBar,\n  ActionBarSelection,\n  ActionBarItem,\n  ActionBarClose,\n  ActionBarSeparator,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/portal.tsx",
      "content": "\"use client\";\n\nimport { Slot, type SlotProps } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\ninterface PortalProps extends SlotProps {\n  container?: Element | DocumentFragment | null;\n}\n\nfunction Portal(props: PortalProps) {\n  const { container: containerProp, ...portalProps } = props;\n\n  const [mounted, setMounted] = React.useState(false);\n\n  React.useLayoutEffect(() => setMounted(true), []);\n\n  const container =\n    containerProp ?? (mounted ? globalThis.document?.body : null);\n\n  if (!container) return null;\n\n  return ReactDOM.createPortal(<Slot {...portalProps} />, container);\n}\n\nexport { Portal };\n\nexport type { PortalProps };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}