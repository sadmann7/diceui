{
  "name": "scrollspy",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/scrollspy.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useCallbackRef } from \"@/hooks/use-callback-ref\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"ScrollSpy\";\nconst LIST_NAME = \"ScrollSpyList\";\nconst ITEM_NAME = \"ScrollSpyItem\";\nconst CONTENT_GROUP_NAME = \"ScrollSpyContentGroup\";\nconst CONTENT_NAME = \"ScrollSpyContent\";\n\ntype Direction = \"ltr\" | \"rtl\";\ntype Orientation = \"horizontal\" | \"vertical\";\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\ninterface StoreState {\n  activeValue: string | undefined;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nfunction createStore(\n  listenersRef: React.RefObject<Set<() => void>>,\n  stateRef: React.RefObject<StoreState>,\n  onValueChange?: (value: string) => void,\n): Store {\n  const store: Store = {\n    subscribe: (cb) => {\n      if (listenersRef.current) {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current?.delete(cb);\n      }\n      return () => {};\n    },\n    getState: () =>\n      stateRef.current ?? {\n        activeValue: undefined,\n      },\n    setState: (key, value) => {\n      const state = stateRef.current;\n      if (!state || Object.is(state[key], value)) return;\n\n      if (\n        key === \"activeValue\" &&\n        (typeof value === \"string\" || value === undefined)\n      ) {\n        state.activeValue = value;\n        if (value) onValueChange?.(value);\n      }\n\n      store.notify();\n    },\n    notify: () => {\n      if (listenersRef.current) {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      }\n    },\n  };\n\n  return store;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\nfunction useDirection(dir?: Direction): Direction {\n  const contextDir = React.useContext(DirectionContext);\n  return dir ?? contextDir ?? \"ltr\";\n}\n\ninterface ScrollSpyContextValue {\n  offset: number;\n  scrollBehavior: ScrollBehavior;\n  dir: Direction;\n  orientation: Orientation;\n  onContentRegister: (id: string, element: Element) => void;\n  onContentUnregister: (id: string) => void;\n}\n\nconst ScrollSpyContext = React.createContext<ScrollSpyContextValue | null>(\n  null,\n);\n\nfunction useScrollSpyContext(consumerName: string) {\n  const context = React.useContext(ScrollSpyContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface ScrollSpyRootProps extends React.ComponentProps<\"div\"> {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  rootMargin?: string;\n  threshold?: number | number[];\n  offset?: number;\n  scrollBehavior?: ScrollBehavior;\n  orientation?: Orientation;\n  dir?: Direction;\n  asChild?: boolean;\n}\n\nfunction ScrollSpyRoot(props: ScrollSpyRootProps) {\n  const { value, defaultValue, onValueChange, ...rootProps } = props;\n\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const stateRef = useLazyRef<StoreState>(() => ({\n    activeValue: value ?? defaultValue,\n  }));\n\n  const store = React.useMemo(\n    () => createStore(listenersRef, stateRef, onValueChange),\n    [listenersRef, stateRef, onValueChange],\n  );\n\n  return (\n    <StoreContext.Provider value={store}>\n      <ScrollSpyRootImpl value={value} {...rootProps} />\n    </StoreContext.Provider>\n  );\n}\n\nfunction ScrollSpyRootImpl(\n  props: Omit<ScrollSpyRootProps, \"defaultValue\" | \"onValueChange\">,\n) {\n  const {\n    value: valueProp,\n    rootMargin = \"0px 0px -80% 0px\",\n    threshold = 0.1,\n    offset = 0,\n    scrollBehavior = \"smooth\",\n    orientation = \"horizontal\",\n    dir: dirProp,\n    asChild,\n    className,\n    ...rootProps\n  } = props;\n\n  const dir = useDirection(dirProp);\n\n  const store = useStoreContext(ROOT_NAME);\n  const contentMapRef = React.useRef(new Map<string, Element>());\n  const observerRef = React.useRef<IntersectionObserver | null>(null);\n\n  const onContentRegister = React.useCallback(\n    (id: string, element: Element) => {\n      contentMapRef.current.set(id, element);\n      observerRef.current?.observe(element);\n    },\n    [],\n  );\n\n  const onContentUnregister = React.useCallback((id: string) => {\n    const element = contentMapRef.current.get(id);\n    if (element) {\n      observerRef.current?.unobserve(element);\n      contentMapRef.current.delete(id);\n    }\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    const visibleSections = new Set<string>();\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          const sectionId = entry.target.getAttribute(\"id\");\n          if (!sectionId) return;\n\n          if (entry.isIntersecting) {\n            visibleSections.add(sectionId);\n          } else {\n            visibleSections.delete(sectionId);\n          }\n        });\n\n        // Find the topmost visible section\n        if (visibleSections.size > 0) {\n          const sections = Array.from(contentMapRef.current.entries());\n          for (const [id, _] of sections) {\n            if (visibleSections.has(id)) {\n              store.setState(\"activeValue\", id);\n              break;\n            }\n          }\n        }\n      },\n      {\n        rootMargin,\n        threshold,\n      },\n    );\n\n    observerRef.current = observer;\n\n    // Observe existing sections\n    contentMapRef.current.forEach((element) => {\n      observer.observe(element);\n    });\n\n    return () => {\n      observer.disconnect();\n      observerRef.current = null;\n    };\n  }, [rootMargin, threshold]);\n\n  // Sync controlled value\n  React.useEffect(() => {\n    if (valueProp !== undefined) {\n      store.setState(\"activeValue\", valueProp);\n    }\n  }, [valueProp, store]);\n\n  const contextValue = React.useMemo<ScrollSpyContextValue>(\n    () => ({\n      offset,\n      scrollBehavior,\n      dir,\n      orientation,\n      onContentRegister,\n      onContentUnregister,\n    }),\n    [\n      offset,\n      scrollBehavior,\n      dir,\n      orientation,\n      onContentRegister,\n      onContentUnregister,\n    ],\n  );\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <DirectionContext.Provider value={dir}>\n      <ScrollSpyContext.Provider value={contextValue}>\n        <RootPrimitive\n          data-orientation={orientation}\n          data-slot=\"scrollspy\"\n          dir={dir}\n          {...rootProps}\n          className={cn(\n            \"flex gap-8\",\n            orientation === \"horizontal\" ? \"flex-row\" : \"flex-col\",\n            className,\n          )}\n        />\n      </ScrollSpyContext.Provider>\n    </DirectionContext.Provider>\n  );\n}\n\ninterface ScrollSpyItemGroupProps extends React.ComponentProps<\"nav\"> {\n  asChild?: boolean;\n}\n\nfunction ScrollSpyItemGroup(props: ScrollSpyItemGroupProps) {\n  const { asChild, className, ...listProps } = props;\n\n  const { dir, orientation } = useScrollSpyContext(LIST_NAME);\n\n  const ListPrimitive = asChild ? Slot : \"nav\";\n\n  return (\n    <ListPrimitive\n      data-orientation={orientation}\n      data-slot=\"scrollspy-list\"\n      dir={dir}\n      className={cn(\n        \"flex gap-2\",\n        orientation === \"horizontal\" ? \"flex-col\" : \"flex-row\",\n        className,\n      )}\n      {...listProps}\n    />\n  );\n}\n\ninterface ScrollSpyItemProps extends React.ComponentProps<\"a\"> {\n  value: string;\n  asChild?: boolean;\n}\n\nfunction ScrollSpyItem(props: ScrollSpyItemProps) {\n  const { value, asChild, onClick, className, ...itemProps } = props;\n\n  const { orientation, offset, scrollBehavior } =\n    useScrollSpyContext(ITEM_NAME);\n  const activeValue = useStore((state) => state.activeValue);\n  const isActive = activeValue === value;\n\n  const onItemClick = React.useCallback(\n    (event: React.MouseEvent<HTMLAnchorElement>) => {\n      event.preventDefault();\n      onClick?.(event);\n\n      const element = document.getElementById(value);\n      if (!element) return;\n\n      const elementPosition = element.getBoundingClientRect().top;\n      const offsetPosition = elementPosition + window.scrollY - offset;\n\n      window.scrollTo({\n        top: offsetPosition,\n        behavior: scrollBehavior,\n      });\n    },\n    [offset, scrollBehavior, value, onClick],\n  );\n\n  const ItemPrimitive = asChild ? Slot : \"a\";\n\n  return (\n    <ItemPrimitive\n      data-orientation={orientation}\n      data-slot=\"scrollspy-item\"\n      data-state={isActive ? \"active\" : \"inactive\"}\n      className={cn(\n        \"rounded px-3 py-1.5 text-muted-foreground text-sm transition-colors hover:bg-accent hover:text-accent-foreground data-[state=active]:bg-accent data-[state=active]:font-medium data-[state=active]:text-foreground\",\n        className,\n      )}\n      {...itemProps}\n      href={`#${value}`}\n      onClick={onItemClick}\n    />\n  );\n}\n\ninterface ScrollSpyContentGroupProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction ScrollSpyContentGroup(props: ScrollSpyContentGroupProps) {\n  const { asChild, className, ...groupProps } = props;\n\n  const { dir, orientation } = useScrollSpyContext(CONTENT_GROUP_NAME);\n\n  const GroupPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <GroupPrimitive\n      data-orientation={orientation}\n      data-slot=\"scrollspy-content-group\"\n      dir={dir}\n      {...groupProps}\n      className={cn(\"flex flex-1 flex-col gap-8\", className)}\n    />\n  );\n}\n\ninterface ScrollSpyContentProps extends React.ComponentProps<\"div\"> {\n  value: string;\n  asChild?: boolean;\n}\n\nfunction ScrollSpyContent(props: ScrollSpyContentProps) {\n  const { asChild, ref, value, ...contentProps } = props;\n\n  const { orientation, onContentRegister, onContentUnregister } =\n    useScrollSpyContext(CONTENT_NAME);\n  const contentRef = React.useRef<HTMLDivElement>(null);\n  const composedRef = useComposedRefs(ref, contentRef);\n\n  useIsomorphicLayoutEffect(() => {\n    const element = contentRef.current;\n    if (!element || !value) return;\n\n    onContentRegister(value, element);\n\n    return () => {\n      onContentUnregister(value);\n    };\n  }, [value, onContentRegister, onContentUnregister]);\n\n  const ContentPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ContentPrimitive\n      data-orientation={orientation}\n      data-slot=\"scrollspy-content\"\n      {...contentProps}\n      id={value}\n      ref={composedRef}\n    />\n  );\n}\n\nexport {\n  ScrollSpyRoot as Root,\n  ScrollSpyItemGroup as ItemGroup,\n  ScrollSpyItem as Item,\n  ScrollSpyContentGroup as ContentGroup,\n  ScrollSpyContent as Content,\n  //\n  ScrollSpyRoot as ScrollSpy,\n  ScrollSpyItemGroup,\n  ScrollSpyItem,\n  ScrollSpyContentGroup,\n  ScrollSpyContent,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}