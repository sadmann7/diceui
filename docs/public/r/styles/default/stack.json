{
  "name": "stack",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/stack.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface ItemHeight {\n  itemId: number;\n  height: number;\n}\n\ninterface StackContextValue {\n  childrenCount: number;\n  itemCount: number;\n  expandedItemCount: number;\n  gap: number;\n  scale: number;\n  offset: number;\n  heights: ItemHeight[];\n  setHeights: React.Dispatch<React.SetStateAction<ItemHeight[]>>;\n  expandOnHover: boolean;\n  isExpanded: boolean;\n  isInteracting: boolean;\n}\n\nconst StackContext = React.createContext<StackContextValue | null>(null);\n\nfunction useStackContext() {\n  const context = React.useContext(StackContext);\n  if (!context) {\n    throw new Error(\"Stack components must be used within Stack.Root\");\n  }\n  return context;\n}\n\ninterface StackRootProps extends React.ComponentProps<\"div\"> {\n  itemCount?: number;\n  expandedItemCount?: number;\n  gap?: number;\n  scale?: number;\n  offset?: number;\n  expandOnHover?: boolean;\n  asChild?: boolean;\n}\n\nfunction StackRoot(props: StackRootProps) {\n  const {\n    itemCount = 3,\n    expandedItemCount,\n    gap = 8,\n    scale = 0.05,\n    offset = 10,\n    className,\n    children,\n    style,\n    onMouseEnter: onMouseEnterProp,\n    onMouseLeave: onMouseLeaveProp,\n    onMouseMove: onMouseMoveProp,\n    onPointerDown: onPointerDownProp,\n    onPointerUp: onPointerUpProp,\n    expandOnHover = false,\n    asChild,\n    ...rootProps\n  } = props;\n\n  const [isExpanded, setIsExpanded] = React.useState(false);\n  const [isInteracting, setIsInteracting] = React.useState(false);\n  const [heights, setHeights] = React.useState<ItemHeight[]>([]);\n\n  const childrenArray = React.Children.toArray(children).filter(\n    React.isValidElement,\n  );\n  const childrenCount = childrenArray.length;\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  const effectiveExpandedItemCount = expandedItemCount ?? childrenCount;\n\n  const onMouseEnter = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      onMouseEnterProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (expandOnHover) {\n        setIsExpanded(true);\n      }\n    },\n    [expandOnHover, onMouseEnterProp],\n  );\n\n  const onMouseMove = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      onMouseMoveProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (expandOnHover) {\n        setIsExpanded(true);\n      }\n    },\n    [expandOnHover, onMouseMoveProp],\n  );\n\n  const onMouseLeave = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      onMouseLeaveProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (expandOnHover && !isInteracting) {\n        setIsExpanded(false);\n      }\n    },\n    [expandOnHover, isInteracting, onMouseLeaveProp],\n  );\n\n  const onPointerDown = React.useCallback(\n    (event: React.PointerEvent<HTMLDivElement>) => {\n      onPointerDownProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsInteracting(true);\n    },\n    [onPointerDownProp],\n  );\n\n  const onPointerUp = React.useCallback(\n    (event: React.PointerEvent<HTMLDivElement>) => {\n      onPointerUpProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsInteracting(false);\n    },\n    [onPointerUpProp],\n  );\n\n  const contextValue = React.useMemo<StackContextValue>(\n    () => ({\n      childrenCount,\n      itemCount,\n      expandedItemCount: effectiveExpandedItemCount,\n      gap,\n      scale,\n      offset,\n      expandOnHover,\n      isExpanded,\n      isInteracting,\n      heights,\n      setHeights,\n    }),\n    [\n      childrenCount,\n      itemCount,\n      effectiveExpandedItemCount,\n      gap,\n      scale,\n      offset,\n      expandOnHover,\n      isExpanded,\n      isInteracting,\n      heights,\n    ],\n  );\n\n  return (\n    <StackContext.Provider value={contextValue}>\n      <RootPrimitive\n        data-slot=\"stack\"\n        data-expanded={isExpanded}\n        onMouseEnter={onMouseEnter}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        onPointerDown={onPointerDown}\n        onPointerUp={onPointerUp}\n        {...rootProps}\n        className={cn(\"relative w-full\", className)}\n        style={\n          {\n            \"--stack-gap\": `${gap}px`,\n            \"--stack-offset\": `${offset}px`,\n            \"--stack-scale\": scale,\n            ...style,\n          } as React.CSSProperties\n        }\n      >\n        {childrenArray.map((child, index) => (\n          <StackItemWrapper key={index} index={index}>\n            {child}\n          </StackItemWrapper>\n        ))}\n      </RootPrimitive>\n    </StackContext.Provider>\n  );\n}\n\ninterface StackItemWrapperProps extends React.ComponentProps<\"div\"> {\n  index: number;\n}\n\nfunction StackItemWrapper(props: StackItemWrapperProps) {\n  const { children, index, style, ...itemProps } = props;\n\n  const {\n    childrenCount,\n    itemCount,\n    expandedItemCount,\n    gap,\n    scale,\n    offset,\n    isExpanded,\n    heights,\n    setHeights,\n  } = useStackContext();\n\n  const itemRef = React.useRef<HTMLDivElement>(null);\n\n  const isFront = index === 0;\n  const isVisible = isExpanded ? index < expandedItemCount : index < itemCount;\n  const itemsBefore = index;\n\n  React.useEffect(() => {\n    const itemNode = itemRef.current;\n    if (itemNode) {\n      const height = itemNode.getBoundingClientRect().height;\n      setHeights((h) => {\n        const existing = h.find((item) => item.itemId === index);\n        if (!existing) {\n          return [...h, { itemId: index, height }];\n        }\n        return h.map((item) =>\n          item.itemId === index ? { ...item, height } : item,\n        );\n      });\n    }\n  }, [index, setHeights]);\n\n  const itemsHeightBefore = React.useMemo(() => {\n    return heights.reduce((prev, curr) => {\n      if (curr.itemId >= index) return prev;\n      return prev + curr.height;\n    }, 0);\n  }, [heights, index]);\n\n  const itemScale = isExpanded ? 1 : 1 - itemsBefore * scale;\n  const translateY = isExpanded\n    ? itemsBefore * gap + itemsHeightBefore\n    : itemsBefore * offset;\n  const zIndex = childrenCount - index;\n\n  const opacity = !isVisible ? 0 : isExpanded ? 1 : 1 - itemsBefore * 0.15;\n\n  return (\n    <div\n      ref={itemRef}\n      data-slot=\"stack-item-wrapper\"\n      data-index={index}\n      data-front={isFront}\n      data-visible={isVisible}\n      data-expanded={isExpanded}\n      className={cn(\n        \"absolute top-0 left-0 w-full transition-all duration-300 ease-out\",\n        \"after:absolute after:bottom-full after:left-0 after:w-full after:content-['']\",\n        !isVisible && \"pointer-events-none\",\n        isExpanded && \"after:h-[calc(var(--stack-gap)+1px)]\",\n      )}\n      style={{\n        transform: `translateY(${translateY}px) scale(${itemScale})`,\n        transformOrigin: \"top center\",\n        zIndex,\n        opacity,\n        ...style,\n      }}\n      {...itemProps}\n    >\n      {children}\n    </div>\n  );\n}\n\ninterface StackItemProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction StackItem(props: StackItemProps) {\n  const { asChild, className, ...itemProps } = props;\n\n  const ItemPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemPrimitive\n      data-slot=\"stack-item\"\n      {...itemProps}\n      className={cn(\n        \"rounded-lg border bg-card p-4 shadow-md\",\n        \"transition-shadow duration-200\",\n        \"hover:shadow-lg\",\n        className,\n      )}\n    />\n  );\n}\n\nexport {\n  StackRoot as Root,\n  StackItem as Item,\n  //\n  StackRoot as Stack,\n  StackItem,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}