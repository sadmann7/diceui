{
  "name": "stack",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/stack.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface HeightT {\n  itemId: number;\n  height: number;\n}\n\ninterface StackContextValue {\n  visibleItems: number;\n  gap: number;\n  scaleFactor: number;\n  expandOnHover: boolean;\n  offset: number;\n  isExpanded: boolean;\n  totalItems: number;\n  heights: HeightT[];\n  setHeights: React.Dispatch<React.SetStateAction<HeightT[]>>;\n}\n\nconst StackContext = React.createContext<StackContextValue | null>(null);\n\nfunction useStackContext() {\n  const context = React.useContext(StackContext);\n  if (!context) {\n    throw new Error(\"Stack components must be used within Stack.Root\");\n  }\n  return context;\n}\n\ninterface StackRootProps extends React.ComponentProps<\"div\"> {\n  visibleItems?: number;\n  gap?: number;\n  scaleFactor?: number;\n  expandOnHover?: boolean;\n  offset?: number;\n  asChild?: boolean;\n}\n\nfunction StackRoot(props: StackRootProps) {\n  const {\n    visibleItems = 3,\n    gap = 8,\n    scaleFactor = 0.05,\n    expandOnHover = true,\n    offset = 10,\n    asChild,\n    className,\n    children,\n    onMouseEnter,\n    onMouseLeave,\n    ...rootProps\n  } = props;\n\n  const [isExpanded, setIsExpanded] = React.useState(false);\n  const [heights, setHeights] = React.useState<HeightT[]>([]);\n\n  const childrenArray = React.Children.toArray(children).filter(\n    React.isValidElement,\n  );\n  const totalItems = childrenArray.length;\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  const contextValue: StackContextValue = {\n    visibleItems,\n    gap,\n    scaleFactor,\n    expandOnHover,\n    offset,\n    isExpanded,\n    totalItems,\n    heights,\n    setHeights,\n  };\n\n  function onMouseEnterHandler(event: React.MouseEvent<HTMLDivElement>) {\n    if (expandOnHover) {\n      setIsExpanded(true);\n    }\n    onMouseEnter?.(event);\n  }\n\n  function onMouseLeaveHandler(event: React.MouseEvent<HTMLDivElement>) {\n    if (expandOnHover) {\n      setIsExpanded(false);\n    }\n    onMouseLeave?.(event);\n  }\n\n  return (\n    <StackContext.Provider value={contextValue}>\n      <RootPrimitive\n        data-slot=\"stack\"\n        data-expanded={isExpanded}\n        onMouseEnter={onMouseEnterHandler}\n        onMouseLeave={onMouseLeaveHandler}\n        {...rootProps}\n        className={cn(\"relative\", className)}\n        style={\n          {\n            \"--stack-gap\": `${gap}px`,\n            \"--stack-offset\": `${offset}px`,\n            \"--stack-scale-factor\": scaleFactor,\n          } as React.CSSProperties\n        }\n      >\n        {childrenArray.map((child, index) => (\n          <StackItemWrapper key={index} index={index}>\n            {child}\n          </StackItemWrapper>\n        ))}\n      </RootPrimitive>\n    </StackContext.Provider>\n  );\n}\n\ninterface StackItemWrapperProps {\n  children: React.ReactNode;\n  index: number;\n}\n\nfunction StackItemWrapper({ children, index }: StackItemWrapperProps) {\n  const context = useStackContext();\n  const {\n    visibleItems,\n    gap,\n    scaleFactor,\n    offset,\n    isExpanded,\n    totalItems,\n    heights,\n    setHeights,\n  } = context;\n\n  const itemRef = React.useRef<HTMLDivElement>(null);\n\n  const isFront = index === 0;\n  const isVisible = index < visibleItems;\n  const itemsBefore = index;\n\n  // Similar to Sonner's height tracking\n  React.useEffect(() => {\n    const itemNode = itemRef.current;\n    if (itemNode) {\n      const height = itemNode.getBoundingClientRect().height;\n      setHeights((h) => {\n        const existing = h.find((item) => item.itemId === index);\n        if (!existing) {\n          return [...h, { itemId: index, height }];\n        }\n        return h.map((item) =>\n          item.itemId === index ? { ...item, height } : item,\n        );\n      });\n    }\n  }, [index, setHeights]);\n\n  // Calculate offset based on actual heights (like Sonner)\n  const itemsHeightBefore = React.useMemo(() => {\n    return heights.reduce((prev, curr) => {\n      if (curr.itemId >= index) return prev;\n      return prev + curr.height;\n    }, 0);\n  }, [heights, index]);\n\n  // Calculate transform values\n  const scale = isExpanded ? 1 : 1 - itemsBefore * scaleFactor;\n  const translateY = isExpanded\n    ? itemsBefore * gap + itemsHeightBefore\n    : itemsBefore * offset;\n  const zIndex = totalItems - index;\n\n  const opacity = isExpanded ? 1 : isVisible ? 1 - itemsBefore * 0.15 : 0;\n\n  return (\n    <div\n      ref={itemRef}\n      data-slot=\"stack-item-wrapper\"\n      data-index={index}\n      data-front={isFront}\n      data-visible={isVisible}\n      className={cn(\n        \"absolute top-0 left-0 w-full transition-all duration-300 ease-out\",\n        !isVisible && \"pointer-events-none\",\n      )}\n      style={{\n        transform: `translateY(${translateY}px) scale(${scale})`,\n        transformOrigin: \"top center\",\n        zIndex,\n        opacity,\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n\ninterface StackItemProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction StackItem(props: StackItemProps) {\n  const { asChild, className, ...itemProps } = props;\n\n  const ItemPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemPrimitive\n      data-slot=\"stack-item\"\n      {...itemProps}\n      className={cn(\n        \"rounded-lg border bg-card p-4 shadow-md\",\n        \"transition-shadow duration-200\",\n        \"hover:shadow-lg\",\n        className,\n      )}\n    />\n  );\n}\n\nexport { StackRoot as Root, StackItem as Item };\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}