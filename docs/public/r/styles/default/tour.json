{
  "name": "tour",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/tour.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { ChevronLeft, ChevronRight, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"Tour\";\nconst STEP_NAME = \"TourStep\";\nconst CLOSE_NAME = \"TourClose\";\nconst PREV_NAME = \"TourPrev\";\nconst NEXT_NAME = \"TourNext\";\nconst SKIP_NAME = \"TourSkip\";\nconst OVERLAY_NAME = \"TourOverlay\";\n\ntype Direction = \"ltr\" | \"rtl\";\ntype Placement =\n  | \"top\"\n  | \"top-start\"\n  | \"top-end\"\n  | \"bottom\"\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"left\"\n  | \"left-start\"\n  | \"left-end\"\n  | \"right\"\n  | \"right-start\"\n  | \"right-end\";\n\ninterface ScrollOffset {\n  top?: number;\n  bottom?: number;\n  left?: number;\n  right?: number;\n}\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\ninterface StepData {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  placement?: Placement;\n  offset?: number;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  required?: boolean;\n}\n\ninterface State {\n  open: boolean;\n  value: number;\n  steps: StepData[];\n  position: { top: number; left: number };\n  maskPath: string;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  snapshot: () => State;\n  setState: <K extends keyof State>(\n    key: K,\n    value: State[K],\n    opts?: unknown,\n  ) => void;\n  notify: () => void;\n  addStep: (stepData: StepData) => number;\n  removeStep: (index: number) => void;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useStore<T>(selector: (state: State) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.snapshot()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\nfunction getTargetElement(\n  target: string | React.RefObject<HTMLElement> | HTMLElement,\n): HTMLElement | null {\n  if (typeof target === \"string\") {\n    return document.querySelector(target);\n  }\n  if (target && \"current\" in target) {\n    return target.current;\n  }\n  if (target instanceof HTMLElement) {\n    return target;\n  }\n  return null;\n}\n\nfunction getElementRect(element: HTMLElement) {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top + window.scrollY,\n    left: rect.left + window.scrollX,\n    width: rect.width,\n    height: rect.height,\n    bottom: rect.bottom + window.scrollY,\n    right: rect.right + window.scrollX,\n  };\n}\n\nfunction scrollToElement(\n  element: HTMLElement,\n  scrollBehavior: ScrollBehavior = \"smooth\",\n  scrollOffset?: ScrollOffset,\n) {\n  const offset = {\n    top: 100,\n    bottom: 100,\n    left: 0,\n    right: 0,\n    ...scrollOffset,\n  };\n  const rect = element.getBoundingClientRect();\n  const viewportHeight = window.innerHeight;\n  const viewportWidth = window.innerWidth;\n\n  const isInViewport =\n    rect.top >= offset.top &&\n    rect.bottom <= viewportHeight - offset.bottom &&\n    rect.left >= offset.left &&\n    rect.right <= viewportWidth - offset.right;\n\n  if (!isInViewport) {\n    const elementTop = rect.top + window.scrollY;\n    const scrollTop = elementTop - offset.top;\n\n    window.scrollTo({\n      top: Math.max(0, scrollTop),\n      behavior: scrollBehavior,\n    });\n  }\n}\n\nfunction updatePositionAndMask(\n  store: Store,\n  stepData: StepData,\n  padding: number = 4,\n) {\n  const targetElement = getTargetElement(stepData.target);\n  if (!targetElement) return;\n\n  const rect = getElementRect(targetElement);\n  const placement = stepData.placement ?? \"bottom\";\n  const offset = stepData.offset ?? 8;\n\n  let top = 0;\n  let left = 0;\n\n  switch (placement) {\n    case \"top\":\n      top = rect.top - offset;\n      left = rect.left + rect.width / 2;\n      break;\n    case \"top-start\":\n      top = rect.top - offset;\n      left = rect.left;\n      break;\n    case \"top-end\":\n      top = rect.top - offset;\n      left = rect.right;\n      break;\n    case \"bottom\":\n      top = rect.bottom + offset;\n      left = rect.left + rect.width / 2;\n      break;\n    case \"bottom-start\":\n      top = rect.bottom + offset;\n      left = rect.left;\n      break;\n    case \"bottom-end\":\n      top = rect.bottom + offset;\n      left = rect.right;\n      break;\n    case \"left\":\n      top = rect.top + rect.height / 2;\n      left = rect.left - offset;\n      break;\n    case \"left-start\":\n      top = rect.top;\n      left = rect.left - offset;\n      break;\n    case \"left-end\":\n      top = rect.bottom;\n      left = rect.left - offset;\n      break;\n    case \"right\":\n      top = rect.top + rect.height / 2;\n      left = rect.right + offset;\n      break;\n    case \"right-start\":\n      top = rect.top;\n      left = rect.right + offset;\n      break;\n    case \"right-end\":\n      top = rect.bottom;\n      left = rect.right + offset;\n      break;\n  }\n\n  store.setState(\"position\", { top, left });\n\n  const clientRect = targetElement.getBoundingClientRect();\n  const viewportWidth = window.innerWidth;\n  const viewportHeight = window.innerHeight;\n\n  const x = Math.max(0, clientRect.left - padding);\n  const y = Math.max(0, clientRect.top - padding);\n  const width = Math.min(viewportWidth - x, clientRect.width + padding * 2);\n  const height = Math.min(viewportHeight - y, clientRect.height + padding * 2);\n\n  const path = `polygon(0% 0%, 0% 100%, ${x}px 100%, ${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px, ${x}px 100%, 100% 100%, 100% 0%)`;\n  store.setState(\"maskPath\", path);\n}\n\nfunction getTransform(placement: Placement = \"bottom\") {\n  switch (placement) {\n    case \"top\":\n    case \"top-start\":\n    case \"top-end\":\n      return \"translate(-50%, -100%)\";\n    case \"bottom\":\n    case \"bottom-start\":\n    case \"bottom-end\":\n      return \"translate(-50%, 0)\";\n    case \"left\":\n    case \"left-start\":\n    case \"left-end\":\n      return \"translate(-100%, -50%)\";\n    case \"right\":\n    case \"right-start\":\n    case \"right-end\":\n      return \"translate(0, -50%)\";\n  }\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nconst TourContext = React.createContext<React.ReactElement | undefined>(\n  undefined,\n);\n\nfunction useTourContext(consumerName: string) {\n  const context = React.useContext(TourContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface TourRootProps extends DivProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  value?: number;\n  defaultValue?: number;\n  onValueChange?: (step: number) => void;\n  onComplete?: () => void;\n  onSkip?: () => void;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  dir?: Direction;\n  padding?: number;\n  borderRadius?: number;\n  scrollToElement?: boolean;\n  scrollBehavior?: ScrollBehavior;\n  scrollOffset?: ScrollOffset;\n  stepFooter?: React.ReactElement;\n}\n\nfunction TourRoot(props: TourRootProps) {\n  const {\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    value: valueProp,\n    defaultValue = 0,\n    onValueChange,\n    onComplete,\n    onSkip,\n    onEscapeKeyDown,\n    stepFooter,\n    padding = 4,\n    scrollToElement: scrollToElementProp = false,\n    scrollBehavior = \"smooth\",\n    scrollOffset,\n    asChild,\n    ...rootProps\n  } = props;\n\n  const state = useLazyRef<State>(() => ({\n    open: openProp ?? defaultOpen,\n    value: valueProp ?? defaultValue,\n    steps: [],\n    position: { top: 0, left: 0 },\n    maskPath: \"\",\n  }));\n\n  const listeners = useLazyRef<Set<() => void>>(() => new Set());\n\n  const store: Store = React.useMemo(() => {\n    return {\n      subscribe: (cb) => {\n        listeners.current.add(cb);\n        return () => listeners.current.delete(cb);\n      },\n      snapshot: () => {\n        return state.current;\n      },\n      setState: (key, value, _opts) => {\n        if (Object.is(state.current[key], value)) return;\n        state.current[key] = value;\n\n        if (key === \"open\") {\n          onOpenChange?.(value as boolean);\n\n          if (value) {\n            if (state.current.steps.length > 0) {\n              if (state.current.value >= state.current.steps.length) {\n                store.setState(\"value\", 0);\n              }\n\n              const currentStepIndex =\n                state.current.value >= state.current.steps.length\n                  ? 0\n                  : state.current.value;\n              const currentStepData = state.current.steps[currentStepIndex];\n              if (currentStepData) {\n                queueMicrotask(() => {\n                  updatePositionAndMask(store, currentStepData, padding);\n                });\n              }\n            }\n          } else {\n            if (state.current.value < (state.current.steps.length || 0) - 1) {\n              onSkip?.();\n            }\n          }\n        } else if (key === \"value\") {\n          const prevStep = state.current.steps[state.current.value];\n          const nextStep = state.current.steps[value as number];\n\n          prevStep?.onStepLeave?.();\n          nextStep?.onStepEnter?.();\n\n          if (valueProp !== undefined) {\n            onValueChange?.(value as number);\n            return;\n          }\n\n          onValueChange?.(value as number);\n\n          if ((value as number) >= state.current.steps.length) {\n            onComplete?.();\n            store.setState(\"open\", false);\n            return;\n          }\n\n          if (nextStep) {\n            updatePositionAndMask(store, nextStep, padding);\n\n            if (scrollToElementProp) {\n              const targetElement = getTargetElement(nextStep.target);\n              if (targetElement) {\n                scrollToElement(targetElement, scrollBehavior, scrollOffset);\n              }\n            }\n          }\n        }\n\n        store.notify();\n      },\n      notify: () => {\n        listeners.current.forEach((l) => {\n          l();\n        });\n      },\n      addStep: (stepData) => {\n        const newSteps = [...state.current.steps, stepData];\n        state.current.steps = newSteps;\n        store.notify();\n        return newSteps.length - 1;\n      },\n      removeStep: (index) => {\n        state.current.steps = state.current.steps.filter((_, i) => i !== index);\n        store.notify();\n      },\n    };\n  }, [\n    onOpenChange,\n    onValueChange,\n    onComplete,\n    onSkip,\n    padding,\n    scrollToElementProp,\n    scrollBehavior,\n    scrollOffset,\n    valueProp,\n    state,\n    listeners,\n  ]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (openProp !== undefined) {\n      store.setState(\"open\", openProp);\n    }\n  }, [openProp, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (valueProp !== undefined) {\n      store.setState(\"value\", valueProp);\n    }\n  }, [valueProp, store]);\n\n  React.useEffect(() => {\n    function onKeyDown(event: KeyboardEvent) {\n      if (state.current.open && event.key === \"Escape\") {\n        if (onEscapeKeyDown) {\n          onEscapeKeyDown(event);\n          if (event.defaultPrevented) return;\n        }\n        store.setState(\"open\", false);\n      }\n    }\n\n    document.addEventListener(\"keydown\", onKeyDown);\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\n  }, [store, onEscapeKeyDown, state]);\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StoreContext.Provider value={store}>\n      <TourContext.Provider value={stepFooter}>\n        <RootPrimitive data-slot=\"tour\" {...rootProps} />\n      </TourContext.Provider>\n    </StoreContext.Provider>\n  );\n}\n\ninterface TourStepProps extends DivProps {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  placement?: Placement;\n  offset?: number;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  required?: boolean;\n  forceMount?: boolean;\n}\n\nfunction TourStep(props: TourStepProps) {\n  const {\n    target,\n    placement = \"bottom\",\n    offset = 8,\n    required = false,\n    forceMount = false,\n    onStepEnter,\n    onStepLeave,\n    className,\n    children,\n    asChild,\n    ...stepProps\n  } = props;\n\n  const store = useStoreContext(STEP_NAME);\n  const stepIndexRef = React.useRef<number>(-1);\n\n  const open = useStore((state) => state.open);\n  const value = useStore((state) => state.value);\n  const steps = useStore((state) => state.steps);\n  const position = useStore((state) => state.position);\n  const stepFooter = useTourContext(STEP_NAME);\n\n  const hasStepFooter = React.Children.toArray(children).some((child) => {\n    if (!React.isValidElement(child)) return false;\n    return child.type === TourFooter;\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const stepData: StepData = {\n      target,\n      placement,\n      offset,\n      onStepEnter,\n      onStepLeave,\n      required,\n    };\n\n    const index = store.addStep(stepData);\n    stepIndexRef.current = index;\n\n    const state = store.snapshot();\n    if (index === 0 && state.open) {\n      queueMicrotask(() => {\n        updatePositionAndMask(store, stepData, 4);\n      });\n    }\n\n    return () => {\n      store.removeStep(stepIndexRef.current);\n    };\n  }, [store, target, placement, offset, required, onStepEnter, onStepLeave]);\n\n  const stepData = steps[value];\n  const targetElement = stepData ? getTargetElement(stepData.target) : null;\n\n  const isCurrentStep = stepIndexRef.current === value;\n\n  React.useEffect(() => {\n    if (!open || !stepData || !targetElement || !isCurrentStep) return;\n\n    function updatePosition() {\n      if (stepData) {\n        updatePositionAndMask(store, stepData, 4);\n      }\n    }\n\n    updatePosition();\n    window.addEventListener(\"resize\", updatePosition);\n    window.addEventListener(\"scroll\", updatePosition);\n\n    return () => {\n      window.removeEventListener(\"resize\", updatePosition);\n      window.removeEventListener(\"scroll\", updatePosition);\n    };\n  }, [open, stepData, targetElement, store, isCurrentStep]);\n\n  if (!open || !stepData || (!targetElement && !forceMount) || !isCurrentStep) {\n    return null;\n  }\n\n  const StepPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StepPrimitive\n      data-slot=\"tour-step\"\n      {...stepProps}\n      className={cn(\n        \"fixed z-50 w-80 rounded-lg border bg-popover p-4 text-popover-foreground shadow-md\",\n        className,\n      )}\n      style={{\n        top: position.top,\n        left: position.left,\n        transform: getTransform(stepData.placement),\n      }}\n    >\n      {children}\n      {!hasStepFooter && stepFooter && stepFooter}\n    </StepPrimitive>\n  );\n}\n\ninterface TourOverlayProps extends DivProps {\n  forceMount?: boolean;\n}\n\nfunction TourOverlay(props: TourOverlayProps) {\n  const {\n    asChild,\n    className,\n    style,\n    forceMount = false,\n    ...backdropProps\n  } = props;\n\n  const store = useStoreContext(OVERLAY_NAME);\n  const open = useStore((state) => state.open);\n  const maskPath = useStore((state) => state.maskPath);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      backdropProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, backdropProps.onClick],\n  );\n\n  if (!open && !forceMount) return null;\n\n  const OverlayPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <OverlayPrimitive\n      data-state={open ? \"open\" : \"closed\"}\n      data-slot=\"tour-overlay\"\n      {...backdropProps}\n      className={cn(\n        \"data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in\",\n        className,\n      )}\n      style={{\n        ...style,\n        clipPath: maskPath,\n      }}\n      onClick={onClick}\n    />\n  );\n}\n\nfunction TourHeader(props: DivProps) {\n  const { asChild, className, ...headerProps } = props;\n\n  const HeaderPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <HeaderPrimitive\n      data-slot=\"tour-header\"\n      {...headerProps}\n      className={cn(\n        \"flex flex-col gap-1.5 text-center sm:text-left\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TourTitleProps extends React.ComponentProps<\"h2\"> {\n  asChild?: boolean;\n}\n\nfunction TourTitle(props: TourTitleProps) {\n  const { asChild, className, ...titleProps } = props;\n\n  const TitlePrimitive = asChild ? Slot : \"h2\";\n\n  return (\n    <TitlePrimitive\n      data-slot=\"tour-title\"\n      {...titleProps}\n      className={cn(\n        \"font-semibold text-lg leading-none tracking-tight\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TourDescriptionProps extends React.ComponentProps<\"p\"> {\n  asChild?: boolean;\n}\n\nfunction TourDescription(props: TourDescriptionProps) {\n  const { asChild, className, ...descriptionProps } = props;\n\n  const DescriptionPrimitive = asChild ? Slot : \"p\";\n\n  return (\n    <DescriptionPrimitive\n      data-slot=\"tour-description\"\n      {...descriptionProps}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n    />\n  );\n}\n\nfunction TourFooter(props: DivProps) {\n  const { asChild, className, ...footerProps } = props;\n\n  const FooterPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <FooterPrimitive\n      data-slot=\"tour-footer\"\n      {...footerProps}\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className,\n      )}\n    />\n  );\n}\n\nfunction TourClose(props: ButtonProps) {\n  const { asChild, className, ...closeButtonProps } = props;\n\n  const store = useStoreContext(CLOSE_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      closeButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, closeButtonProps.onClick],\n  );\n\n  const ClosePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ClosePrimitive\n      type=\"button\"\n      aria-label=\"Close tour\"\n      className={cn(\n        \"absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\",\n        className,\n      )}\n      onClick={onClick}\n      {...closeButtonProps}\n    >\n      <X className=\"size-4\" />\n    </ClosePrimitive>\n  );\n}\n\ninterface TourStepCounterProps extends DivProps {\n  format?: (current: number, total: number) => string;\n}\n\nfunction TourStepCounter(props: TourStepCounterProps) {\n  const {\n    format = (current, total) => `${current} / ${total}`,\n    asChild,\n    className,\n    children,\n    ...stepCounterProps\n  } = props;\n\n  const value = useStore((state) => state.value);\n  const steps = useStore((state) => state.steps);\n\n  const StepCounterPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StepCounterPrimitive\n      data-slot=\"tour-step-counter\"\n      {...stepCounterProps}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n    >\n      {children ?? format(value + 1, steps.length)}\n    </StepCounterPrimitive>\n  );\n}\n\nfunction TourPrev(props: ButtonProps) {\n  const { asChild, className, children, ...prevButtonProps } = props;\n\n  const store = useStoreContext(PREV_NAME);\n  const value = useStore((state) => state.value);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      prevButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      if (value > 0) {\n        store.setState(\"value\", value - 1);\n      }\n    },\n    [value, store, prevButtonProps.onClick],\n  );\n\n  const isDisabled = value === 0;\n\n  const PrevPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <PrevPrimitive\n      type=\"button\"\n      aria-label=\"Previous step\"\n      data-slot=\"tour-prev\"\n      {...prevButtonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n      disabled={isDisabled}\n    >\n      {children ?? (\n        <>\n          <ChevronLeft className=\"size-4\" />\n          Previous\n        </>\n      )}\n    </PrevPrimitive>\n  );\n}\n\nfunction TourNext(props: ButtonProps) {\n  const { asChild, className, children, ...nextButtonProps } = props;\n  const store = useStoreContext(NEXT_NAME);\n  const value = useStore((state) => state.value);\n  const steps = useStore((state) => state.steps);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      nextButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"value\", value + 1);\n    },\n    [value, store, nextButtonProps.onClick],\n  );\n\n  const isLastStep = value === steps.length - 1;\n\n  const NextPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <NextPrimitive\n      type=\"button\"\n      aria-label=\"Next step\"\n      data-slot=\"tour-next\"\n      {...nextButtonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md bg-primary px-3 font-medium text-primary-foreground text-sm ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n    >\n      {children ?? (\n        <>\n          {isLastStep ? \"Finish\" : \"Next\"}\n          {!isLastStep && <ChevronRight className=\"size-4\" />}\n        </>\n      )}\n    </NextPrimitive>\n  );\n}\n\nfunction TourSkip(props: ButtonProps) {\n  const { asChild, className, children, ...skipButtonProps } = props;\n\n  const store = useStoreContext(SKIP_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      skipButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, skipButtonProps.onClick],\n  );\n\n  const SkipPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <SkipPrimitive\n      type=\"button\"\n      aria-label=\"Skip tour\"\n      data-slot=\"tour-skip\"\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n      {...skipButtonProps}\n    >\n      {children ?? \"Skip\"}\n    </SkipPrimitive>\n  );\n}\n\nexport {\n  TourRoot as Root,\n  TourStep as Step,\n  TourOverlay as Overlay,\n  TourHeader as Header,\n  TourTitle as Title,\n  TourDescription as Description,\n  TourFooter as Footer,\n  TourClose as Close,\n  TourStepCounter as StepCounter,\n  TourPrev as Prev,\n  TourNext as Next,\n  TourSkip as Skip,\n  //\n  TourRoot as Tour,\n  TourStep,\n  TourOverlay,\n  TourHeader,\n  TourTitle,\n  TourDescription,\n  TourFooter,\n  TourClose,\n  TourStepCounter,\n  TourPrev,\n  TourNext,\n  TourSkip,\n  //\n  type TourRootProps as TourProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}