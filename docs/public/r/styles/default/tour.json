{
  "name": "tour",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/tour.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { ChevronLeft, ChevronRight, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"Tour\";\nconst STEP_NAME = \"TourStep\";\nconst CLOSE_NAME = \"TourClose\";\nconst PREV_NAME = \"TourPrev\";\nconst NEXT_NAME = \"TourNext\";\nconst SKIP_NAME = \"TourSkip\";\nconst OVERLAY_NAME = \"TourOverlay\";\n\ntype Direction = \"ltr\" | \"rtl\";\ntype Placement =\n  | \"top\"\n  | \"top-start\"\n  | \"top-end\"\n  | \"bottom\"\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"left\"\n  | \"left-start\"\n  | \"left-end\"\n  | \"right\"\n  | \"right-start\"\n  | \"right-end\";\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\ninterface StepData {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  placement?: Placement;\n  offset?: number;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  required?: boolean;\n}\n\ninterface StoreState {\n  open: boolean;\n  currentStep: number;\n  steps: StepData[];\n  dir: Direction;\n  showBackdrop: boolean;\n  closeOnBackdropClick: boolean;\n  closeOnEscape: boolean;\n  padding: number;\n  borderRadius: number;\n  scrollToElement: boolean;\n  scrollBehavior: ScrollBehavior;\n  scrollOffset: {\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n  };\n  position: { top: number; left: number };\n  maskPath: string;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n  addStep: (stepData: StepData) => number;\n  removeStep: (index: number) => void;\n}\n\nfunction createStore(\n  listenersRef: React.RefObject<Set<() => void>>,\n  stateRef: React.RefObject<StoreState>,\n  onValueChange?: Partial<{\n    [K in keyof StoreState]: (value: StoreState[K], store: Store) => void;\n  }>,\n): Store {\n  const store: Store = {\n    subscribe: (cb) => {\n      if (listenersRef.current) {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current?.delete(cb);\n      }\n      return () => {};\n    },\n    getState: () =>\n      stateRef.current ?? {\n        open: false,\n        currentStep: 0,\n        steps: [],\n        dir: \"ltr\",\n        showBackdrop: true,\n        closeOnBackdropClick: false,\n        closeOnEscape: true,\n        padding: 4,\n        borderRadius: 8,\n        scrollToElement: true,\n        scrollBehavior: \"smooth\",\n        scrollOffset: { top: 100, bottom: 100, left: 0, right: 0 },\n        position: { top: 0, left: 0 },\n        maskPath: \"\",\n      },\n    setState: (key, value) => {\n      const state = stateRef.current;\n      if (!state || Object.is(state[key], value)) return;\n      state[key] = value;\n      onValueChange?.[key]?.(value, store);\n      store.notify();\n    },\n    addStep: (stepData) => {\n      const state = stateRef.current;\n      if (state) {\n        const newSteps = [...state.steps, stepData];\n        state.steps = newSteps;\n        store.notify();\n        return newSteps.length - 1;\n      }\n      return -1;\n    },\n    removeStep: (index) => {\n      const state = stateRef.current;\n      if (state) {\n        state.steps = state.steps.filter((_, i) => i !== index);\n        store.notify();\n      }\n    },\n    notify: () => {\n      if (listenersRef.current) {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      }\n    },\n  };\n\n  return store;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\nfunction getTargetElement(\n  target: string | React.RefObject<HTMLElement> | HTMLElement,\n): HTMLElement | null {\n  if (typeof target === \"string\") {\n    return document.querySelector(target);\n  }\n  if (target && \"current\" in target) {\n    return target.current;\n  }\n  if (target instanceof HTMLElement) {\n    return target;\n  }\n  return null;\n}\n\nfunction getElementRect(element: HTMLElement) {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top + window.scrollY,\n    left: rect.left + window.scrollX,\n    width: rect.width,\n    height: rect.height,\n    bottom: rect.bottom + window.scrollY,\n    right: rect.right + window.scrollX,\n  };\n}\n\nfunction scrollToElement(\n  element: HTMLElement,\n  behavior: ScrollBehavior = \"smooth\",\n  offset = { top: 100, bottom: 100, left: 0, right: 0 },\n) {\n  const rect = element.getBoundingClientRect();\n  const viewportHeight = window.innerHeight;\n  const viewportWidth = window.innerWidth;\n\n  const isInViewport =\n    rect.top >= offset.top &&\n    rect.bottom <= viewportHeight - offset.bottom &&\n    rect.left >= offset.left &&\n    rect.right <= viewportWidth - offset.right;\n\n  if (!isInViewport) {\n    const elementTop = rect.top + window.scrollY;\n    const scrollTop = elementTop - offset.top;\n\n    window.scrollTo({\n      top: Math.max(0, scrollTop),\n      behavior,\n    });\n  }\n}\n\nfunction updatePositionAndMask(store: Store, stepData: StepData) {\n  const targetElement = getTargetElement(stepData.target);\n  if (!targetElement) return;\n\n  const state = store.getState();\n  const rect = getElementRect(targetElement);\n  const placement = stepData.placement ?? \"bottom\";\n  const offset = stepData.offset ?? 8;\n\n  let top = 0;\n  let left = 0;\n\n  switch (placement) {\n    case \"top\":\n      top = rect.top - offset;\n      left = rect.left + rect.width / 2;\n      break;\n    case \"top-start\":\n      top = rect.top - offset;\n      left = rect.left;\n      break;\n    case \"top-end\":\n      top = rect.top - offset;\n      left = rect.right;\n      break;\n    case \"bottom\":\n      top = rect.bottom + offset;\n      left = rect.left + rect.width / 2;\n      break;\n    case \"bottom-start\":\n      top = rect.bottom + offset;\n      left = rect.left;\n      break;\n    case \"bottom-end\":\n      top = rect.bottom + offset;\n      left = rect.right;\n      break;\n    case \"left\":\n      top = rect.top + rect.height / 2;\n      left = rect.left - offset;\n      break;\n    case \"left-start\":\n      top = rect.top;\n      left = rect.left - offset;\n      break;\n    case \"left-end\":\n      top = rect.bottom;\n      left = rect.left - offset;\n      break;\n    case \"right\":\n      top = rect.top + rect.height / 2;\n      left = rect.right + offset;\n      break;\n    case \"right-start\":\n      top = rect.top;\n      left = rect.right + offset;\n      break;\n    case \"right-end\":\n      top = rect.bottom;\n      left = rect.right + offset;\n      break;\n  }\n\n  store.setState(\"position\", { top, left });\n\n  if (state.showBackdrop) {\n    const clientRect = targetElement.getBoundingClientRect();\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    const padding = state.padding;\n\n    const x = Math.max(0, clientRect.left - padding);\n    const y = Math.max(0, clientRect.top - padding);\n    const width = Math.min(viewportWidth - x, clientRect.width + padding * 2);\n    const height = Math.min(\n      viewportHeight - y,\n      clientRect.height + padding * 2,\n    );\n\n    const path = `polygon(0% 0%, 0% 100%, ${x}px 100%, ${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px, ${x}px 100%, 100% 100%, 100% 0%)`;\n    store.setState(\"maskPath\", path);\n  }\n}\n\nfunction getTransform(placement: Placement = \"bottom\") {\n  switch (placement) {\n    case \"top\":\n    case \"top-start\":\n    case \"top-end\":\n      return \"translate(-50%, -100%)\";\n    case \"bottom\":\n    case \"bottom-start\":\n    case \"bottom-end\":\n      return \"translate(-50%, 0)\";\n    case \"left\":\n    case \"left-start\":\n    case \"left-end\":\n      return \"translate(-100%, -50%)\";\n    case \"right\":\n    case \"right-start\":\n    case \"right-end\":\n      return \"translate(0, -50%)\";\n  }\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nconst TourContext = React.createContext<React.ReactElement | undefined>(\n  undefined,\n);\n\nfunction useTourContext(consumerName: string) {\n  const context = React.useContext(TourContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface TourRootProps extends DivProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  currentStep?: number;\n  defaultCurrentStep?: number;\n  onCurrentStepChange?: (step: number) => void;\n  onComplete?: () => void;\n  onSkip?: () => void;\n  dir?: Direction;\n  showBackdrop?: boolean;\n  closeOnBackdropClick?: boolean;\n  closeOnEscape?: boolean;\n  padding?: number;\n  borderRadius?: number;\n  scrollToElement?: boolean;\n  scrollBehavior?: ScrollBehavior;\n  scrollOffset?: {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n  };\n  stepFooter?: React.ReactElement;\n}\n\nfunction TourRoot(props: TourRootProps) {\n  const {\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    currentStep: currentStepProp,\n    defaultCurrentStep = 0,\n    onCurrentStepChange,\n    onComplete,\n    onSkip,\n    dir = \"ltr\",\n    showBackdrop = true,\n    closeOnBackdropClick = false,\n    closeOnEscape = true,\n    padding = 4,\n    borderRadius = 8,\n    scrollToElement: scrollToElementProp = true,\n    scrollBehavior = \"smooth\",\n    scrollOffset = {},\n    stepFooter,\n    asChild,\n    ...rootProps\n  } = props;\n\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const stateRef = useLazyRef<StoreState>(() => ({\n    open: openProp ?? defaultOpen,\n    currentStep: currentStepProp ?? defaultCurrentStep,\n    steps: [],\n    dir,\n    showBackdrop,\n    closeOnBackdropClick,\n    closeOnEscape,\n    padding,\n    borderRadius,\n    scrollToElement: scrollToElementProp,\n    scrollBehavior,\n    scrollOffset: {\n      top: 100,\n      bottom: 100,\n      left: 0,\n      right: 0,\n      ...scrollOffset,\n    },\n    position: { top: 0, left: 0 },\n    maskPath: \"\",\n  }));\n\n  const store = React.useMemo(\n    () =>\n      createStore(listenersRef, stateRef, {\n        open: (value) => {\n          onOpenChange?.(value);\n\n          if (value) {\n            const state = stateRef.current;\n            if (state && state.steps.length > 0) {\n              if (state.currentStep >= state.steps.length) {\n                store.setState(\"currentStep\", 0);\n              }\n\n              const currentStepIndex =\n                state.currentStep >= state.steps.length ? 0 : state.currentStep;\n              const currentStepData = state.steps[currentStepIndex];\n              if (currentStepData) {\n                queueMicrotask(() => {\n                  updatePositionAndMask(store, currentStepData);\n                });\n              }\n            }\n          } else {\n            const state = stateRef.current;\n            if (state && state.currentStep < (state.steps.length || 0) - 1) {\n              onSkip?.();\n            }\n          }\n        },\n        currentStep: (value, store) => {\n          const state = store.getState();\n          const prevStep = state.steps[state.currentStep];\n          const nextStep = state.steps[value];\n\n          prevStep?.onStepLeave?.();\n          nextStep?.onStepEnter?.();\n\n          onCurrentStepChange?.(value);\n\n          if (value >= state.steps.length) {\n            onComplete?.();\n            store.setState(\"open\", false);\n            return;\n          }\n\n          if (nextStep) {\n            updatePositionAndMask(store, nextStep);\n\n            if (state.scrollToElement) {\n              const targetElement = getTargetElement(nextStep.target);\n              if (targetElement) {\n                scrollToElement(\n                  targetElement,\n                  state.scrollBehavior,\n                  state.scrollOffset,\n                );\n              }\n            }\n          }\n        },\n      }),\n    [\n      listenersRef,\n      stateRef,\n      onOpenChange,\n      onCurrentStepChange,\n      onComplete,\n      onSkip,\n    ],\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (openProp !== undefined) {\n      store.setState(\"open\", openProp);\n    }\n  }, [openProp, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (currentStepProp !== undefined) {\n      store.setState(\"currentStep\", currentStepProp);\n    }\n  }, [currentStepProp, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"dir\", dir);\n  }, [dir, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"showBackdrop\", showBackdrop);\n  }, [showBackdrop, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"closeOnBackdropClick\", closeOnBackdropClick);\n  }, [closeOnBackdropClick, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"closeOnEscape\", closeOnEscape);\n  }, [closeOnEscape, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"padding\", padding);\n  }, [padding, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"borderRadius\", borderRadius);\n  }, [borderRadius, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"scrollToElement\", scrollToElementProp);\n  }, [scrollToElementProp, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"scrollBehavior\", scrollBehavior);\n  }, [scrollBehavior, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    store.setState(\"scrollOffset\", {\n      top: 100,\n      bottom: 100,\n      left: 0,\n      right: 0,\n      ...scrollOffset,\n    });\n  }, [scrollOffset, store]);\n\n  React.useEffect(() => {\n    function onKeyDown(event: KeyboardEvent) {\n      const state = store.getState();\n      if (state.open && state.closeOnEscape && event.key === \"Escape\") {\n        event.preventDefault();\n        store.setState(\"open\", false);\n      }\n    }\n\n    document.addEventListener(\"keydown\", onKeyDown);\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\n  }, [store]);\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StoreContext.Provider value={store}>\n      <TourContext.Provider value={stepFooter}>\n        <RootPrimitive data-slot=\"tour\" {...rootProps} />\n      </TourContext.Provider>\n    </StoreContext.Provider>\n  );\n}\n\ninterface TourStepProps extends DivProps {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  placement?: Placement;\n  offset?: number;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  required?: boolean;\n  forceMount?: boolean;\n}\n\nfunction TourStep(props: TourStepProps) {\n  const {\n    target,\n    placement = \"bottom\",\n    offset = 8,\n    required = false,\n    forceMount = false,\n    onStepEnter,\n    onStepLeave,\n    className,\n    children,\n    asChild,\n    ...stepProps\n  } = props;\n\n  const store = useStoreContext(STEP_NAME);\n  const stepIndexRef = React.useRef<number>(-1);\n\n  const hasStepFooter = React.Children.toArray(children).some((child) => {\n    if (!React.isValidElement(child)) return false;\n    return child.type === TourFooter;\n  });\n\n  const stepData: StepData = {\n    target,\n    placement,\n    offset,\n    onStepEnter,\n    onStepLeave,\n    required,\n  };\n\n  useIsomorphicLayoutEffect(() => {\n    const index = store.addStep(stepData);\n    stepIndexRef.current = index;\n\n    const state = store.getState();\n    if (index === 0 && state.open) {\n      queueMicrotask(() => {\n        updatePositionAndMask(store, stepData);\n      });\n    }\n\n    return () => {\n      store.removeStep(stepIndexRef.current);\n    };\n  }, [store, target, placement, offset, required, onStepEnter, onStepLeave]);\n\n  const open = useStore((state) => state.open);\n  const currentStep = useStore((state) => state.currentStep);\n  const steps = useStore((state) => state.steps);\n  const position = useStore((state) => state.position);\n  const stepFooter = useTourContext(STEP_NAME);\n\n  const currentStepData = steps[currentStep];\n  const targetElement = currentStepData\n    ? getTargetElement(currentStepData.target)\n    : null;\n\n  const isCurrentStep = stepIndexRef.current === currentStep;\n\n  React.useEffect(() => {\n    if (!open || !currentStepData || !targetElement || !isCurrentStep) return;\n\n    function updatePosition() {\n      if (currentStepData) {\n        updatePositionAndMask(store, currentStepData);\n      }\n    }\n\n    updatePosition();\n    window.addEventListener(\"resize\", updatePosition);\n    window.addEventListener(\"scroll\", updatePosition);\n\n    return () => {\n      window.removeEventListener(\"resize\", updatePosition);\n      window.removeEventListener(\"scroll\", updatePosition);\n    };\n  }, [open, currentStepData, targetElement, store, isCurrentStep]);\n\n  if (\n    !open ||\n    !currentStepData ||\n    (!targetElement && !forceMount) ||\n    !isCurrentStep\n  ) {\n    return null;\n  }\n\n  const StepPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StepPrimitive\n      data-slot=\"tour-step\"\n      {...stepProps}\n      className={cn(\n        \"fixed z-50 w-80 rounded-lg border bg-popover p-4 text-popover-foreground shadow-md\",\n        className,\n      )}\n      style={{\n        top: position.top,\n        left: position.left,\n        transform: getTransform(currentStepData.placement),\n      }}\n    >\n      {children}\n      {!hasStepFooter && stepFooter && stepFooter}\n    </StepPrimitive>\n  );\n}\n\nfunction TourOverlay(props: DivProps) {\n  const { asChild, className, style, ...backdropProps } = props;\n\n  const store = useStoreContext(OVERLAY_NAME);\n  const open = useStore((state) => state.open);\n  const showBackdrop = useStore((state) => state.showBackdrop);\n  const closeOnBackdropClick = useStore((state) => state.closeOnBackdropClick);\n  const maskPath = useStore((state) => state.maskPath);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      backdropProps.onClick?.(event);\n      if (event.defaultPrevented || !closeOnBackdropClick) return;\n\n      store.setState(\"open\", false);\n    },\n    [closeOnBackdropClick, store, backdropProps.onClick],\n  );\n\n  if (!open || !showBackdrop) return null;\n\n  const OverlayPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <OverlayPrimitive\n      data-slot=\"tour-overlay\"\n      {...backdropProps}\n      className={cn(\"fixed inset-0 z-40 bg-black/50\", className)}\n      style={{\n        ...style,\n        clipPath: maskPath,\n      }}\n      onClick={onClick}\n    />\n  );\n}\n\nfunction TourHeader(props: DivProps) {\n  const { asChild, className, ...headerProps } = props;\n\n  const HeaderPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <HeaderPrimitive\n      data-slot=\"tour-header\"\n      {...headerProps}\n      className={cn(\n        \"flex flex-col gap-1.5 text-center sm:text-left\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TourTitleProps extends React.ComponentProps<\"h2\"> {\n  asChild?: boolean;\n}\n\nfunction TourTitle(props: TourTitleProps) {\n  const { asChild, className, ...titleProps } = props;\n\n  const TitlePrimitive = asChild ? Slot : \"h2\";\n\n  return (\n    <TitlePrimitive\n      data-slot=\"tour-title\"\n      {...titleProps}\n      className={cn(\n        \"font-semibold text-lg leading-none tracking-tight\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TourDescriptionProps extends React.ComponentProps<\"p\"> {\n  asChild?: boolean;\n}\n\nfunction TourDescription(props: TourDescriptionProps) {\n  const { asChild, className, ...descriptionProps } = props;\n\n  const DescriptionPrimitive = asChild ? Slot : \"p\";\n\n  return (\n    <DescriptionPrimitive\n      data-slot=\"tour-description\"\n      {...descriptionProps}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n    />\n  );\n}\n\nfunction TourFooter(props: DivProps) {\n  const { asChild, className, ...footerProps } = props;\n\n  const FooterPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <FooterPrimitive\n      data-slot=\"tour-footer\"\n      {...footerProps}\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className,\n      )}\n    />\n  );\n}\n\nfunction TourClose(props: ButtonProps) {\n  const { asChild, className, ...closeButtonProps } = props;\n\n  const store = useStoreContext(CLOSE_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      closeButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, closeButtonProps.onClick],\n  );\n\n  const ClosePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ClosePrimitive\n      type=\"button\"\n      aria-label=\"Close tour\"\n      className={cn(\n        \"absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\",\n        className,\n      )}\n      onClick={onClick}\n      {...closeButtonProps}\n    >\n      <X className=\"size-4\" />\n    </ClosePrimitive>\n  );\n}\n\ninterface TourStepCounterProps extends DivProps {\n  format?: (current: number, total: number) => string;\n}\n\nfunction TourStepCounter(props: TourStepCounterProps) {\n  const {\n    format = (current, total) => `${current} / ${total}`,\n    asChild,\n    className,\n    children,\n    ...stepCounterProps\n  } = props;\n\n  const currentStep = useStore((state) => state.currentStep);\n  const steps = useStore((state) => state.steps);\n\n  const StepCounterPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StepCounterPrimitive\n      data-slot=\"tour-step-counter\"\n      {...stepCounterProps}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n    >\n      {children ?? format(currentStep + 1, steps.length)}\n    </StepCounterPrimitive>\n  );\n}\n\nfunction TourNavigation(props: DivProps) {\n  const { asChild, className, ...navigationProps } = props;\n  const NavigationPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <NavigationPrimitive\n      data-slot=\"tour-navigation\"\n      {...navigationProps}\n      className={cn(\"flex items-center justify-between\", className)}\n    />\n  );\n}\n\nfunction TourPrev(props: ButtonProps) {\n  const { asChild, className, children, ...prevButtonProps } = props;\n\n  const store = useStoreContext(PREV_NAME);\n  const currentStep = useStore((state) => state.currentStep);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      prevButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      if (currentStep > 0) {\n        store.setState(\"currentStep\", currentStep - 1);\n      }\n    },\n    [currentStep, store, prevButtonProps.onClick],\n  );\n\n  const isDisabled = currentStep === 0;\n\n  const PrevPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <PrevPrimitive\n      type=\"button\"\n      aria-label=\"Previous step\"\n      data-slot=\"tour-prev\"\n      {...prevButtonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n      disabled={isDisabled}\n    >\n      {children ?? (\n        <>\n          <ChevronLeft className=\"size-4\" />\n          Previous\n        </>\n      )}\n    </PrevPrimitive>\n  );\n}\n\nfunction TourNext(props: ButtonProps) {\n  const { asChild, className, children, ...nextButtonProps } = props;\n  const store = useStoreContext(NEXT_NAME);\n  const currentStep = useStore((state) => state.currentStep);\n  const steps = useStore((state) => state.steps);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      nextButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"currentStep\", currentStep + 1);\n    },\n    [currentStep, store, nextButtonProps.onClick],\n  );\n\n  const isLastStep = currentStep === steps.length - 1;\n\n  const NextPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <NextPrimitive\n      type=\"button\"\n      aria-label=\"Next step\"\n      data-slot=\"tour-next\"\n      {...nextButtonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md bg-primary px-3 font-medium text-primary-foreground text-sm ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n    >\n      {children ?? (\n        <>\n          {isLastStep ? \"Finish\" : \"Next\"}\n          {!isLastStep && <ChevronRight className=\"size-4\" />}\n        </>\n      )}\n    </NextPrimitive>\n  );\n}\n\nfunction TourSkip(props: ButtonProps) {\n  const { asChild, className, children, ...skipButtonProps } = props;\n\n  const store = useStoreContext(SKIP_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      skipButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, skipButtonProps.onClick],\n  );\n\n  const SkipPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <SkipPrimitive\n      type=\"button\"\n      aria-label=\"Skip tour\"\n      data-slot=\"tour-skip\"\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n      {...skipButtonProps}\n    >\n      {children ?? \"Skip\"}\n    </SkipPrimitive>\n  );\n}\n\nexport {\n  TourRoot as Root,\n  TourStep as Step,\n  TourOverlay as Overlay,\n  TourHeader as Header,\n  TourTitle as Title,\n  TourDescription as Description,\n  TourFooter as Footer,\n  TourClose as Close,\n  TourStepCounter as StepCounter,\n  TourNavigation as Navigation,\n  TourPrev as Prev,\n  TourNext as Next,\n  TourSkip as Skip,\n  //\n  TourRoot as Tour,\n  TourStep,\n  TourOverlay,\n  TourHeader,\n  TourTitle,\n  TourDescription,\n  TourFooter,\n  TourClose,\n  TourStepCounter,\n  TourNavigation,\n  TourPrev,\n  TourNext,\n  TourSkip,\n  //\n  type TourRootProps as TourProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}