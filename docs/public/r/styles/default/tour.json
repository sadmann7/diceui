{
  "name": "tour",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/tour.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { ChevronLeft, ChevronRight, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"Tour\";\nconst STEP_NAME = \"TourStep\";\nconst CONTENT_NAME = \"TourContent\";\nconst HEADER_NAME = \"TourHeader\";\nconst TITLE_NAME = \"TourTitle\";\nconst DESCRIPTION_NAME = \"TourDescription\";\nconst FOOTER_NAME = \"TourFooter\";\nconst CLOSE_BUTTON_NAME = \"TourCloseButton\";\nconst STEP_COUNTER_NAME = \"TourStepCounter\";\nconst NAVIGATION_NAME = \"TourNavigation\";\nconst PREV_BUTTON_NAME = \"TourPrevButton\";\nconst NEXT_BUTTON_NAME = \"TourNextButton\";\nconst SKIP_BUTTON_NAME = \"TourSkipButton\";\nconst BACKDROP_NAME = \"TourBackdrop\";\n\ntype Direction = \"ltr\" | \"rtl\";\ntype Placement =\n  | \"top\"\n  | \"top-start\"\n  | \"top-end\"\n  | \"bottom\"\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"left\"\n  | \"left-start\"\n  | \"left-end\"\n  | \"right\"\n  | \"right-start\"\n  | \"right-end\";\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\ninterface StepData {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  placement?: Placement;\n  offset?: number;\n  skippable?: boolean;\n  showOnTargetNotFound?: boolean;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  element?: React.ReactElement;\n}\n\ninterface StoreState {\n  open: boolean;\n  currentStep: number;\n  steps: StepData[];\n  dir: Direction;\n  showBackdrop: boolean;\n  closeOnBackdropClick: boolean;\n  closeOnEscape: boolean;\n  padding: number;\n  borderRadius: number;\n  scrollToElement: boolean;\n  scrollBehavior: ScrollBehavior;\n  scrollOffset: {\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n  };\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nfunction createStore(\n  listenersRef: React.RefObject<Set<() => void>>,\n  stateRef: React.RefObject<StoreState>,\n  onValueChange?: Partial<{\n    [K in keyof StoreState]: (value: StoreState[K], store: Store) => void;\n  }>,\n): Store {\n  const store: Store = {\n    subscribe: (cb) => {\n      listenersRef.current?.add(cb);\n      return () => listenersRef.current?.delete(cb);\n    },\n    getState: () => stateRef.current as StoreState,\n    setState: (key, value) => {\n      const currentState = stateRef.current as StoreState;\n      if (Object.is(currentState[key], value)) return;\n      currentState[key] = value;\n      onValueChange?.[key]?.(value, store);\n      store.notify();\n    },\n    notify: () => {\n      if (listenersRef.current) {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      }\n    },\n  };\n\n  return store;\n}\n\nfunction useStoreSelector<T>(\n  store: Store,\n  selector: (state: StoreState) => T,\n): T {\n  const selectorRef = React.useRef(selector);\n  const snapshotRef = React.useRef<T | undefined>(undefined);\n  const hasSnapshotRef = React.useRef(false);\n\n  let snapshot: T;\n  if (hasSnapshotRef.current && Object.is(selector, selectorRef.current)) {\n    snapshot = snapshotRef.current as T;\n  } else {\n    snapshot = selector(store.getState());\n    selectorRef.current = selector;\n    snapshotRef.current = snapshot;\n    hasSnapshotRef.current = true;\n  }\n\n  const getSnapshot = React.useCallback(() => {\n    if (Object.is(selector, selectorRef.current)) {\n      return snapshotRef.current as T;\n    }\n    const newSnapshot = selector(store.getState());\n    selectorRef.current = selector;\n    snapshotRef.current = newSnapshot;\n    return newSnapshot;\n  }, [selector, store]);\n\n  const subscribe = React.useCallback(\n    (callback: () => void) => store.subscribe(callback),\n    [store],\n  );\n\n  return React.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nfunction getTargetElement(\n  target: string | React.RefObject<HTMLElement> | HTMLElement,\n): HTMLElement | null {\n  if (typeof target === \"string\") {\n    return document.querySelector(target);\n  }\n  if (target && \"current\" in target) {\n    return target.current;\n  }\n  if (target instanceof HTMLElement) {\n    return target;\n  }\n  return null;\n}\n\nfunction getElementRect(element: HTMLElement) {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top + window.scrollY,\n    left: rect.left + window.scrollX,\n    width: rect.width,\n    height: rect.height,\n    bottom: rect.bottom + window.scrollY,\n    right: rect.right + window.scrollX,\n  };\n}\n\nfunction scrollToElement(\n  element: HTMLElement,\n  behavior: ScrollBehavior = \"smooth\",\n  offset = { top: 100, bottom: 100, left: 0, right: 0 },\n) {\n  const rect = element.getBoundingClientRect();\n  const viewportHeight = window.innerHeight;\n  const viewportWidth = window.innerWidth;\n\n  const isInViewport =\n    rect.top >= offset.top &&\n    rect.bottom <= viewportHeight - offset.bottom &&\n    rect.left >= offset.left &&\n    rect.right <= viewportWidth - offset.right;\n\n  if (!isInViewport) {\n    const elementTop = rect.top + window.scrollY;\n    const scrollTop = elementTop - offset.top;\n\n    window.scrollTo({\n      top: Math.max(0, scrollTop),\n      behavior,\n    });\n  }\n}\n\nconst TourContext = React.createContext<Store | null>(null);\n\nfunction useTourContext(consumerName: string) {\n  const context = React.useContext(TourContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nconst StepContext = React.createContext<{\n  stepIndex: number;\n  stepData: StepData;\n} | null>(null);\n\ninterface TourRootProps extends DivProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  currentStep?: number;\n  defaultCurrentStep?: number;\n  onCurrentStepChange?: (step: number) => void;\n  onComplete?: () => void;\n  onSkip?: () => void;\n  dir?: Direction;\n  showBackdrop?: boolean;\n  closeOnBackdropClick?: boolean;\n  closeOnEscape?: boolean;\n  padding?: number;\n  borderRadius?: number;\n  scrollToElement?: boolean;\n  scrollBehavior?: ScrollBehavior;\n  scrollOffset?: {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n  };\n}\n\nfunction TourRoot(props: TourRootProps) {\n  const {\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    currentStep: currentStepProp,\n    defaultCurrentStep = 0,\n    onCurrentStepChange,\n    onComplete,\n    onSkip,\n    dir = \"ltr\",\n    showBackdrop = true,\n    closeOnBackdropClick = false,\n    closeOnEscape = true,\n    padding = 4,\n    borderRadius = 8,\n    scrollToElement: scrollToElementProp = true,\n    scrollBehavior = \"smooth\",\n    scrollOffset = {},\n    asChild,\n    children,\n    ref,\n    ...rootProps\n  } = props;\n  const [openState, setOpenState] = React.useState(defaultOpen);\n  const [currentStepState, setCurrentStepState] =\n    React.useState(defaultCurrentStep);\n\n  const open = openProp ?? openState;\n  const currentStep = currentStepProp ?? currentStepState;\n\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const stateRef = useLazyRef(\n    (): StoreState => ({\n      open,\n      currentStep,\n      steps: [],\n      dir,\n      showBackdrop,\n      closeOnBackdropClick,\n      closeOnEscape,\n      padding,\n      borderRadius,\n      scrollToElement: scrollToElementProp,\n      scrollBehavior,\n      scrollOffset: {\n        top: 100,\n        bottom: 100,\n        left: 0,\n        right: 0,\n        ...scrollOffset,\n      },\n    }),\n  );\n\n  const store = useLazyRef(() =>\n    createStore(listenersRef, stateRef, {\n      open: (value) => {\n        if (openProp === undefined) {\n          setOpenState(value);\n        }\n        onOpenChange?.(value);\n\n        // If closing the tour, check if it was skipped\n        if (!value && currentStep < (stateRef.current?.steps.length || 0) - 1) {\n          onSkip?.();\n        }\n      },\n      currentStep: (value, store) => {\n        const state = store.getState();\n        const prevStep = state.steps[currentStep];\n        const nextStep = state.steps[value];\n\n        prevStep?.onStepLeave?.();\n        nextStep?.onStepEnter?.();\n\n        if (currentStepProp === undefined) {\n          setCurrentStepState(value);\n        }\n        onCurrentStepChange?.(value);\n\n        // Handle completion\n        if (value >= state.steps.length) {\n          onComplete?.();\n          store.setState(\"open\", false);\n          return;\n        }\n\n        // Scroll to target element\n        if (state.scrollToElement && nextStep) {\n          const targetElement = getTargetElement(nextStep.target);\n          if (targetElement) {\n            scrollToElement(\n              targetElement,\n              state.scrollBehavior,\n              state.scrollOffset,\n            );\n          }\n        }\n      },\n    }),\n  );\n\n  // Update store state when props change\n  React.useEffect(() => {\n    store.current.setState(\"open\", open);\n  }, [open, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"currentStep\", currentStep);\n  }, [currentStep, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"dir\", dir);\n  }, [dir, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"showBackdrop\", showBackdrop);\n  }, [showBackdrop, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"closeOnBackdropClick\", closeOnBackdropClick);\n  }, [closeOnBackdropClick, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"closeOnEscape\", closeOnEscape);\n  }, [closeOnEscape, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"padding\", padding);\n  }, [padding, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"borderRadius\", borderRadius);\n  }, [borderRadius, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"scrollToElement\", scrollToElementProp);\n  }, [scrollToElementProp, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"scrollBehavior\", scrollBehavior);\n  }, [scrollBehavior, store]);\n\n  React.useEffect(() => {\n    store.current.setState(\"scrollOffset\", {\n      top: 100,\n      bottom: 100,\n      left: 0,\n      right: 0,\n      ...scrollOffset,\n    });\n  }, [scrollOffset, store]);\n\n  // Handle escape key\n  React.useEffect(() => {\n    if (!open || !closeOnEscape) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === \"Escape\") {\n        event.preventDefault();\n        store.current.setState(\"open\", false);\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [open, closeOnEscape, store]);\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <TourContext.Provider value={store.current}>\n      <Comp ref={ref} {...rootProps}>\n        {children}\n      </Comp>\n    </TourContext.Provider>\n  );\n}\nTourRoot.displayName = ROOT_NAME;\n\ninterface TourStepProps extends DivProps {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  placement?: Placement;\n  offset?: number;\n  skippable?: boolean;\n  showOnTargetNotFound?: boolean;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n}\n\nfunction TourStep(props: TourStepProps) {\n  const {\n    target,\n    placement = \"bottom\",\n    offset = 8,\n    skippable = true,\n    showOnTargetNotFound = false,\n    onStepEnter,\n    onStepLeave,\n    asChild,\n    children,\n    ref,\n    ...stepProps\n  } = props;\n  const store = useTourContext(STEP_NAME);\n  const stepIndex = React.useRef<number>(-1);\n\n  // Register step with store\n  React.useEffect(() => {\n    const stepData: StepData = {\n      target,\n      placement,\n      offset,\n      skippable,\n      showOnTargetNotFound,\n      onStepEnter,\n      onStepLeave,\n    };\n\n    const state = store.getState();\n    const newSteps = [...state.steps, stepData];\n    stepIndex.current = newSteps.length - 1;\n    store.setState(\"steps\", newSteps);\n\n    return () => {\n      const currentState = store.getState();\n      const filteredSteps = currentState.steps.filter(\n        (_, index) => index !== stepIndex.current,\n      );\n      store.setState(\"steps\", filteredSteps);\n    };\n  }, [\n    target,\n    placement,\n    offset,\n    skippable,\n    showOnTargetNotFound,\n    onStepEnter,\n    onStepLeave,\n    store,\n  ]);\n\n  const stepData: StepData = {\n    target,\n    placement,\n    offset,\n    skippable,\n    showOnTargetNotFound,\n    onStepEnter,\n    onStepLeave,\n  };\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <StepContext.Provider value={{ stepIndex: stepIndex.current, stepData }}>\n      <Comp ref={ref} {...stepProps}>\n        {children}\n      </Comp>\n    </StepContext.Provider>\n  );\n}\nTourStep.displayName = STEP_NAME;\n\ninterface TourContentProps extends DivProps {}\n\nfunction TourContent(props: TourContentProps) {\n  const { asChild, className, children, ref, ...contentProps } = props;\n  const store = useTourContext(CONTENT_NAME);\n  const { open, currentStep, steps } = useStoreSelector(store, (state) => ({\n    open: state.open,\n    currentStep: state.currentStep,\n    steps: state.steps,\n  }));\n\n  const currentStepData = steps[currentStep];\n  const targetElement = currentStepData\n    ? getTargetElement(currentStepData.target)\n    : null;\n\n  const [position, setPosition] = React.useState({ top: 0, left: 0 });\n\n  React.useEffect(() => {\n    if (!open || !currentStepData || !targetElement) return;\n\n    const updatePosition = () => {\n      const rect = getElementRect(targetElement);\n      const placement = currentStepData.placement || \"bottom\";\n      const offset = currentStepData.offset || 8;\n\n      let top = 0;\n      let left = 0;\n\n      switch (placement) {\n        case \"top\":\n          top = rect.top - offset;\n          left = rect.left + rect.width / 2;\n          break;\n        case \"top-start\":\n          top = rect.top - offset;\n          left = rect.left;\n          break;\n        case \"top-end\":\n          top = rect.top - offset;\n          left = rect.right;\n          break;\n        case \"bottom\":\n          top = rect.bottom + offset;\n          left = rect.left + rect.width / 2;\n          break;\n        case \"bottom-start\":\n          top = rect.bottom + offset;\n          left = rect.left;\n          break;\n        case \"bottom-end\":\n          top = rect.bottom + offset;\n          left = rect.right;\n          break;\n        case \"left\":\n          top = rect.top + rect.height / 2;\n          left = rect.left - offset;\n          break;\n        case \"left-start\":\n          top = rect.top;\n          left = rect.left - offset;\n          break;\n        case \"left-end\":\n          top = rect.bottom;\n          left = rect.left - offset;\n          break;\n        case \"right\":\n          top = rect.top + rect.height / 2;\n          left = rect.right + offset;\n          break;\n        case \"right-start\":\n          top = rect.top;\n          left = rect.right + offset;\n          break;\n        case \"right-end\":\n          top = rect.bottom;\n          left = rect.right + offset;\n          break;\n      }\n\n      setPosition({ top, left });\n    };\n\n    updatePosition();\n    window.addEventListener(\"resize\", updatePosition);\n    window.addEventListener(\"scroll\", updatePosition);\n\n    return () => {\n      window.removeEventListener(\"resize\", updatePosition);\n      window.removeEventListener(\"scroll\", updatePosition);\n    };\n  }, [open, currentStepData, targetElement]);\n\n  if (\n    !open ||\n    !currentStepData ||\n    (!targetElement && !currentStepData.showOnTargetNotFound)\n  ) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\n        \"fixed z-50 w-80 rounded-lg border bg-popover p-4 text-popover-foreground shadow-md\",\n        className,\n      )}\n      style={{\n        top: position.top,\n        left: position.left,\n        transform: \"translate(-50%, -100%)\",\n      }}\n      {...contentProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourContent.displayName = CONTENT_NAME;\n\ninterface TourBackdropProps extends DivProps {}\n\nfunction TourBackdrop(props: TourBackdropProps) {\n  const { asChild, className, children, ref, ...backdropProps } = props;\n  const store = useTourContext(BACKDROP_NAME);\n  const {\n    open,\n    showBackdrop,\n    closeOnBackdropClick,\n    currentStep,\n    steps,\n    padding,\n  } = useStoreSelector(store, (state) => ({\n    open: state.open,\n    showBackdrop: state.showBackdrop,\n    closeOnBackdropClick: state.closeOnBackdropClick,\n    currentStep: state.currentStep,\n    steps: state.steps,\n    padding: state.padding,\n  }));\n\n  const currentStepData = steps[currentStep];\n  const targetElement = currentStepData\n    ? getTargetElement(currentStepData.target)\n    : null;\n\n  const [maskPath, setMaskPath] = React.useState(\"\");\n\n  React.useEffect(() => {\n    if (!open || !showBackdrop || !targetElement) {\n      setMaskPath(\"\");\n      return;\n    }\n\n    const updateMask = () => {\n      const rect = targetElement.getBoundingClientRect();\n      const viewportWidth = window.innerWidth;\n      const viewportHeight = window.innerHeight;\n\n      const x = Math.max(0, rect.left - padding);\n      const y = Math.max(0, rect.top - padding);\n      const width = Math.min(viewportWidth - x, rect.width + padding * 2);\n      const height = Math.min(viewportHeight - y, rect.height + padding * 2);\n\n      const path = `polygon(0% 0%, 0% 100%, ${x}px 100%, ${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px, ${x}px 100%, 100% 100%, 100% 0%)`;\n      setMaskPath(path);\n    };\n\n    updateMask();\n    window.addEventListener(\"resize\", updateMask);\n    window.addEventListener(\"scroll\", updateMask);\n\n    return () => {\n      window.removeEventListener(\"resize\", updateMask);\n      window.removeEventListener(\"scroll\", updateMask);\n    };\n  }, [open, showBackdrop, targetElement, padding]);\n\n  const handleBackdropClick = () => {\n    if (closeOnBackdropClick) {\n      store.setState(\"open\", false);\n    }\n  };\n\n  if (!open || !showBackdrop) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"fixed inset-0 z-40 bg-black/50\", className)}\n      style={{\n        clipPath: maskPath,\n      }}\n      onClick={handleBackdropClick}\n      {...backdropProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourBackdrop.displayName = BACKDROP_NAME;\n\ninterface TourHeaderProps extends DivProps {}\n\nfunction TourHeader(props: TourHeaderProps) {\n  const { asChild, className, children, ref, ...headerProps } = props;\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\n        \"flex flex-col space-y-1.5 text-center sm:text-left\",\n        className,\n      )}\n      {...headerProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourHeader.displayName = HEADER_NAME;\n\ninterface TourTitleProps extends React.ComponentProps<\"h2\"> {\n  asChild?: boolean;\n}\n\nfunction TourTitle(props: TourTitleProps) {\n  const { asChild, className, children, ref, ...titleProps } = props;\n  const Comp = asChild ? Slot : \"h2\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\n        \"font-semibold text-lg leading-none tracking-tight\",\n        className,\n      )}\n      {...titleProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourTitle.displayName = TITLE_NAME;\n\ninterface TourDescriptionProps extends React.ComponentProps<\"p\"> {\n  asChild?: boolean;\n}\n\nfunction TourDescription(props: TourDescriptionProps) {\n  const { asChild, className, children, ref, ...descriptionProps } = props;\n  const Comp = asChild ? Slot : \"p\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...descriptionProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourDescription.displayName = DESCRIPTION_NAME;\n\ninterface TourFooterProps extends DivProps {}\n\nfunction TourFooter(props: TourFooterProps) {\n  const { asChild, className, children, ref, ...footerProps } = props;\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\n        \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n        className,\n      )}\n      {...footerProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourFooter.displayName = FOOTER_NAME;\n\ninterface TourCloseButtonProps extends ButtonProps {}\n\nfunction TourCloseButton(props: TourCloseButtonProps) {\n  const { asChild, className, children, ref, ...closeButtonProps } = props;\n  const store = useTourContext(CLOSE_BUTTON_NAME);\n\n  const handleClick = () => {\n    store.setState(\"open\", false);\n  };\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      className={cn(\n        \"absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\",\n        className,\n      )}\n      aria-label=\"Close tour\"\n      onClick={handleClick}\n      {...closeButtonProps}\n    >\n      {children || <X className=\"h-4 w-4\" />}\n    </Comp>\n  );\n}\nTourCloseButton.displayName = CLOSE_BUTTON_NAME;\n\ninterface TourStepCounterProps extends DivProps {\n  format?: (current: number, total: number) => string;\n}\n\nfunction TourStepCounter(props: TourStepCounterProps) {\n  const {\n    format = (current, total) => `${current} / ${total}`,\n    asChild,\n    className,\n    children,\n    ref,\n    ...stepCounterProps\n  } = props;\n  const store = useTourContext(STEP_COUNTER_NAME);\n  const { currentStep, steps } = useStoreSelector(store, (state) => ({\n    currentStep: state.currentStep,\n    steps: state.steps,\n  }));\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...stepCounterProps}\n    >\n      {children || format(currentStep + 1, steps.length)}\n    </Comp>\n  );\n}\nTourStepCounter.displayName = STEP_COUNTER_NAME;\n\ninterface TourNavigationProps extends DivProps {}\n\nfunction TourNavigation(props: TourNavigationProps) {\n  const { asChild, className, children, ref, ...navigationProps } = props;\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"flex items-center justify-between\", className)}\n      {...navigationProps}\n    >\n      {children}\n    </Comp>\n  );\n}\nTourNavigation.displayName = NAVIGATION_NAME;\n\ninterface TourPrevButtonProps extends ButtonProps {}\n\nfunction TourPrevButton(props: TourPrevButtonProps) {\n  const { asChild, className, children, ref, ...prevButtonProps } = props;\n  const store = useTourContext(PREV_BUTTON_NAME);\n  const { currentStep } = useStoreSelector(store, (state) => ({\n    currentStep: state.currentStep,\n  }));\n\n  const handleClick = () => {\n    if (currentStep > 0) {\n      store.setState(\"currentStep\", currentStep - 1);\n    }\n  };\n\n  const isDisabled = currentStep === 0;\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      className={cn(\n        \"inline-flex h-9 items-center justify-center rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      aria-label=\"Previous step\"\n      disabled={isDisabled}\n      onClick={handleClick}\n      {...prevButtonProps}\n    >\n      {children || (\n        <>\n          <ChevronLeft className=\"mr-2 h-4 w-4\" />\n          Previous\n        </>\n      )}\n    </Comp>\n  );\n}\nTourPrevButton.displayName = PREV_BUTTON_NAME;\n\ninterface TourNextButtonProps extends ButtonProps {}\n\nfunction TourNextButton(props: TourNextButtonProps) {\n  const { asChild, className, children, ref, ...nextButtonProps } = props;\n  const store = useTourContext(NEXT_BUTTON_NAME);\n  const { currentStep, steps } = useStoreSelector(store, (state) => ({\n    currentStep: state.currentStep,\n    steps: state.steps,\n  }));\n\n  const handleClick = () => {\n    store.setState(\"currentStep\", currentStep + 1);\n  };\n\n  const isLastStep = currentStep === steps.length - 1;\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      className={cn(\n        \"inline-flex h-9 items-center justify-center rounded-md bg-primary px-3 font-medium text-primary-foreground text-sm ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      aria-label=\"Next step\"\n      onClick={handleClick}\n      {...nextButtonProps}\n    >\n      {children || (\n        <>\n          {isLastStep ? \"Finish\" : \"Next\"}\n          {!isLastStep && <ChevronRight className=\"ml-2 h-4 w-4\" />}\n        </>\n      )}\n    </Comp>\n  );\n}\nTourNextButton.displayName = NEXT_BUTTON_NAME;\n\ninterface TourSkipButtonProps extends ButtonProps {}\n\nfunction TourSkipButton(props: TourSkipButtonProps) {\n  const { asChild, className, children, ref, ...skipButtonProps } = props;\n  const store = useTourContext(SKIP_BUTTON_NAME);\n\n  const handleClick = () => {\n    store.setState(\"open\", false);\n  };\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      className={cn(\n        \"inline-flex h-9 items-center justify-center rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      aria-label=\"Skip tour\"\n      onClick={handleClick}\n      {...skipButtonProps}\n    >\n      {children || \"Skip\"}\n    </Comp>\n  );\n}\nTourSkipButton.displayName = SKIP_BUTTON_NAME;\n\nconst Root = TourRoot;\nconst Step = TourStep;\nconst Content = TourContent;\nconst Backdrop = TourBackdrop;\nconst Header = TourHeader;\nconst Title = TourTitle;\nconst Description = TourDescription;\nconst Footer = TourFooter;\nconst CloseButton = TourCloseButton;\nconst StepCounter = TourStepCounter;\nconst Navigation = TourNavigation;\nconst PrevButton = TourPrevButton;\nconst NextButton = TourNextButton;\nconst SkipButton = TourSkipButton;\n\nexport {\n  Root,\n  Step,\n  Content,\n  Backdrop,\n  Header,\n  Title,\n  Description,\n  Footer,\n  CloseButton,\n  StepCounter,\n  Navigation,\n  PrevButton,\n  NextButton,\n  SkipButton,\n  //\n  TourRoot,\n  TourStep,\n  TourContent,\n  TourBackdrop,\n  TourHeader,\n  TourTitle,\n  TourDescription,\n  TourFooter,\n  TourCloseButton,\n  TourStepCounter,\n  TourNavigation,\n  TourPrevButton,\n  TourNextButton,\n  TourSkipButton,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}