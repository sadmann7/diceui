{
  "name": "tour",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/tour.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  autoUpdate,\r\n  flip,\r\n  arrow as floatingUIarrow,\r\n  hide,\r\n  limitShift,\r\n  type Middleware,\r\n  offset,\r\n  type Placement,\r\n  shift,\r\n  useFloating,\r\n} from \"@floating-ui/react-dom\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { ChevronLeft, ChevronRight, X } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"Tour\";\r\nconst PORTAL_NAME = \"TourPortal\";\r\nconst OVERLAY_NAME = \"TourOverlay\";\r\nconst STEP_NAME = \"TourStep\";\r\nconst CLOSE_NAME = \"TourClose\";\r\nconst PREV_NAME = \"TourPrev\";\r\nconst NEXT_NAME = \"TourNext\";\r\nconst SKIP_NAME = \"TourSkip\";\r\nconst HEADER_NAME = \"TourHeader\";\r\nconst TITLE_NAME = \"TourTitle\";\r\nconst DESCRIPTION_NAME = \"TourDescription\";\r\nconst FOOTER_NAME = \"TourFooter\";\r\nconst ARROW_NAME = \"TourArrow\";\r\n\r\nconst SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"] as const;\r\nconst ALIGN_OPTIONS = [\"start\", \"center\", \"end\"] as const;\r\n\r\ntype Side = (typeof SIDE_OPTIONS)[number];\r\ntype Align = (typeof ALIGN_OPTIONS)[number];\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\ninterface ButtonProps extends React.ComponentProps<typeof Button> {}\r\n\r\nconst OPPOSITE_SIDE: Record<Side, Side> = {\r\n  top: \"bottom\",\r\n  right: \"left\",\r\n  bottom: \"top\",\r\n  left: \"right\",\r\n};\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\r\n\r\nfunction useAsRef<T>(props: T) {\r\n  const ref = React.useRef<T>(props);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = props;\r\n  });\r\n\r\n  return ref;\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\r\n\r\nfunction useDirection(dirProp?: Direction): Direction {\r\n  const contextDir = React.useContext(DirectionContext);\r\n  return dirProp ?? contextDir ?? \"ltr\";\r\n}\r\n\r\ninterface ScrollOffset {\r\n  top?: number;\r\n  bottom?: number;\r\n  left?: number;\r\n  right?: number;\r\n}\r\n\r\ntype Boundary = Element | null;\r\n\r\ninterface StepData {\r\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\r\n  side?: Side;\r\n  sideOffset?: number;\r\n  align?: Align;\r\n  alignOffset?: number;\r\n  collisionBoundary?: Boundary | Boundary[];\r\n  collisionPadding?: number | Partial<Record<Side, number>>;\r\n  arrowPadding?: number;\r\n  sticky?: \"partial\" | \"always\";\r\n  hideWhenDetached?: boolean;\r\n  avoidCollisions?: boolean;\r\n  onStepEnter?: () => void;\r\n  onStepLeave?: () => void;\r\n  required?: boolean;\r\n}\r\n\r\ninterface StoreState {\r\n  open: boolean;\r\n  value: number;\r\n  steps: StepData[];\r\n  maskPath: string;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(\r\n    key: K,\r\n    value: StoreState[K],\r\n    opts?: unknown,\r\n  ) => void;\r\n  notify: () => void;\r\n  addStep: (stepData: StepData) => { id: string; index: number };\r\n  removeStep: (id: string) => void;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\nfunction getTargetElement(\r\n  target: string | React.RefObject<HTMLElement> | HTMLElement,\r\n): HTMLElement | null {\r\n  if (typeof target === \"string\") {\r\n    return document.querySelector(target);\r\n  }\r\n  if (target && \"current\" in target) {\r\n    return target.current;\r\n  }\r\n  if (target instanceof HTMLElement) {\r\n    return target;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction onScrollToElement(\r\n  element: HTMLElement,\r\n  scrollBehavior: ScrollBehavior = \"smooth\",\r\n  scrollOffset?: ScrollOffset,\r\n) {\r\n  const offset = {\r\n    top: 100,\r\n    bottom: 100,\r\n    left: 0,\r\n    right: 0,\r\n    ...scrollOffset,\r\n  };\r\n  const rect = element.getBoundingClientRect();\r\n  const viewportHeight = window.innerHeight;\r\n  const viewportWidth = window.innerWidth;\r\n\r\n  const isInViewport =\r\n    rect.top >= offset.top &&\r\n    rect.bottom <= viewportHeight - offset.bottom &&\r\n    rect.left >= offset.left &&\r\n    rect.right <= viewportWidth - offset.right;\r\n\r\n  if (!isInViewport) {\r\n    const elementTop = rect.top + window.scrollY;\r\n    const scrollTop = elementTop - offset.top;\r\n\r\n    window.scrollTo({\r\n      top: Math.max(0, scrollTop),\r\n      behavior: scrollBehavior,\r\n    });\r\n  }\r\n}\r\n\r\nfunction getSideAndAlignFromPlacement(placement: Placement): [Side, Align] {\r\n  const [side, align = \"center\"] = placement.split(\"-\") as [Side, Align?];\r\n  return [side, align];\r\n}\r\n\r\nfunction getPlacement(side: Side, align: Align): Placement {\r\n  if (align === \"center\") {\r\n    return side as Placement;\r\n  }\r\n  return `${side}-${align}` as Placement;\r\n}\r\n\r\nfunction updateMask(\r\n  store: Store,\r\n  targetElement: HTMLElement,\r\n  padding: number = 4,\r\n) {\r\n  const clientRect = targetElement.getBoundingClientRect();\r\n  const viewportWidth = window.innerWidth;\r\n  const viewportHeight = window.innerHeight;\r\n\r\n  const x = Math.max(0, clientRect.left - padding);\r\n  const y = Math.max(0, clientRect.top - padding);\r\n  const width = Math.min(viewportWidth - x, clientRect.width + padding * 2);\r\n  const height = Math.min(viewportHeight - y, clientRect.height + padding * 2);\r\n\r\n  const path = `polygon(0% 0%, 0% 100%, ${x}px 100%, ${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px, ${x}px 100%, 100% 100%, 100% 0%)`;\r\n  store.setState(\"maskPath\", path);\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface TourContextValue {\r\n  dir: Direction;\r\n  dismissible: boolean;\r\n  modal: boolean;\r\n  stepFooter?: React.ReactElement;\r\n}\r\n\r\nconst TourContext = React.createContext<TourContextValue | null>(null);\r\n\r\nfunction useTourContext(consumerName: string) {\r\n  const context = React.useContext(TourContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface StepContextValue {\r\n  arrowX?: number;\r\n  arrowY?: number;\r\n  placedSide: Side;\r\n  placedAlign: Align;\r\n  shouldHideArrow: boolean;\r\n  onArrowChange: (arrow: HTMLElement | null) => void;\r\n  onFooterChange: (footer: HTMLElement | null) => void;\r\n}\r\n\r\nconst StepContext = React.createContext<StepContextValue | null>(null);\r\n\r\nfunction useStepContext(consumerName: string) {\r\n  const context = React.useContext(StepContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${STEP_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nconst DefaultFooterContext = React.createContext(false);\r\n\r\ninterface PortalContextValue {\r\n  portal: HTMLElement | null;\r\n  onPortalChange: (node: HTMLElement | null) => void;\r\n}\r\n\r\nconst PortalContext = React.createContext<PortalContextValue | null>(null);\r\n\r\nfunction usePortalContext(consumerName: string) {\r\n  const context = React.useContext(PortalContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useScrollLock(enabled: boolean) {\r\n  React.useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const originalStyle = window.getComputedStyle(document.body).overflow;\r\n    const scrollbarWidth =\r\n      window.innerWidth - document.documentElement.clientWidth;\r\n\r\n    document.body.style.overflow = \"hidden\";\r\n    if (scrollbarWidth > 0) {\r\n      document.body.style.paddingRight = `${scrollbarWidth}px`;\r\n    }\r\n\r\n    return () => {\r\n      document.body.style.overflow = originalStyle;\r\n      document.body.style.paddingRight = \"\";\r\n    };\r\n  }, [enabled]);\r\n}\r\n\r\ninterface TourRootProps extends DivProps {\r\n  open?: boolean;\r\n  defaultOpen?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  value?: number;\r\n  defaultValue?: number;\r\n  onValueChange?: (step: number) => void;\r\n  onComplete?: () => void;\r\n  onSkip?: () => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  scrollToElement?: boolean;\r\n  scrollBehavior?: ScrollBehavior;\r\n  scrollOffset?: ScrollOffset;\r\n  dismissible?: boolean;\r\n  modal?: boolean;\r\n  stepFooter?: React.ReactElement;\r\n}\r\n\r\nfunction TourRoot(props: TourRootProps) {\r\n  const {\r\n    open: openProp,\r\n    defaultOpen = false,\r\n    onOpenChange,\r\n    value: valueProp,\r\n    defaultValue = 0,\r\n    onValueChange,\r\n    onComplete,\r\n    onSkip,\r\n    scrollToElement = false,\r\n    scrollBehavior = \"smooth\",\r\n    scrollOffset,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    open: openProp ?? defaultOpen,\r\n    value: valueProp ?? defaultValue,\r\n    steps: [],\r\n    maskPath: \"\",\r\n  }));\r\n  const listenersRef = useLazyRef<Set<() => void>>(() => new Set());\r\n  const stepIdsMapRef = useLazyRef<Map<string, number>>(() => new Map());\r\n  const stepIdCounterRef = useLazyRef(() => ({ current: 0 }));\r\n  const propsRef = useAsRef({\r\n    valueProp,\r\n    onOpenChange,\r\n    onValueChange,\r\n    onComplete,\r\n    onSkip,\r\n    scrollToElement,\r\n    scrollBehavior,\r\n    scrollOffset,\r\n  });\r\n\r\n  const store: Store = React.useMemo(\r\n    () => ({\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => {\r\n        return stateRef.current;\r\n      },\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n        stateRef.current[key] = value;\r\n\r\n        if (key === \"open\" && typeof value === \"boolean\") {\r\n          propsRef.current.onOpenChange?.(value);\r\n\r\n          if (value) {\r\n            if (stateRef.current.steps.length > 0) {\r\n              if (stateRef.current.value >= stateRef.current.steps.length) {\r\n                store.setState(\"value\", 0);\r\n              }\r\n            }\r\n          } else {\r\n            if (\r\n              stateRef.current.value <\r\n              (stateRef.current.steps.length || 0) - 1\r\n            ) {\r\n              propsRef.current.onSkip?.();\r\n            }\r\n          }\r\n        } else if (key === \"value\" && typeof value === \"number\") {\r\n          const prevStep = stateRef.current.steps[stateRef.current.value];\r\n          const nextStep = stateRef.current.steps[value];\r\n\r\n          prevStep?.onStepLeave?.();\r\n          nextStep?.onStepEnter?.();\r\n\r\n          if (propsRef.current.valueProp !== undefined) {\r\n            propsRef.current.onValueChange?.(value);\r\n            return;\r\n          }\r\n\r\n          propsRef.current.onValueChange?.(value);\r\n\r\n          if (value >= stateRef.current.steps.length) {\r\n            propsRef.current.onComplete?.();\r\n            store.setState(\"open\", false);\r\n            return;\r\n          }\r\n\r\n          if (nextStep && propsRef.current.scrollToElement) {\r\n            const targetElement = getTargetElement(nextStep.target);\r\n            if (targetElement) {\r\n              onScrollToElement(\r\n                targetElement,\r\n                propsRef.current.scrollBehavior,\r\n                propsRef.current.scrollOffset,\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        listenersRef.current.forEach((l) => {\r\n          l();\r\n        });\r\n      },\r\n      addStep: (stepData) => {\r\n        const id = `step-${stepIdCounterRef.current.current++}`;\r\n        const index = stateRef.current.steps.length;\r\n        stepIdsMapRef.current.set(id, index);\r\n        stateRef.current.steps = [...stateRef.current.steps, stepData];\r\n        store.notify();\r\n        return { id, index };\r\n      },\r\n      removeStep: (id) => {\r\n        const index = stepIdsMapRef.current.get(id);\r\n        if (index === undefined) return;\r\n\r\n        stateRef.current.steps = stateRef.current.steps.filter(\r\n          (_, i) => i !== index,\r\n        );\r\n\r\n        stepIdsMapRef.current.delete(id);\r\n\r\n        for (const [stepId, stepIndex] of stepIdsMapRef.current.entries()) {\r\n          if (stepIndex > index) {\r\n            stepIdsMapRef.current.set(stepId, stepIndex - 1);\r\n          }\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n    }),\r\n    [stateRef, listenersRef, stepIdsMapRef, stepIdCounterRef, propsRef],\r\n  );\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (openProp !== undefined) {\r\n      store.setState(\"open\", openProp);\r\n    }\r\n  }, [openProp, store]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp, store]);\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <TourRootImpl {...rootProps} />\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TourRootImplProps\r\n  extends Omit<\r\n    TourRootProps,\r\n    | \"open\"\r\n    | \"defaultOpen\"\r\n    | \"onOpenChange\"\r\n    | \"value\"\r\n    | \"defaultValue\"\r\n    | \"onValueChange\"\r\n    | \"onComplete\"\r\n    | \"onSkip\"\r\n  > {}\r\n\r\nfunction TourRootImpl(props: TourRootImplProps) {\r\n  const {\r\n    onEscapeKeyDown,\r\n    dir: dirProp,\r\n    stepFooter,\r\n    dismissible = true,\r\n    modal = true,\r\n    asChild,\r\n    ...rootImplProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(\"TourRootImpl\");\r\n  const dir = useDirection(dirProp);\r\n\r\n  const [portal, setPortal] = React.useState<HTMLElement | null>(null);\r\n\r\n  const onEscapeKeyDownRef = React.useRef(onEscapeKeyDown);\r\n  onEscapeKeyDownRef.current = onEscapeKeyDown;\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (store.getState().open && event.key === \"Escape\") {\r\n        if (onEscapeKeyDownRef.current) {\r\n          onEscapeKeyDownRef.current(event);\r\n          if (event.defaultPrevented) return;\r\n        }\r\n        store.setState(\"open\", false);\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"keydown\", onKeyDown);\r\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\r\n  }, [store]);\r\n\r\n  const contextValue = React.useMemo<TourContextValue>(\r\n    () => ({\r\n      dir,\r\n      dismissible,\r\n      modal,\r\n      stepFooter,\r\n    }),\r\n    [dir, dismissible, modal, stepFooter],\r\n  );\r\n\r\n  const portalContextValue = React.useMemo(\r\n    () => ({\r\n      portal,\r\n      onPortalChange: setPortal,\r\n    }),\r\n    [portal],\r\n  );\r\n\r\n  const open = useStore((state) => state.open);\r\n  useScrollLock(open && modal);\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <TourContext.Provider value={contextValue}>\r\n      <PortalContext.Provider value={portalContextValue}>\r\n        <RootPrimitive data-slot=\"tour\" dir={dir} {...rootImplProps} />\r\n      </PortalContext.Provider>\r\n    </TourContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TourStepProps extends DivProps {\r\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\r\n  side?: Side;\r\n  sideOffset?: number;\r\n  align?: Align;\r\n  alignOffset?: number;\r\n  collisionBoundary?: Boundary | Boundary[];\r\n  collisionPadding?: number | Partial<Record<Side, number>>;\r\n  arrowPadding?: number;\r\n  sticky?: \"partial\" | \"always\";\r\n  hideWhenDetached?: boolean;\r\n  avoidCollisions?: boolean;\r\n  onStepEnter?: () => void;\r\n  onStepLeave?: () => void;\r\n  onArrowChange?: (arrow: HTMLElement | null) => void;\r\n  required?: boolean;\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction TourStep(props: TourStepProps) {\r\n  const {\r\n    target,\r\n    side = \"bottom\",\r\n    sideOffset = 8,\r\n    align = \"center\",\r\n    alignOffset = 0,\r\n    collisionBoundary = [],\r\n    collisionPadding = 0,\r\n    arrowPadding = 0,\r\n    sticky = \"partial\",\r\n    hideWhenDetached = false,\r\n    avoidCollisions = true,\r\n    required = false,\r\n    forceMount = false,\r\n    onStepEnter,\r\n    onStepLeave,\r\n    children,\r\n    className,\r\n    style,\r\n    asChild,\r\n    ...stepProps\r\n  } = props;\r\n\r\n  const [arrow, setArrow] = React.useState<HTMLElement | null>(null);\r\n  const [footer, setFooter] = React.useState<HTMLElement | null>(null);\r\n  const stepRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n  const store = useStoreContext(STEP_NAME);\r\n  const stepIdRef = React.useRef<string>(\"\");\r\n  const stepOrderRef = React.useRef<number>(-1);\r\n\r\n  const open = useStore((state) => state.open);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n  const context = useTourContext(STEP_NAME);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const stepData: StepData = {\r\n      target,\r\n      side,\r\n      sideOffset,\r\n      align,\r\n      alignOffset,\r\n      collisionBoundary,\r\n      collisionPadding,\r\n      arrowPadding,\r\n      sticky,\r\n      hideWhenDetached,\r\n      avoidCollisions,\r\n      onStepEnter,\r\n      onStepLeave,\r\n      required,\r\n    };\r\n\r\n    const { id, index } = store.addStep(stepData);\r\n    stepIdRef.current = id;\r\n    stepOrderRef.current = index;\r\n\r\n    return () => {\r\n      store.removeStep(stepIdRef.current);\r\n    };\r\n  }, [\r\n    target,\r\n    side,\r\n    sideOffset,\r\n    align,\r\n    alignOffset,\r\n    collisionPadding,\r\n    arrowPadding,\r\n    sticky,\r\n    hideWhenDetached,\r\n    avoidCollisions,\r\n    required,\r\n    onStepEnter,\r\n    onStepLeave,\r\n  ]);\r\n\r\n  const stepData = steps[value];\r\n  const targetElement = stepData ? getTargetElement(stepData.target) : null;\r\n\r\n  const isCurrentStep = stepOrderRef.current === value;\r\n\r\n  const middleware = React.useMemo(() => {\r\n    if (!stepData) return [];\r\n\r\n    const mainAxisOffset = stepData.sideOffset ?? sideOffset;\r\n    const crossAxisOffset = stepData.alignOffset ?? alignOffset;\r\n\r\n    const padding =\r\n      typeof stepData.collisionPadding === \"number\"\r\n        ? stepData.collisionPadding\r\n        : {\r\n            top: stepData.collisionPadding?.top ?? 0,\r\n            right: stepData.collisionPadding?.right ?? 0,\r\n            bottom: stepData.collisionPadding?.bottom ?? 0,\r\n            left: stepData.collisionPadding?.left ?? 0,\r\n          };\r\n\r\n    const boundary = Array.isArray(stepData.collisionBoundary)\r\n      ? stepData.collisionBoundary\r\n      : stepData.collisionBoundary\r\n        ? [stepData.collisionBoundary]\r\n        : [];\r\n    const hasExplicitBoundaries = boundary.length > 0;\r\n\r\n    const detectOverflowOptions = {\r\n      padding,\r\n      boundary: boundary.filter((b): b is Element => b !== null),\r\n      altBoundary: hasExplicitBoundaries,\r\n    };\r\n\r\n    return [\r\n      offset({\r\n        mainAxis: mainAxisOffset,\r\n        alignmentAxis: crossAxisOffset,\r\n      }),\r\n      stepData.avoidCollisions &&\r\n        shift({\r\n          mainAxis: true,\r\n          crossAxis: false,\r\n          limiter: stepData.sticky === \"partial\" ? limitShift() : undefined,\r\n          ...detectOverflowOptions,\r\n        }),\r\n      stepData.avoidCollisions && flip({ ...detectOverflowOptions }),\r\n      arrow &&\r\n        floatingUIarrow({ element: arrow, padding: stepData.arrowPadding }),\r\n      stepData.hideWhenDetached &&\r\n        hide({\r\n          strategy: \"referenceHidden\",\r\n          ...detectOverflowOptions,\r\n        }),\r\n    ].filter(Boolean) as Middleware[];\r\n  }, [stepData, sideOffset, alignOffset, arrow]);\r\n\r\n  const placement = getPlacement(\r\n    stepData?.side ?? side,\r\n    stepData?.align ?? align,\r\n  );\r\n\r\n  const {\r\n    refs,\r\n    floatingStyles,\r\n    placement: finalPlacement,\r\n    middlewareData,\r\n  } = useFloating({\r\n    placement,\r\n    middleware,\r\n    strategy: \"fixed\",\r\n    whileElementsMounted: autoUpdate,\r\n    elements: {\r\n      reference: targetElement,\r\n    },\r\n  });\r\n\r\n  const composedRef = useComposedRefs(refs.setFloating, stepRef);\r\n\r\n  const [placedSide, placedAlign] =\r\n    getSideAndAlignFromPlacement(finalPlacement);\r\n\r\n  const arrowX = middlewareData.arrow?.x;\r\n  const arrowY = middlewareData.arrow?.y;\r\n  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\r\n\r\n  const stepContextValue = React.useMemo<StepContextValue>(\r\n    () => ({\r\n      arrowX,\r\n      arrowY,\r\n      placedSide,\r\n      placedAlign,\r\n      shouldHideArrow: cannotCenterArrow,\r\n      onArrowChange: setArrow,\r\n      onFooterChange: setFooter,\r\n    }),\r\n    [arrowX, arrowY, placedSide, placedAlign, cannotCenterArrow],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (open && targetElement && isCurrentStep) {\r\n      updateMask(store, targetElement, 4);\r\n\r\n      function onResize() {\r\n        if (targetElement) {\r\n          updateMask(store, targetElement, 4);\r\n        }\r\n      }\r\n\r\n      window.addEventListener(\"resize\", onResize);\r\n      return () => window.removeEventListener(\"resize\", onResize);\r\n    }\r\n  }, [open, targetElement, isCurrentStep, store]);\r\n\r\n  useFocusTrap(stepRef, open && isCurrentStep);\r\n\r\n  if (!open || !stepData || (!targetElement && !forceMount) || !isCurrentStep) {\r\n    return null;\r\n  }\r\n\r\n  const isHidden = hideWhenDetached && middlewareData.hide?.referenceHidden;\r\n\r\n  const StepPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <StepContext.Provider value={stepContextValue}>\r\n      <StepPrimitive\r\n        ref={composedRef}\r\n        data-slot=\"tour-step\"\r\n        data-side={placedSide}\r\n        data-align={placedAlign}\r\n        dir={context.dir}\r\n        tabIndex={-1}\r\n        {...stepProps}\r\n        className={cn(\r\n          \"fixed z-50 flex w-80 flex-col gap-4 rounded-lg border bg-popover p-4 text-popover-foreground shadow-md outline-none\",\r\n          className,\r\n        )}\r\n        style={{\r\n          ...style,\r\n          ...floatingStyles,\r\n          visibility: isHidden ? \"hidden\" : undefined,\r\n          pointerEvents: isHidden ? \"none\" : undefined,\r\n        }}\r\n      >\r\n        {children}\r\n        {!footer && (\r\n          <DefaultFooterContext.Provider value={true}>\r\n            {context.stepFooter}\r\n          </DefaultFooterContext.Provider>\r\n        )}\r\n      </StepPrimitive>\r\n    </StepContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TourOverlayProps extends DivProps {\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction TourOverlay(props: TourOverlayProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    style,\r\n    forceMount = false,\r\n    ...backdropProps\r\n  } = props;\r\n\r\n  const context = useTourContext(OVERLAY_NAME);\r\n  const store = useStoreContext(OVERLAY_NAME);\r\n  const open = useStore((state) => state.open);\r\n  const maskPath = useStore((state) => state.maskPath);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      backdropProps.onClick?.(event);\r\n      if (event.defaultPrevented || !context.dismissible) return;\r\n\r\n      store.setState(\"open\", false);\r\n    },\r\n    [store, backdropProps.onClick, context.dismissible],\r\n  );\r\n\r\n  if (!open && !forceMount) return null;\r\n\r\n  const OverlayPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <OverlayPrimitive\r\n      data-state={open ? \"open\" : \"closed\"}\r\n      data-slot=\"tour-overlay\"\r\n      {...backdropProps}\r\n      className={cn(\r\n        \"data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=open]:animate-in\",\r\n        className,\r\n      )}\r\n      style={{\r\n        ...style,\r\n        clipPath: maskPath,\r\n      }}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TourPortalProps {\r\n  children?: React.ReactNode;\r\n  container?: HTMLElement | null;\r\n}\r\n\r\nfunction TourPortal(props: TourPortalProps) {\r\n  const { children, container } = props;\r\n\r\n  const portalContext = usePortalContext(PORTAL_NAME);\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    setMounted(true);\r\n\r\n    const node = container ?? document.body;\r\n\r\n    portalContext?.onPortalChange(node);\r\n    return () => {\r\n      portalContext?.onPortalChange(null);\r\n    };\r\n  }, [container, portalContext]);\r\n\r\n  if (!mounted) return null;\r\n\r\n  const portalContainer = container ?? portalContext?.portal ?? document.body;\r\n\r\n  return ReactDOM.createPortal(children, portalContainer);\r\n}\r\n\r\nfunction useFocusTrap(\r\n  containerRef: React.RefObject<HTMLElement | null>,\r\n  enabled: boolean,\r\n) {\r\n  React.useEffect(() => {\r\n    if (!enabled || !containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n    const previousActiveElement = document.activeElement as HTMLElement;\r\n\r\n    function getFocusableElements() {\r\n      const selector =\r\n        'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"])';\r\n      return Array.from(\r\n        container.querySelectorAll<HTMLElement>(selector),\r\n      ).filter((el) => {\r\n        return (\r\n          el.offsetParent !== null &&\r\n          !el.hasAttribute(\"disabled\") &&\r\n          el.getAttribute(\"aria-hidden\") !== \"true\"\r\n        );\r\n      });\r\n    }\r\n\r\n    function onTabKeyDown(e: KeyboardEvent) {\r\n      if (e.key !== \"Tab\") return;\r\n\r\n      const focusableElements = getFocusableElements();\r\n      if (focusableElements.length === 0) {\r\n        e.preventDefault();\r\n        return;\r\n      }\r\n\r\n      const firstElement = focusableElements[0];\r\n      const lastElement = focusableElements[focusableElements.length - 1];\r\n\r\n      if (e.shiftKey) {\r\n        if (document.activeElement === firstElement) {\r\n          e.preventDefault();\r\n          lastElement?.focus();\r\n        }\r\n      } else {\r\n        if (document.activeElement === lastElement) {\r\n          e.preventDefault();\r\n          firstElement?.focus();\r\n        }\r\n      }\r\n    }\r\n\r\n    const focusableElements = getFocusableElements();\r\n    if (focusableElements.length > 0) {\r\n      focusableElements[0]?.focus();\r\n    } else {\r\n      container.focus();\r\n    }\r\n\r\n    container.addEventListener(\"keydown\", onTabKeyDown);\r\n\r\n    return () => {\r\n      container.removeEventListener(\"keydown\", onTabKeyDown);\r\n      if (\r\n        previousActiveElement &&\r\n        document.body.contains(previousActiveElement)\r\n      ) {\r\n        previousActiveElement.focus();\r\n      }\r\n    };\r\n  }, [containerRef, enabled]);\r\n}\r\n\r\nfunction TourHeader(props: DivProps) {\r\n  const { asChild, className, ...headerProps } = props;\r\n\r\n  const context = useTourContext(HEADER_NAME);\r\n\r\n  const HeaderPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <HeaderPrimitive\r\n      data-slot=\"tour-header\"\r\n      dir={context.dir}\r\n      {...headerProps}\r\n      className={cn(\r\n        \"flex flex-col gap-1.5 text-center sm:text-left\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TourTitleProps extends React.ComponentProps<\"h2\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TourTitle(props: TourTitleProps) {\r\n  const { asChild, className, ...titleProps } = props;\r\n\r\n  const context = useTourContext(TITLE_NAME);\r\n\r\n  const TitlePrimitive = asChild ? Slot : \"h2\";\r\n\r\n  return (\r\n    <TitlePrimitive\r\n      data-slot=\"tour-title\"\r\n      dir={context.dir}\r\n      {...titleProps}\r\n      className={cn(\r\n        \"font-semibold text-lg leading-none tracking-tight\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TourDescriptionProps extends React.ComponentProps<\"p\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TourDescription(props: TourDescriptionProps) {\r\n  const { asChild, className, ...descriptionProps } = props;\r\n\r\n  const context = useTourContext(DESCRIPTION_NAME);\r\n\r\n  const DescriptionPrimitive = asChild ? Slot : \"p\";\r\n\r\n  return (\r\n    <DescriptionPrimitive\r\n      data-slot=\"tour-description\"\r\n      dir={context.dir}\r\n      {...descriptionProps}\r\n      className={cn(\"text-muted-foreground text-sm\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nfunction TourFooter(props: DivProps) {\r\n  const { asChild, className, ref, ...footerProps } = props;\r\n\r\n  const stepContext = useStepContext(FOOTER_NAME);\r\n  const hasDefaultFooter = React.useContext(DefaultFooterContext);\r\n  const context = useTourContext(FOOTER_NAME);\r\n\r\n  const composedRef = useComposedRefs(\r\n    ref,\r\n    hasDefaultFooter ? undefined : stepContext.onFooterChange,\r\n  );\r\n\r\n  const FooterPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <FooterPrimitive\r\n      data-slot=\"tour-footer\"\r\n      dir={context.dir}\r\n      {...footerProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction TourClose(props: ButtonProps) {\r\n  const { asChild, className, ...closeButtonProps } = props;\r\n\r\n  const store = useStoreContext(CLOSE_NAME);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      closeButtonProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"open\", false);\r\n    },\r\n    [store, closeButtonProps.onClick],\r\n  );\r\n\r\n  const ClosePrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <ClosePrimitive\r\n      type=\"button\"\r\n      aria-label=\"Close tour\"\r\n      className={cn(\r\n        \"absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      {...closeButtonProps}\r\n    >\r\n      <X className=\"size-4\" />\r\n    </ClosePrimitive>\r\n  );\r\n}\r\n\r\ninterface TourStepCounterProps extends DivProps {\r\n  format?: (current: number, total: number) => string;\r\n}\r\n\r\nfunction TourStepCounter(props: TourStepCounterProps) {\r\n  const {\r\n    format = (current, total) => `${current} / ${total}`,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ...stepCounterProps\r\n  } = props;\r\n\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const StepCounterPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <StepCounterPrimitive\r\n      data-slot=\"tour-step-counter\"\r\n      {...stepCounterProps}\r\n      className={cn(\"text-muted-foreground text-sm\", className)}\r\n    >\r\n      {children ?? format(value + 1, steps.length)}\r\n    </StepCounterPrimitive>\r\n  );\r\n}\r\n\r\nfunction TourPrev(props: ButtonProps) {\r\n  const { children, ...prevButtonProps } = props;\r\n\r\n  const store = useStoreContext(PREV_NAME);\r\n  const value = useStore((state) => state.value);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      prevButtonProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (value > 0) {\r\n        store.setState(\"value\", value - 1);\r\n      }\r\n    },\r\n    [value, store, prevButtonProps.onClick],\r\n  );\r\n\r\n  const isDisabled = value === 0;\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      aria-label=\"Previous step\"\r\n      data-slot=\"tour-prev\"\r\n      variant=\"outline\"\r\n      {...prevButtonProps}\r\n      onClick={onClick}\r\n      disabled={isDisabled}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <ChevronLeft />\r\n          Previous\r\n        </>\r\n      )}\r\n    </Button>\r\n  );\r\n}\r\n\r\nfunction TourNext(props: ButtonProps) {\r\n  const { children, ...nextButtonProps } = props;\r\n  const store = useStoreContext(NEXT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      nextButtonProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"value\", value + 1);\r\n    },\r\n    [value, store, nextButtonProps.onClick],\r\n  );\r\n\r\n  const isLastStep = value === steps.length - 1;\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      aria-label=\"Next step\"\r\n      data-slot=\"tour-next\"\r\n      {...nextButtonProps}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          {isLastStep ? \"Finish\" : \"Next\"}\r\n          {!isLastStep && <ChevronRight />}\r\n        </>\r\n      )}\r\n    </Button>\r\n  );\r\n}\r\n\r\nfunction TourSkip(props: ButtonProps) {\r\n  const { children, ...skipButtonProps } = props;\r\n\r\n  const store = useStoreContext(SKIP_NAME);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      skipButtonProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"open\", false);\r\n    },\r\n    [store, skipButtonProps.onClick],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      aria-label=\"Skip tour\"\r\n      data-slot=\"tour-skip\"\r\n      variant=\"outline\"\r\n      {...skipButtonProps}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? \"Skip\"}\r\n    </Button>\r\n  );\r\n}\r\n\r\ninterface TourArrowProps extends React.ComponentProps<\"svg\"> {\r\n  width?: number;\r\n  height?: number;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TourArrow(props: TourArrowProps) {\r\n  const {\r\n    width = 10,\r\n    height = 5,\r\n    className,\r\n    children,\r\n    asChild,\r\n    ...arrowProps\r\n  } = props;\r\n\r\n  const stepContext = useStepContext(ARROW_NAME);\r\n  const baseSide = OPPOSITE_SIDE[stepContext.placedSide];\r\n\r\n  return (\r\n    <span\r\n      ref={stepContext.onArrowChange}\r\n      data-slot=\"tour-arrow\"\r\n      style={{\r\n        position: \"absolute\",\r\n        left:\r\n          stepContext.arrowX != null ? `${stepContext.arrowX}px` : undefined,\r\n        top: stepContext.arrowY != null ? `${stepContext.arrowY}px` : undefined,\r\n        [baseSide]: 0,\r\n        transformOrigin: {\r\n          top: \"\",\r\n          right: \"0 0\",\r\n          bottom: \"center 0\",\r\n          left: \"100% 0\",\r\n        }[stepContext.placedSide],\r\n        transform: {\r\n          top: \"translateY(100%)\",\r\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\r\n          bottom: \"rotate(180deg)\",\r\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\",\r\n        }[stepContext.placedSide],\r\n        visibility: stepContext.shouldHideArrow ? \"hidden\" : undefined,\r\n      }}\r\n    >\r\n      <svg\r\n        viewBox=\"0 0 30 10\"\r\n        preserveAspectRatio=\"none\"\r\n        width={width}\r\n        height={height}\r\n        {...arrowProps}\r\n        className={cn(\"block fill-popover stroke-border\", className)}\r\n      >\r\n        {asChild ? children : <polygon points=\"0,0 30,0 15,10\" />}\r\n      </svg>\r\n    </span>\r\n  );\r\n}\r\n\r\nexport {\r\n  TourRoot as Root,\r\n  TourPortal as Portal,\r\n  TourOverlay as Overlay,\r\n  TourStep as Step,\r\n  TourHeader as Header,\r\n  TourTitle as Title,\r\n  TourDescription as Description,\r\n  TourFooter as Footer,\r\n  TourClose as Close,\r\n  TourStepCounter as StepCounter,\r\n  TourPrev as Prev,\r\n  TourNext as Next,\r\n  TourSkip as Skip,\r\n  TourArrow as Arrow,\r\n  //\r\n  TourRoot as Tour,\r\n  TourPortal,\r\n  TourOverlay,\r\n  TourStep,\r\n  TourHeader,\r\n  TourTitle,\r\n  TourDescription,\r\n  TourFooter,\r\n  TourClose,\r\n  TourStepCounter,\r\n  TourPrev,\r\n  TourNext,\r\n  TourSkip,\r\n  TourArrow,\r\n  //\r\n  type TourRootProps as TourProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}