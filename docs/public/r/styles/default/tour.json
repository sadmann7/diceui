{
  "name": "tour",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/tour.tsx",
      "content": "\"use client\";\n\nimport {\n  autoUpdate,\n  flip,\n  arrow as floatingUIarrow,\n  hide,\n  limitShift,\n  type Middleware,\n  offset,\n  type Placement,\n  shift,\n  useFloating,\n} from \"@floating-ui/react-dom\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { ChevronLeft, ChevronRight, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"Tour\";\nconst OVERLAY_NAME = \"TourOverlay\";\nconst STEP_NAME = \"TourStep\";\nconst CLOSE_NAME = \"TourClose\";\nconst PREV_NAME = \"TourPrev\";\nconst NEXT_NAME = \"TourNext\";\nconst SKIP_NAME = \"TourSkip\";\nconst FOOTER_NAME = \"TourFooter\";\nconst ARROW_NAME = \"TourArrow\";\n\nconst SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"] as const;\nconst ALIGN_OPTIONS = [\"start\", \"center\", \"end\"] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\ntype Direction = \"ltr\" | \"rtl\";\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\",\n};\n\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\nfunction useDirection(dirProp?: Direction): Direction {\n  const contextDir = React.useContext(DirectionContext);\n  return dirProp ?? contextDir ?? \"ltr\";\n}\n\ninterface ScrollOffset {\n  top?: number;\n  bottom?: number;\n  left?: number;\n  right?: number;\n}\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\ntype Boundary = Element | null;\n\ninterface StepData {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  arrowPadding?: number;\n  sticky?: \"partial\" | \"always\";\n  hideWhenDetached?: boolean;\n  avoidCollisions?: boolean;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  required?: boolean;\n}\n\ninterface State {\n  open: boolean;\n  value: number;\n  steps: StepData[];\n  maskPath: string;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => State;\n  setState: <K extends keyof State>(\n    key: K,\n    value: State[K],\n    opts?: unknown,\n  ) => void;\n  notify: () => void;\n  addStep: (stepData: StepData) => { id: string; index: number };\n  removeStep: (id: string) => void;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useStore<T>(selector: (state: State) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\nfunction getTargetElement(\n  target: string | React.RefObject<HTMLElement> | HTMLElement,\n): HTMLElement | null {\n  if (typeof target === \"string\") {\n    return document.querySelector(target);\n  }\n  if (target && \"current\" in target) {\n    return target.current;\n  }\n  if (target instanceof HTMLElement) {\n    return target;\n  }\n  return null;\n}\n\nfunction scrollToElement(\n  element: HTMLElement,\n  scrollBehavior: ScrollBehavior = \"smooth\",\n  scrollOffset?: ScrollOffset,\n) {\n  const offset = {\n    top: 100,\n    bottom: 100,\n    left: 0,\n    right: 0,\n    ...scrollOffset,\n  };\n  const rect = element.getBoundingClientRect();\n  const viewportHeight = window.innerHeight;\n  const viewportWidth = window.innerWidth;\n\n  const isInViewport =\n    rect.top >= offset.top &&\n    rect.bottom <= viewportHeight - offset.bottom &&\n    rect.left >= offset.left &&\n    rect.right <= viewportWidth - offset.right;\n\n  if (!isInViewport) {\n    const elementTop = rect.top + window.scrollY;\n    const scrollTop = elementTop - offset.top;\n\n    window.scrollTo({\n      top: Math.max(0, scrollTop),\n      behavior: scrollBehavior,\n    });\n  }\n}\n\nfunction getSideAndAlignFromPlacement(placement: Placement): [Side, Align] {\n  const [side, align = \"center\"] = placement.split(\"-\") as [Side, Align?];\n  return [side, align];\n}\n\nfunction getPlacement(side: Side, align: Align): Placement {\n  if (align === \"center\") {\n    return side as Placement;\n  }\n  return `${side}-${align}` as Placement;\n}\n\nfunction updateMask(\n  store: Store,\n  targetElement: HTMLElement,\n  padding: number = 4,\n) {\n  const clientRect = targetElement.getBoundingClientRect();\n  const viewportWidth = window.innerWidth;\n  const viewportHeight = window.innerHeight;\n\n  const x = Math.max(0, clientRect.left - padding);\n  const y = Math.max(0, clientRect.top - padding);\n  const width = Math.min(viewportWidth - x, clientRect.width + padding * 2);\n  const height = Math.min(viewportHeight - y, clientRect.height + padding * 2);\n\n  const path = `polygon(0% 0%, 0% 100%, ${x}px 100%, ${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px, ${x}px 100%, 100% 100%, 100% 0%)`;\n  store.setState(\"maskPath\", path);\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface TourContextValue {\n  dir: Direction;\n  stepFooter?: React.ReactElement;\n}\n\nconst TourContext = React.createContext<TourContextValue | null>(null);\n\nfunction useTourContext(consumerName: string) {\n  const context = React.useContext(TourContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface StepContextValue {\n  arrowX?: number;\n  arrowY?: number;\n  placedSide: Side;\n  placedAlign: Align;\n  shouldHideArrow: boolean;\n  onArrowChange: (arrow: HTMLElement | null) => void;\n  onFooterChange: (footer: HTMLElement | null) => void;\n}\n\nconst StepContext = React.createContext<StepContextValue | null>(null);\n\nfunction useStepContext(consumerName: string) {\n  const context = React.useContext(StepContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${STEP_NAME}\\``);\n  }\n  return context;\n}\n\nconst DefaultFooterContext = React.createContext(false);\n\ninterface TourRootProps extends DivProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  value?: number;\n  defaultValue?: number;\n  onValueChange?: (step: number) => void;\n  onComplete?: () => void;\n  onSkip?: () => void;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  dir?: Direction;\n  scrollToElement?: boolean;\n  scrollBehavior?: ScrollBehavior;\n  scrollOffset?: ScrollOffset;\n  stepFooter?: React.ReactElement;\n}\n\nfunction TourRoot(props: TourRootProps) {\n  const {\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    value: valueProp,\n    defaultValue = 0,\n    onValueChange,\n    onComplete,\n    onSkip,\n    onEscapeKeyDown,\n    dir: dirProp,\n    stepFooter,\n    scrollToElement: scrollToElementProp = false,\n    scrollBehavior = \"smooth\",\n    scrollOffset,\n    asChild,\n    ...rootProps\n  } = props;\n\n  const dir = useDirection(dirProp);\n\n  const state = useLazyRef<State>(() => ({\n    open: openProp ?? defaultOpen,\n    value: valueProp ?? defaultValue,\n    steps: [],\n    maskPath: \"\",\n  }));\n\n  const listenersRef = useLazyRef<Set<() => void>>(() => new Set());\n  const stepIdsMapRef = useLazyRef<Map<string, number>>(() => new Map());\n  const stepIdCounterRef = useLazyRef(() => ({ current: 0 }));\n  const callbacksRef = React.useRef({\n    onOpenChange,\n    onValueChange,\n    onComplete,\n    onSkip,\n    scrollToElementProp,\n    scrollBehavior,\n    scrollOffset,\n    valueProp,\n  });\n\n  callbacksRef.current = {\n    onOpenChange,\n    onValueChange,\n    onComplete,\n    onSkip,\n    scrollToElementProp,\n    scrollBehavior,\n    scrollOffset,\n    valueProp,\n  };\n\n  const store: Store = React.useMemo(\n    () => ({\n      subscribe: (cb) => {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current.delete(cb);\n      },\n      getState: () => {\n        return state.current;\n      },\n      setState: (key, value) => {\n        if (Object.is(state.current[key], value)) return;\n        state.current[key] = value;\n\n        if (key === \"open\" && typeof value === \"boolean\") {\n          callbacksRef.current.onOpenChange?.(value);\n\n          if (value) {\n            if (state.current.steps.length > 0) {\n              if (state.current.value >= state.current.steps.length) {\n                store.setState(\"value\", 0);\n              }\n            }\n          } else {\n            if (state.current.value < (state.current.steps.length || 0) - 1) {\n              callbacksRef.current.onSkip?.();\n            }\n          }\n        } else if (key === \"value\" && typeof value === \"number\") {\n          const prevStep = state.current.steps[state.current.value];\n          const nextStep = state.current.steps[value];\n\n          prevStep?.onStepLeave?.();\n          nextStep?.onStepEnter?.();\n\n          if (callbacksRef.current.valueProp !== undefined) {\n            callbacksRef.current.onValueChange?.(value);\n            return;\n          }\n\n          callbacksRef.current.onValueChange?.(value);\n\n          if (value >= state.current.steps.length) {\n            callbacksRef.current.onComplete?.();\n            store.setState(\"open\", false);\n            return;\n          }\n\n          if (nextStep && callbacksRef.current.scrollToElementProp) {\n            const targetElement = getTargetElement(nextStep.target);\n            if (targetElement) {\n              scrollToElement(\n                targetElement,\n                callbacksRef.current.scrollBehavior,\n                callbacksRef.current.scrollOffset,\n              );\n            }\n          }\n        }\n\n        store.notify();\n      },\n      notify: () => {\n        listenersRef.current.forEach((l) => {\n          l();\n        });\n      },\n      addStep: (stepData) => {\n        const id = `step-${stepIdCounterRef.current.current++}`;\n        const index = state.current.steps.length;\n        stepIdsMapRef.current.set(id, index);\n        state.current.steps = [...state.current.steps, stepData];\n        store.notify();\n        return { id, index };\n      },\n      removeStep: (id) => {\n        const index = stepIdsMapRef.current.get(id);\n        if (index === undefined) return;\n\n        state.current.steps = state.current.steps.filter((_, i) => i !== index);\n\n        stepIdsMapRef.current.delete(id);\n\n        for (const [stepId, stepIndex] of stepIdsMapRef.current.entries()) {\n          if (stepIndex > index) {\n            stepIdsMapRef.current.set(stepId, stepIndex - 1);\n          }\n        }\n\n        store.notify();\n      },\n    }),\n    [state, listenersRef, stepIdsMapRef, stepIdCounterRef],\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (openProp !== undefined) {\n      store.setState(\"open\", openProp);\n    }\n  }, [openProp, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (valueProp !== undefined) {\n      store.setState(\"value\", valueProp);\n    }\n  }, [valueProp, store]);\n\n  const onEscapeKeyDownRef = React.useRef(onEscapeKeyDown);\n  onEscapeKeyDownRef.current = onEscapeKeyDown;\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: onEscapeKeyDownRef is stable, accessed in closures\n  React.useEffect(() => {\n    function onKeyDown(event: KeyboardEvent) {\n      if (state.current.open && event.key === \"Escape\") {\n        if (onEscapeKeyDownRef.current) {\n          onEscapeKeyDownRef.current(event);\n          if (event.defaultPrevented) return;\n        }\n        store.setState(\"open\", false);\n      }\n    }\n\n    document.addEventListener(\"keydown\", onKeyDown);\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\n  }, [state.current.open]);\n\n  const contextValue = React.useMemo<TourContextValue>(\n    () => ({\n      dir,\n      stepFooter,\n    }),\n    [dir, stepFooter],\n  );\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StoreContext.Provider value={store}>\n      <TourContext.Provider value={contextValue}>\n        <RootPrimitive data-slot=\"tour\" dir={dir} {...rootProps} />\n      </TourContext.Provider>\n    </StoreContext.Provider>\n  );\n}\n\ninterface TourStepProps extends DivProps {\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  arrowPadding?: number;\n  sticky?: \"partial\" | \"always\";\n  hideWhenDetached?: boolean;\n  avoidCollisions?: boolean;\n  onStepEnter?: () => void;\n  onStepLeave?: () => void;\n  onArrowChange?: (arrow: HTMLElement | null) => void;\n  required?: boolean;\n  forceMount?: boolean;\n}\n\nfunction TourStep(props: TourStepProps) {\n  const {\n    target,\n    side = \"bottom\",\n    sideOffset = 8,\n    align = \"center\",\n    alignOffset = 0,\n    collisionBoundary = [],\n    collisionPadding = 0,\n    arrowPadding = 0,\n    sticky = \"partial\",\n    hideWhenDetached = false,\n    avoidCollisions = true,\n    required = false,\n    forceMount = false,\n    onStepEnter,\n    onStepLeave,\n    children,\n    className,\n    style,\n    asChild,\n    ...stepProps\n  } = props;\n\n  const [arrow, setArrow] = React.useState<HTMLElement | null>(null);\n  const [footer, setFooter] = React.useState<HTMLElement | null>(null);\n\n  const store = useStoreContext(STEP_NAME);\n  const stepIdRef = React.useRef<string>(\"\");\n  const stepOrderRef = React.useRef<number>(-1);\n\n  const open = useStore((state) => state.open);\n  const value = useStore((state) => state.value);\n  const steps = useStore((state) => state.steps);\n  const context = useTourContext(STEP_NAME);\n\n  useIsomorphicLayoutEffect(() => {\n    const stepData: StepData = {\n      target,\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      collisionBoundary,\n      collisionPadding,\n      arrowPadding,\n      sticky,\n      hideWhenDetached,\n      avoidCollisions,\n      onStepEnter,\n      onStepLeave,\n      required,\n    };\n\n    const { id, index } = store.addStep(stepData);\n    stepIdRef.current = id;\n    stepOrderRef.current = index;\n\n    return () => {\n      store.removeStep(stepIdRef.current);\n    };\n  }, [\n    target,\n    side,\n    sideOffset,\n    align,\n    alignOffset,\n    collisionPadding,\n    arrowPadding,\n    sticky,\n    hideWhenDetached,\n    avoidCollisions,\n    required,\n    onStepEnter,\n    onStepLeave,\n  ]);\n\n  const stepData = steps[value];\n  const targetElement = stepData ? getTargetElement(stepData.target) : null;\n\n  const isCurrentStep = stepOrderRef.current === value;\n\n  const middleware = React.useMemo(() => {\n    if (!stepData) return [];\n\n    const mainAxisOffset = stepData.sideOffset ?? sideOffset;\n    const crossAxisOffset = stepData.alignOffset ?? alignOffset;\n\n    const padding =\n      typeof stepData.collisionPadding === \"number\"\n        ? stepData.collisionPadding\n        : {\n            top: stepData.collisionPadding?.top ?? 0,\n            right: stepData.collisionPadding?.right ?? 0,\n            bottom: stepData.collisionPadding?.bottom ?? 0,\n            left: stepData.collisionPadding?.left ?? 0,\n          };\n\n    const boundary = Array.isArray(stepData.collisionBoundary)\n      ? stepData.collisionBoundary\n      : stepData.collisionBoundary\n        ? [stepData.collisionBoundary]\n        : [];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding,\n      boundary: boundary.filter((b): b is Element => b !== null),\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    return [\n      offset({\n        mainAxis: mainAxisOffset,\n        alignmentAxis: crossAxisOffset,\n      }),\n      stepData.avoidCollisions &&\n        shift({\n          mainAxis: true,\n          crossAxis: false,\n          limiter: stepData.sticky === \"partial\" ? limitShift() : undefined,\n          ...detectOverflowOptions,\n        }),\n      stepData.avoidCollisions && flip({ ...detectOverflowOptions }),\n      arrow &&\n        floatingUIarrow({ element: arrow, padding: stepData.arrowPadding }),\n      stepData.hideWhenDetached &&\n        hide({\n          strategy: \"referenceHidden\",\n          ...detectOverflowOptions,\n        }),\n    ].filter(Boolean) as Middleware[];\n  }, [stepData, sideOffset, alignOffset, arrow]);\n\n  const placement = getPlacement(\n    stepData?.side ?? side,\n    stepData?.align ?? align,\n  );\n\n  const {\n    refs,\n    floatingStyles,\n    placement: finalPlacement,\n    middlewareData,\n  } = useFloating({\n    placement,\n    middleware,\n    strategy: \"fixed\",\n    whileElementsMounted: autoUpdate,\n    elements: {\n      reference: targetElement,\n    },\n  });\n\n  const [placedSide, placedAlign] =\n    getSideAndAlignFromPlacement(finalPlacement);\n\n  const arrowX = middlewareData.arrow?.x;\n  const arrowY = middlewareData.arrow?.y;\n  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n  const stepContextValue = React.useMemo<StepContextValue>(\n    () => ({\n      arrowX,\n      arrowY,\n      placedSide,\n      placedAlign,\n      shouldHideArrow: cannotCenterArrow,\n      onArrowChange: setArrow,\n      onFooterChange: setFooter,\n    }),\n    [arrowX, arrowY, placedSide, placedAlign, cannotCenterArrow],\n  );\n\n  React.useEffect(() => {\n    if (open && targetElement && isCurrentStep) {\n      updateMask(store, targetElement, 4);\n\n      function onResize() {\n        if (targetElement) {\n          updateMask(store, targetElement, 4);\n        }\n      }\n\n      window.addEventListener(\"resize\", onResize);\n      return () => window.removeEventListener(\"resize\", onResize);\n    }\n  }, [open, targetElement, isCurrentStep, store]);\n\n  if (!open || !stepData || (!targetElement && !forceMount) || !isCurrentStep) {\n    return null;\n  }\n\n  const isHidden = hideWhenDetached && middlewareData.hide?.referenceHidden;\n\n  const StepPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StepContext.Provider value={stepContextValue}>\n      <StepPrimitive\n        ref={refs.setFloating}\n        data-slot=\"tour-step\"\n        data-side={placedSide}\n        data-align={placedAlign}\n        dir={context.dir}\n        {...stepProps}\n        className={cn(\n          \"fixed z-50 flex w-80 flex-col gap-4 rounded-lg border bg-popover p-4 text-popover-foreground shadow-md\",\n          className,\n        )}\n        style={{\n          ...style,\n          ...floatingStyles,\n          visibility: isHidden ? \"hidden\" : undefined,\n          pointerEvents: isHidden ? \"none\" : undefined,\n        }}\n      >\n        {children}\n        {!footer && (\n          <DefaultFooterContext.Provider value={true}>\n            {context.stepFooter}\n          </DefaultFooterContext.Provider>\n        )}\n      </StepPrimitive>\n    </StepContext.Provider>\n  );\n}\n\ninterface TourOverlayProps extends DivProps {\n  forceMount?: boolean;\n}\n\nfunction TourOverlay(props: TourOverlayProps) {\n  const {\n    asChild,\n    className,\n    style,\n    forceMount = false,\n    ...backdropProps\n  } = props;\n\n  const store = useStoreContext(OVERLAY_NAME);\n  const open = useStore((state) => state.open);\n  const maskPath = useStore((state) => state.maskPath);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      backdropProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, backdropProps.onClick],\n  );\n\n  if (!open && !forceMount) return null;\n\n  const OverlayPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <OverlayPrimitive\n      data-state={open ? \"open\" : \"closed\"}\n      data-slot=\"tour-overlay\"\n      {...backdropProps}\n      className={cn(\n        \"data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in\",\n        className,\n      )}\n      style={{\n        ...style,\n        clipPath: maskPath,\n      }}\n      onClick={onClick}\n    />\n  );\n}\n\nfunction TourHeader(props: DivProps) {\n  const { asChild, className, ...headerProps } = props;\n\n  const context = useTourContext(\"TourHeader\");\n  const HeaderPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <HeaderPrimitive\n      data-slot=\"tour-header\"\n      dir={context.dir}\n      {...headerProps}\n      className={cn(\n        \"flex flex-col gap-1.5 text-center sm:text-left\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TourTitleProps extends React.ComponentProps<\"h2\"> {\n  asChild?: boolean;\n}\n\nfunction TourTitle(props: TourTitleProps) {\n  const { asChild, className, ...titleProps } = props;\n\n  const context = useTourContext(\"TourTitle\");\n  const TitlePrimitive = asChild ? Slot : \"h2\";\n\n  return (\n    <TitlePrimitive\n      data-slot=\"tour-title\"\n      dir={context.dir}\n      {...titleProps}\n      className={cn(\n        \"font-semibold text-lg leading-none tracking-tight\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TourDescriptionProps extends React.ComponentProps<\"p\"> {\n  asChild?: boolean;\n}\n\nfunction TourDescription(props: TourDescriptionProps) {\n  const { asChild, className, ...descriptionProps } = props;\n\n  const context = useTourContext(\"TourDescription\");\n  const DescriptionPrimitive = asChild ? Slot : \"p\";\n\n  return (\n    <DescriptionPrimitive\n      data-slot=\"tour-description\"\n      dir={context.dir}\n      {...descriptionProps}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n    />\n  );\n}\n\nfunction TourFooter(props: DivProps) {\n  const { asChild, className, ref, ...footerProps } = props;\n\n  const stepContext = useStepContext(FOOTER_NAME);\n  const hasDefaultFooter = React.useContext(DefaultFooterContext);\n  const context = useTourContext(FOOTER_NAME);\n\n  const composedRef = useComposedRefs(\n    ref,\n    hasDefaultFooter ? undefined : stepContext.onFooterChange,\n  );\n\n  const FooterPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <FooterPrimitive\n      data-slot=\"tour-footer\"\n      dir={context.dir}\n      {...footerProps}\n      ref={composedRef}\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className,\n      )}\n    />\n  );\n}\n\nfunction TourClose(props: ButtonProps) {\n  const { asChild, className, ...closeButtonProps } = props;\n\n  const store = useStoreContext(CLOSE_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      closeButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, closeButtonProps.onClick],\n  );\n\n  const ClosePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ClosePrimitive\n      type=\"button\"\n      aria-label=\"Close tour\"\n      className={cn(\n        \"absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none\",\n        className,\n      )}\n      onClick={onClick}\n      {...closeButtonProps}\n    >\n      <X className=\"size-4\" />\n    </ClosePrimitive>\n  );\n}\n\ninterface TourStepCounterProps extends DivProps {\n  format?: (current: number, total: number) => string;\n}\n\nfunction TourStepCounter(props: TourStepCounterProps) {\n  const {\n    format = (current, total) => `${current} / ${total}`,\n    asChild,\n    className,\n    children,\n    ...stepCounterProps\n  } = props;\n\n  const value = useStore((state) => state.value);\n  const steps = useStore((state) => state.steps);\n\n  const StepCounterPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StepCounterPrimitive\n      data-slot=\"tour-step-counter\"\n      {...stepCounterProps}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n    >\n      {children ?? format(value + 1, steps.length)}\n    </StepCounterPrimitive>\n  );\n}\n\nfunction TourPrev(props: ButtonProps) {\n  const { asChild, className, children, ...prevButtonProps } = props;\n\n  const store = useStoreContext(PREV_NAME);\n  const value = useStore((state) => state.value);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      prevButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      if (value > 0) {\n        store.setState(\"value\", value - 1);\n      }\n    },\n    [value, store, prevButtonProps.onClick],\n  );\n\n  const isDisabled = value === 0;\n\n  const PrevPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <PrevPrimitive\n      type=\"button\"\n      aria-label=\"Previous step\"\n      data-slot=\"tour-prev\"\n      {...prevButtonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n      disabled={isDisabled}\n    >\n      {children ?? (\n        <>\n          <ChevronLeft className=\"size-4\" />\n          Previous\n        </>\n      )}\n    </PrevPrimitive>\n  );\n}\n\nfunction TourNext(props: ButtonProps) {\n  const { asChild, className, children, ...nextButtonProps } = props;\n  const store = useStoreContext(NEXT_NAME);\n  const value = useStore((state) => state.value);\n  const steps = useStore((state) => state.steps);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      nextButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"value\", value + 1);\n    },\n    [value, store, nextButtonProps.onClick],\n  );\n\n  const isLastStep = value === steps.length - 1;\n\n  const NextPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <NextPrimitive\n      type=\"button\"\n      aria-label=\"Next step\"\n      data-slot=\"tour-next\"\n      {...nextButtonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md bg-primary px-3 font-medium text-primary-foreground text-sm ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n    >\n      {children ?? (\n        <>\n          {isLastStep ? \"Finish\" : \"Next\"}\n          {!isLastStep && <ChevronRight className=\"size-4\" />}\n        </>\n      )}\n    </NextPrimitive>\n  );\n}\n\nfunction TourSkip(props: ButtonProps) {\n  const { asChild, className, children, ...skipButtonProps } = props;\n\n  const store = useStoreContext(SKIP_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      skipButtonProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [store, skipButtonProps.onClick],\n  );\n\n  const SkipPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <SkipPrimitive\n      type=\"button\"\n      aria-label=\"Skip tour\"\n      data-slot=\"tour-skip\"\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-input bg-background px-3 font-medium text-sm ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n      {...skipButtonProps}\n    >\n      {children ?? \"Skip\"}\n    </SkipPrimitive>\n  );\n}\n\ninterface TourArrowProps extends React.ComponentPropsWithoutRef<\"svg\"> {\n  width?: number;\n  height?: number;\n  asChild?: boolean;\n}\n\nfunction TourArrow(props: TourArrowProps) {\n  const {\n    width = 10,\n    height = 5,\n    className,\n    children,\n    asChild,\n    ...arrowProps\n  } = props;\n\n  const stepContext = useStepContext(ARROW_NAME);\n  const baseSide = OPPOSITE_SIDE[stepContext.placedSide];\n\n  return (\n    <span\n      ref={stepContext.onArrowChange}\n      data-slot=\"tour-arrow\"\n      style={{\n        position: \"absolute\",\n        left:\n          stepContext.arrowX != null ? `${stepContext.arrowX}px` : undefined,\n        top: stepContext.arrowY != null ? `${stepContext.arrowY}px` : undefined,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\",\n        }[stepContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: \"rotate(180deg)\",\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\",\n        }[stepContext.placedSide],\n        visibility: stepContext.shouldHideArrow ? \"hidden\" : undefined,\n      }}\n    >\n      <svg\n        viewBox=\"0 0 30 10\"\n        preserveAspectRatio=\"none\"\n        width={width}\n        height={height}\n        {...arrowProps}\n        className={cn(\"block fill-popover stroke-border\", className)}\n      >\n        {asChild ? children : <polygon points=\"0,0 30,0 15,10\" />}\n      </svg>\n    </span>\n  );\n}\n\nexport {\n  TourRoot as Root,\n  TourStep as Step,\n  TourOverlay as Overlay,\n  TourHeader as Header,\n  TourTitle as Title,\n  TourDescription as Description,\n  TourFooter as Footer,\n  TourClose as Close,\n  TourStepCounter as StepCounter,\n  TourPrev as Prev,\n  TourNext as Next,\n  TourSkip as Skip,\n  TourArrow as Arrow,\n  //\n  TourRoot as Tour,\n  TourStep,\n  TourOverlay,\n  TourHeader,\n  TourTitle,\n  TourDescription,\n  TourFooter,\n  TourClose,\n  TourStepCounter,\n  TourPrev,\n  TourNext,\n  TourSkip,\n  TourArrow,\n  //\n  type TourRootProps as TourProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}