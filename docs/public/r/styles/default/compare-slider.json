{
  "name": "compare-slider",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/compare-slider.tsx",
      "content": "\"use client\";\n\nimport { GripVerticalIcon } from \"lucide-react\";\nimport {\n  type MotionValue,\n  motion,\n  useMotionValue,\n  useSpring,\n  useTransform,\n} from \"motion/react\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"CompareSlider\";\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\ninterface StoreState {\n  value: number;\n  isDragging: boolean;\n  mode: \"hover\" | \"drag\";\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  updateValue: (value: number) => void;\n  notify: () => void;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface CompareSliderContextValue {\n  motionSliderPosition: MotionValue<number>;\n  mode: \"hover\" | \"drag\";\n}\n\nconst CompareSliderContext =\n  React.createContext<CompareSliderContextValue | null>(null);\n\nfunction useCompareSliderContext(consumerName: string) {\n  const context = React.useContext(CompareSliderContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface CompareSliderRootProps extends React.ComponentProps<\"div\"> {\n  value?: number;\n  defaultValue?: number;\n  onValueChange?: (value: number) => void;\n  mode?: \"hover\" | \"drag\";\n  onDragStart?: () => void;\n  onDragEnd?: () => void;\n}\n\nfunction CompareSliderRoot(props: CompareSliderRootProps) {\n  const {\n    value: valueProp,\n    defaultValue = 50,\n    onValueChange,\n    ...rootProps\n  } = props;\n\n  const stateRef = useLazyRef<StoreState>(() => ({\n    value: clamp(valueProp ?? defaultValue, 0, 100),\n    isDragging: false,\n    mode: props.mode ?? \"drag\",\n  }));\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const onValueChangeRef = useAsRef(onValueChange);\n\n  const store = React.useMemo<Store>(() => {\n    return {\n      subscribe: (cb) => {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current.delete(cb);\n      },\n      getState: () => stateRef.current,\n      setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => {\n        if (Object.is(stateRef.current[key], value)) return;\n        stateRef.current[key] = value;\n\n        if (key === \"value\") {\n          onValueChangeRef.current?.(value as number);\n        }\n\n        store.notify();\n      },\n      updateValue: (newValue: number) => {\n        const clampedValue = clamp(newValue, 0, 100);\n        if (Object.is(stateRef.current.value, clampedValue)) return;\n        stateRef.current.value = clampedValue;\n        onValueChangeRef.current?.(clampedValue);\n        store.notify();\n      },\n      notify: () => {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      },\n    };\n  }, [listenersRef, stateRef, onValueChangeRef]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (valueProp !== undefined) {\n      const clampedValue = clamp(valueProp, 0, 100);\n      if (!Object.is(stateRef.current.value, clampedValue)) {\n        stateRef.current.value = clampedValue;\n        store.notify();\n      }\n    }\n  }, [valueProp, store]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (props.mode !== undefined) {\n      stateRef.current.mode = props.mode;\n    }\n  }, [props.mode]);\n\n  return (\n    <StoreContext.Provider value={store}>\n      <CompareSliderRootImpl {...rootProps} mode={props.mode ?? \"drag\"} />\n    </StoreContext.Provider>\n  );\n}\n\nfunction CompareSliderRootImpl(\n  props: Omit<\n    CompareSliderRootProps,\n    \"value\" | \"defaultValue\" | \"onValueChange\"\n  >,\n) {\n  const {\n    mode = \"drag\",\n    onDragStart,\n    onDragEnd,\n    className,\n    children,\n    ref,\n    ...rootProps\n  } = props;\n\n  const store = useStoreContext(ROOT_NAME);\n  const value = useStore((state) => state.value);\n  const motionValue = useMotionValue(value);\n  const motionSliderPosition = useSpring(motionValue, {\n    bounce: 0,\n    duration: 0,\n  });\n\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const isDraggingRef = React.useRef(false);\n  const onDragStartRef = useAsRef(onDragStart);\n  const onDragEndRef = useAsRef(onDragEnd);\n\n  // Subscribe to store changes to update motion value\n  React.useEffect(() => {\n    const unsubscribe = store.subscribe(() => {\n      const currentValue = store.getState().value;\n      if (currentValue !== motionValue.get()) {\n        motionValue.set(currentValue);\n      }\n    });\n    return unsubscribe;\n  }, [store, motionValue]);\n\n  const handleDrag = React.useCallback(\n    (domRect: DOMRect, clientX: number) => {\n      if (!isDraggingRef.current && mode === \"drag\") {\n        return;\n      }\n\n      const x = clientX - domRect.left;\n      const percentage = clamp((x / domRect.width) * 100, 0, 100);\n\n      motionValue.set(percentage);\n      store.updateValue(percentage);\n    },\n    [mode, motionValue, store],\n  );\n\n  const handleMouseDrag = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      if (!containerRef.current) return;\n      const containerRect = containerRef.current.getBoundingClientRect();\n      handleDrag(containerRect, event.clientX);\n    },\n    [handleDrag],\n  );\n\n  const handleTouchDrag = React.useCallback(\n    (event: React.TouchEvent<HTMLDivElement>) => {\n      if (!containerRef.current) return;\n      const containerRect = containerRef.current.getBoundingClientRect();\n      const touches = Array.from(event.touches);\n      handleDrag(containerRect, touches.at(0)?.clientX ?? 0);\n    },\n    [handleDrag],\n  );\n\n  const handleDragStart = React.useCallback(() => {\n    if (mode === \"drag\") {\n      isDraggingRef.current = true;\n      store.setState(\"isDragging\", true);\n      onDragStartRef.current?.();\n    }\n  }, [mode, store, onDragStartRef]);\n\n  const handleDragEnd = React.useCallback(() => {\n    if (mode === \"drag\") {\n      isDraggingRef.current = false;\n      store.setState(\"isDragging\", false);\n      onDragEndRef.current?.();\n    }\n  }, [mode, store, onDragEndRef]);\n\n  const contextValue = React.useMemo<CompareSliderContextValue>(\n    () => ({\n      motionSliderPosition,\n      mode,\n    }),\n    [motionSliderPosition, mode],\n  );\n\n  return (\n    <CompareSliderContext.Provider value={contextValue}>\n      <div\n        ref={useComposedRefs(containerRef, ref)}\n        aria-label=\"Comparison slider\"\n        aria-valuemax={100}\n        aria-valuemin={0}\n        aria-valuenow={value}\n        className={cn(\n          \"relative isolate w-full select-none overflow-hidden\",\n          className,\n        )}\n        onMouseDown={handleDragStart}\n        onMouseLeave={handleDragEnd}\n        onMouseMove={handleMouseDrag}\n        onMouseUp={handleDragEnd}\n        onTouchEnd={handleDragEnd}\n        onTouchMove={handleTouchDrag}\n        onTouchStart={handleDragStart}\n        role=\"slider\"\n        tabIndex={0}\n        {...rootProps}\n      >\n        {children}\n      </div>\n    </CompareSliderContext.Provider>\n  );\n}\n\ninterface CompareSliderBeforeProps extends React.ComponentProps<\"div\"> {\n  label?: string;\n}\n\nfunction CompareSliderBefore(props: CompareSliderBeforeProps) {\n  const { className, children, label, ref, ...beforeProps } = props;\n  const { motionSliderPosition } = useCompareSliderContext(\n    \"CompareSliderBefore\",\n  );\n\n  const leftClipPath = useTransform(\n    motionSliderPosition,\n    (value) => `inset(0 0 0 ${value}%)`,\n  );\n\n  const {\n    onDrag: _onDrag,\n    onDragStart: _onDragStart,\n    onDragEnd: _onDragEnd,\n    ...restProps\n  } = beforeProps as React.ComponentProps<typeof motion.div> & {\n    onDrag?: unknown;\n    onDragStart?: unknown;\n    onDragEnd?: unknown;\n  };\n\n  return (\n    <motion.div\n      ref={ref}\n      aria-hidden=\"true\"\n      className={cn(\"absolute inset-0 h-full w-full object-cover\", className)}\n      role=\"img\"\n      style={{\n        clipPath: leftClipPath,\n      }}\n      {...restProps}\n    >\n      {children}\n      {label && <CompareSliderLabel side=\"before\">{label}</CompareSliderLabel>}\n    </motion.div>\n  );\n}\n\ninterface CompareSliderAfterProps extends React.ComponentProps<\"div\"> {\n  label?: string;\n}\n\nfunction CompareSliderAfter(props: CompareSliderAfterProps) {\n  const { className, children, label, ref, ...afterProps } = props;\n  const { motionSliderPosition } =\n    useCompareSliderContext(\"CompareSliderAfter\");\n\n  const rightClipPath = useTransform(\n    motionSliderPosition,\n    (value) => `inset(0 ${100 - value}% 0 0)`,\n  );\n\n  const {\n    onDrag: _onDrag,\n    onDragStart: _onDragStart,\n    onDragEnd: _onDragEnd,\n    ...restProps\n  } = afterProps as React.ComponentProps<typeof motion.div> & {\n    onDrag?: unknown;\n    onDragStart?: unknown;\n    onDragEnd?: unknown;\n  };\n\n  return (\n    <motion.div\n      ref={ref}\n      aria-hidden=\"true\"\n      className={cn(\"absolute inset-0 h-full w-full object-cover\", className)}\n      role=\"img\"\n      style={{\n        clipPath: rightClipPath,\n      }}\n      {...restProps}\n    >\n      {children}\n      {label && <CompareSliderLabel side=\"after\">{label}</CompareSliderLabel>}\n    </motion.div>\n  );\n}\n\ninterface CompareSliderHandleProps extends React.ComponentProps<\"div\"> {\n  children?: React.ReactNode;\n}\n\nfunction CompareSliderHandle(props: CompareSliderHandleProps) {\n  const { className, children, ref, ...handleProps } = props;\n  const { motionSliderPosition, mode } = useCompareSliderContext(\n    \"CompareSliderHandle\",\n  );\n\n  const left = useTransform(motionSliderPosition, (value) => `${value}%`);\n\n  const {\n    onDrag: _onDrag,\n    onDragStart: _onDragStart,\n    onDragEnd: _onDragEnd,\n    ...restProps\n  } = handleProps as React.ComponentProps<typeof motion.div> & {\n    onDrag?: unknown;\n    onDragStart?: unknown;\n    onDragEnd?: unknown;\n  };\n\n  return (\n    <motion.div\n      ref={ref}\n      aria-hidden=\"true\"\n      className={cn(\n        \"-translate-x-1/2 absolute top-0 z-50 flex h-full w-10 items-center justify-center\",\n        mode === \"drag\" && \"cursor-grab active:cursor-grabbing\",\n        className,\n      )}\n      role=\"presentation\"\n      style={{ left }}\n      {...restProps}\n    >\n      {children ?? (\n        <>\n          <div className=\"-translate-x-1/2 absolute left-1/2 h-full w-1 bg-background\" />\n          {mode === \"drag\" && (\n            <div className=\"z-50 flex items-center justify-center rounded-sm bg-background px-0.5 py-1\">\n              <GripVerticalIcon className=\"h-4 w-4 select-none text-muted-foreground\" />\n            </div>\n          )}\n        </>\n      )}\n    </motion.div>\n  );\n}\n\ninterface CompareSliderLabelProps extends React.ComponentProps<\"div\"> {\n  side?: \"before\" | \"after\";\n}\n\nfunction CompareSliderLabel(props: CompareSliderLabelProps) {\n  const { className, children, side, ref, ...labelProps } = props;\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"absolute z-20 rounded-md border border-border bg-background/80 px-3 py-1.5 font-medium text-sm backdrop-blur-sm\",\n        side === \"before\" ? \"top-2 left-2\" : \"top-2 right-2\",\n        className,\n      )}\n      {...labelProps}\n    >\n      {children}\n    </div>\n  );\n}\n\nexport {\n  CompareSliderRoot as Root,\n  CompareSliderAfter as After,\n  CompareSliderBefore as Before,\n  CompareSliderHandle as Handle,\n  CompareSliderLabel as Label,\n  //\n  CompareSliderRoot as CompareSlider,\n  CompareSliderAfter,\n  CompareSliderBefore,\n  CompareSliderHandle,\n  CompareSliderLabel,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}