{
  "name": "compare-slider",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/compare-slider.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport {\r\n  ChevronDownIcon,\r\n  ChevronLeftIcon,\r\n  ChevronRightIcon,\r\n  ChevronUpIcon,\r\n} from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"CompareSlider\";\r\nconst BEFORE_NAME = \"CompareSliderBefore\";\r\nconst AFTER_NAME = \"CompareSliderAfter\";\r\nconst LABEL_NAME = \"CompareSliderLabel\";\r\nconst HANDLE_NAME = \"CompareSliderHandle\";\r\n\r\nconst PAGE_KEYS = [\"PageUp\", \"PageDown\"];\r\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\r\n\r\ntype Interaction = \"hover\" | \"drag\";\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootImplElement = React.ComponentRef<typeof CompareSliderRootImpl>;\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\nfunction useAsRef<T>(props: T) {\r\n  const ref = React.useRef<T>(props);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = props;\r\n  });\r\n\r\n  return ref;\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nfunction clamp(value: number, min: number, max: number): number {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\ninterface StoreState {\r\n  value: number;\r\n  isDragging: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface CompareSliderContextValue {\r\n  interaction: Interaction;\r\n  orientation: Orientation;\r\n}\r\n\r\nconst CompareSliderContext =\r\n  React.createContext<CompareSliderContextValue | null>(null);\r\n\r\nfunction useCompareSliderContext(consumerName: string) {\r\n  const context = React.useContext(CompareSliderContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface CompareSliderRootProps extends DivProps {\r\n  value?: number;\r\n  defaultValue?: number;\r\n  onValueChange?: (value: number) => void;\r\n  step?: number;\r\n  interaction?: Interaction;\r\n  orientation?: Orientation;\r\n}\r\n\r\nfunction CompareSliderRoot(props: CompareSliderRootProps) {\r\n  const { value, defaultValue = 50, onValueChange, ...rootProps } = props;\r\n\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    value: clamp(value ?? defaultValue, 0, 100),\r\n    isDragging: false,\r\n  }));\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const onValueChangeRef = useAsRef(onValueChange);\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n        stateRef.current[key] = value;\r\n\r\n        if (key === \"value\") {\r\n          onValueChangeRef.current?.(value as number);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, onValueChangeRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (value !== undefined) {\r\n      store.setState(\"value\", clamp(value, 0, 100));\r\n    }\r\n  }, [value, store]);\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <CompareSliderRootImpl {...rootProps} />\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nfunction CompareSliderRootImpl(\r\n  props: Omit<\r\n    CompareSliderRootProps,\r\n    \"value\" | \"defaultValue\" | \"onValueChange\"\r\n  >,\r\n) {\r\n  const {\r\n    step = 1,\r\n    interaction = \"drag\",\r\n    orientation = \"horizontal\",\r\n    className,\r\n    children,\r\n    ref,\r\n    onPointerMove: onPointerMoveProp,\r\n    onPointerUp: onPointerUpProp,\r\n    onPointerDown: onPointerDownProp,\r\n    onKeyDown: onKeyDownProp,\r\n    asChild,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(ROOT_NAME);\r\n  const value = useStore((state) => state.value);\r\n\r\n  const containerRef = React.useRef<RootImplElement>(null);\r\n  const composedRef = useComposedRefs(ref, containerRef);\r\n  const isDraggingRef = React.useRef(false);\r\n\r\n  const propsRef = useAsRef({\r\n    onPointerMove: onPointerMoveProp,\r\n    onPointerUp: onPointerUpProp,\r\n    onPointerDown: onPointerDownProp,\r\n    onKeyDown: onKeyDownProp,\r\n    interaction,\r\n    orientation,\r\n    step,\r\n  });\r\n\r\n  const onPointerMove = React.useCallback(\r\n    (event: React.PointerEvent<RootImplElement>) => {\r\n      if (!isDraggingRef.current && propsRef.current.interaction === \"drag\") {\r\n        return;\r\n      }\r\n      if (!containerRef.current) return;\r\n\r\n      propsRef.current.onPointerMove?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const containerRect = containerRef.current.getBoundingClientRect();\r\n      const isVertical = propsRef.current.orientation === \"vertical\";\r\n      const position = isVertical\r\n        ? event.clientY - containerRect.top\r\n        : event.clientX - containerRect.left;\r\n      const size = isVertical ? containerRect.height : containerRect.width;\r\n      const percentage = clamp((position / size) * 100, 0, 100);\r\n\r\n      store.setState(\"value\", percentage);\r\n    },\r\n    [propsRef, store],\r\n  );\r\n\r\n  const onPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<RootImplElement>) => {\r\n      if (propsRef.current.interaction !== \"drag\") return;\r\n\r\n      propsRef.current.onPointerDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      event.currentTarget.setPointerCapture(event.pointerId);\r\n      isDraggingRef.current = true;\r\n      store.setState(\"isDragging\", true);\r\n    },\r\n    [store, propsRef],\r\n  );\r\n\r\n  const onPointerUp = React.useCallback(\r\n    (event: React.PointerEvent<RootImplElement>) => {\r\n      if (propsRef.current.interaction !== \"drag\") return;\r\n\r\n      propsRef.current.onPointerUp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      event.currentTarget.releasePointerCapture(event.pointerId);\r\n      isDraggingRef.current = false;\r\n      store.setState(\"isDragging\", false);\r\n    },\r\n    [store, propsRef],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<RootImplElement>) => {\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const currentValue = store.getState().value;\r\n      const isVertical = propsRef.current.orientation === \"vertical\";\r\n\r\n      if (event.key === \"Home\") {\r\n        event.preventDefault();\r\n        store.setState(\"value\", 0);\r\n      } else if (event.key === \"End\") {\r\n        event.preventDefault();\r\n        store.setState(\"value\", 100);\r\n      } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\r\n        event.preventDefault();\r\n\r\n        const isPageKey = PAGE_KEYS.includes(event.key);\r\n        const isSkipKey =\r\n          isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\r\n        const multiplier = isSkipKey ? 10 : 1;\r\n\r\n        let direction = 0;\r\n        if (isVertical) {\r\n          const isDecreaseKey = [\"ArrowUp\", \"PageUp\"].includes(event.key);\r\n          direction = isDecreaseKey ? -1 : 1;\r\n        } else {\r\n          const isDecreaseKey = [\"ArrowLeft\", \"PageUp\"].includes(event.key);\r\n          direction = isDecreaseKey ? -1 : 1;\r\n        }\r\n\r\n        const stepInDirection = propsRef.current.step * multiplier * direction;\r\n        const newValue = clamp(currentValue + stepInDirection, 0, 100);\r\n        store.setState(\"value\", newValue);\r\n      }\r\n    },\r\n    [store, propsRef],\r\n  );\r\n\r\n  const contextValue = React.useMemo<CompareSliderContextValue>(\r\n    () => ({\r\n      interaction,\r\n      orientation,\r\n    }),\r\n    [interaction, orientation],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <CompareSliderContext.Provider value={contextValue}>\r\n      <RootPrimitive\r\n        role=\"slider\"\r\n        aria-orientation={orientation}\r\n        aria-valuemax={100}\r\n        aria-valuemin={0}\r\n        aria-valuenow={value}\r\n        data-slot=\"compare-slider\"\r\n        data-orientation={orientation}\r\n        {...rootProps}\r\n        ref={composedRef}\r\n        tabIndex={0}\r\n        className={cn(\r\n          \"relative isolate select-none overflow-hidden outline-none transition-all focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50\",\r\n          orientation === \"horizontal\" ? \"w-full\" : \"h-full\",\r\n          className,\r\n        )}\r\n        onPointerDown={onPointerDown}\r\n        onPointerMove={onPointerMove}\r\n        onPointerUp={onPointerUp}\r\n        onPointerCancel={onPointerUp}\r\n        onKeyDown={onKeyDown}\r\n      >\r\n        {children}\r\n      </RootPrimitive>\r\n    </CompareSliderContext.Provider>\r\n  );\r\n}\r\n\r\ninterface CompareSliderBeforeProps extends DivProps {\r\n  label?: string;\r\n}\r\n\r\nfunction CompareSliderBefore(props: CompareSliderBeforeProps) {\r\n  const { className, children, style, label, asChild, ref, ...beforeProps } =\r\n    props;\r\n\r\n  const value = useStore((state) => state.value);\r\n  const { orientation } = useCompareSliderContext(BEFORE_NAME);\r\n\r\n  const labelId = React.useId();\r\n\r\n  const isVertical = orientation === \"vertical\";\r\n  const clipPath = isVertical\r\n    ? `inset(${value}% 0 0 0)`\r\n    : `inset(0 0 0 ${value}%)`;\r\n\r\n  const BeforePrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <BeforePrimitive\r\n      role=\"img\"\r\n      aria-labelledby={label ? labelId : undefined}\r\n      aria-hidden={label ? undefined : \"true\"}\r\n      data-slot=\"compare-slider-before\"\r\n      data-orientation={orientation}\r\n      {...beforeProps}\r\n      ref={ref}\r\n      className={cn(\"absolute inset-0 h-full w-full object-cover\", className)}\r\n      style={{\r\n        clipPath,\r\n        ...style,\r\n      }}\r\n    >\r\n      {children}\r\n      {label && (\r\n        <CompareSliderLabel id={labelId} side=\"before\">\r\n          {label}\r\n        </CompareSliderLabel>\r\n      )}\r\n    </BeforePrimitive>\r\n  );\r\n}\r\n\r\ninterface CompareSliderAfterProps extends DivProps {\r\n  label?: string;\r\n}\r\n\r\nfunction CompareSliderAfter(props: CompareSliderAfterProps) {\r\n  const { className, children, style, label, asChild, ref, ...afterProps } =\r\n    props;\r\n\r\n  const value = useStore((state) => state.value);\r\n  const { orientation } = useCompareSliderContext(AFTER_NAME);\r\n\r\n  const labelId = React.useId();\r\n\r\n  const isVertical = orientation === \"vertical\";\r\n  const clipPath = isVertical\r\n    ? `inset(0 0 ${100 - value}% 0)`\r\n    : `inset(0 ${100 - value}% 0 0)`;\r\n\r\n  const AfterPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <AfterPrimitive\r\n      role=\"img\"\r\n      aria-labelledby={label ? labelId : undefined}\r\n      aria-hidden={label ? undefined : \"true\"}\r\n      data-slot=\"compare-slider-after\"\r\n      data-orientation={orientation}\r\n      {...afterProps}\r\n      ref={ref}\r\n      className={cn(\"absolute inset-0 h-full w-full object-cover\", className)}\r\n      style={{\r\n        clipPath,\r\n        ...style,\r\n      }}\r\n    >\r\n      {children}\r\n      {label && (\r\n        <CompareSliderLabel id={labelId} side=\"after\">\r\n          {label}\r\n        </CompareSliderLabel>\r\n      )}\r\n    </AfterPrimitive>\r\n  );\r\n}\r\n\r\nfunction CompareSliderHandle(props: DivProps) {\r\n  const { className, children, style, asChild, ref, ...handleProps } = props;\r\n\r\n  const value = useStore((state) => state.value);\r\n  const { interaction, orientation } = useCompareSliderContext(HANDLE_NAME);\r\n\r\n  const isVertical = orientation === \"vertical\";\r\n\r\n  const HandlePrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <HandlePrimitive\r\n      role=\"presentation\"\r\n      aria-hidden=\"true\"\r\n      data-slot=\"compare-slider-handle\"\r\n      data-orientation={orientation}\r\n      {...handleProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"absolute z-50 flex items-center justify-center\",\r\n        isVertical\r\n          ? \"-translate-y-1/2 left-0 h-10 w-full\"\r\n          : \"-translate-x-1/2 top-0 h-full w-10\",\r\n        interaction === \"drag\" && \"cursor-grab active:cursor-grabbing\",\r\n        className,\r\n      )}\r\n      style={{\r\n        [isVertical ? \"top\" : \"left\"]: `${value}%`,\r\n        ...style,\r\n      }}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <div\r\n            className={cn(\r\n              \"absolute bg-background\",\r\n              isVertical\r\n                ? \"-translate-y-1/2 top-1/2 h-1 w-full\"\r\n                : \"-translate-x-1/2 left-1/2 h-full w-1\",\r\n            )}\r\n          />\r\n          {interaction === \"drag\" && (\r\n            <div className=\"z-50 flex aspect-square size-11 shrink-0 items-center justify-center rounded-full bg-background p-2 [&_svg]:size-4 [&_svg]:select-none [&_svg]:stroke-3 [&_svg]:text-muted-foreground\">\r\n              {isVertical ? (\r\n                <div className=\"flex flex-col items-center\">\r\n                  <ChevronUpIcon />\r\n                  <ChevronDownIcon />\r\n                </div>\r\n              ) : (\r\n                <div className=\"flex items-center\">\r\n                  <ChevronLeftIcon />\r\n                  <ChevronRightIcon />\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n        </>\r\n      )}\r\n    </HandlePrimitive>\r\n  );\r\n}\r\n\r\ninterface CompareSliderLabelProps extends DivProps {\r\n  side?: \"before\" | \"after\";\r\n}\r\n\r\nfunction CompareSliderLabel(props: CompareSliderLabelProps) {\r\n  const { className, children, side, asChild, ref, ...labelProps } = props;\r\n\r\n  const { orientation } = useCompareSliderContext(LABEL_NAME);\r\n  const isVertical = orientation === \"vertical\";\r\n\r\n  const LabelPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <LabelPrimitive\r\n      ref={ref}\r\n      data-slot=\"compare-slider-label\"\r\n      className={cn(\r\n        \"absolute z-20 rounded-md border border-border bg-background/80 px-3 py-1.5 font-medium text-sm backdrop-blur-sm\",\r\n        isVertical\r\n          ? side === \"before\"\r\n            ? \"top-2 left-2\"\r\n            : \"bottom-2 left-2\"\r\n          : side === \"before\"\r\n            ? \"top-2 left-2\"\r\n            : \"top-2 right-2\",\r\n        className,\r\n      )}\r\n      {...labelProps}\r\n    >\r\n      {children}\r\n    </LabelPrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  CompareSliderRoot as Root,\r\n  CompareSliderAfter as After,\r\n  CompareSliderBefore as Before,\r\n  CompareSliderHandle as Handle,\r\n  CompareSliderLabel as Label,\r\n  //\r\n  CompareSliderRoot as CompareSlider,\r\n  CompareSliderAfter,\r\n  CompareSliderBefore,\r\n  CompareSliderHandle,\r\n  CompareSliderLabel,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}