{
  "name": "angle-slider",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/angle-slider.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\r\n\r\nconst ROOT_NAME = \"AngleSlider\";\r\nconst THUMB_NAME = \"AngleSliderThumb\";\r\n\r\nconst PAGE_KEYS = [\"PageUp\", \"PageDown\"];\r\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof AngleSliderRoot>;\r\ntype ThumbElement = React.ComponentRef<typeof AngleSliderThumb>;\r\n\r\nfunction clamp(value: number, [min, max]: [number, number]) {\r\n  return Math.min(max, Math.max(min, value));\r\n}\r\n\r\nfunction getNextSortedValues(\r\n  prevValues: number[] = [],\r\n  nextValue: number,\r\n  atIndex: number,\r\n) {\r\n  const nextValues = [...prevValues];\r\n  nextValues[atIndex] = nextValue;\r\n  return nextValues.sort((a, b) => a - b);\r\n}\r\n\r\nfunction getStepsBetweenValues(values: number[]) {\r\n  return values.slice(0, -1).map((value, index) => {\r\n    const nextValue = values[index + 1];\r\n    return nextValue !== undefined ? nextValue - value : 0;\r\n  });\r\n}\r\n\r\nfunction hasMinStepsBetweenValues(\r\n  values: number[],\r\n  minStepsBetweenValues: number,\r\n) {\r\n  if (minStepsBetweenValues > 0) {\r\n    const stepsBetweenValues = getStepsBetweenValues(values);\r\n    const actualMinStepsBetweenValues =\r\n      stepsBetweenValues.length > 0 ? Math.min(...stepsBetweenValues) : 0;\r\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction getDecimalCount(value: number) {\r\n  return (String(value).split(\".\")[1] ?? \"\").length;\r\n}\r\n\r\nfunction roundValue(value: number, decimalCount: number) {\r\n  const rounder = 10 ** decimalCount;\r\n  return Math.round(value * rounder) / rounder;\r\n}\r\n\r\nfunction getClosestValueIndex(values: number[], nextValue: number) {\r\n  if (values.length === 1) return 0;\r\n  const distances = values.map((value) => Math.abs(value - nextValue));\r\n  const closestDistance = Math.min(...distances);\r\n  return distances.indexOf(closestDistance);\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\ninterface ThumbData {\r\n  id: string;\r\n  element: ThumbElement;\r\n  index: number;\r\n  value: number;\r\n}\r\n\r\ninterface StoreState {\r\n  values: number[];\r\n  thumbs: Map<number, ThumbData>;\r\n  valueIndexToChange: number;\r\n  min: number;\r\n  max: number;\r\n  step: number;\r\n  size: number;\r\n  thickness: number;\r\n  startAngle: number;\r\n  endAngle: number;\r\n  minStepsBetweenThumbs: number;\r\n  disabled: boolean;\r\n  inverted: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n  addThumb: (index: number, thumbData: ThumbData) => void;\r\n  removeThumb: (index: number) => void;\r\n  updateValue: (\r\n    value: number,\r\n    atIndex: number,\r\n    options?: { commit?: boolean },\r\n  ) => void;\r\n  getValueFromPointer: (\r\n    clientX: number,\r\n    clientY: number,\r\n    rect: DOMRect,\r\n  ) => number;\r\n  getAngleFromValue: (value: number) => number;\r\n  getPositionFromAngle: (angle: number) => { x: number; y: number };\r\n}\r\n\r\nfunction createStore(\r\n  listenersRef: React.RefObject<Set<() => void>>,\r\n  stateRef: React.RefObject<StoreState>,\r\n  onValueChange?: (value: number[]) => void,\r\n  onValueCommit?: (value: number[]) => void,\r\n): Store {\r\n  const store: Store = {\r\n    subscribe: (cb) => {\r\n      if (listenersRef.current) {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current?.delete(cb);\r\n      }\r\n      return () => {};\r\n    },\r\n    getState: () =>\r\n      stateRef.current ?? {\r\n        values: [0],\r\n        thumbs: new Map(),\r\n        valueIndexToChange: 0,\r\n        min: 0,\r\n        max: 100,\r\n        step: 1,\r\n        minStepsBetweenThumbs: 0,\r\n        size: 80,\r\n        thickness: 8,\r\n        startAngle: -90,\r\n        endAngle: 270,\r\n        disabled: false,\r\n        inverted: false,\r\n      },\r\n    setState: (key, value) => {\r\n      const state = stateRef.current;\r\n      if (!state || Object.is(state[key], value)) return;\r\n\r\n      if (key === \"values\" && Array.isArray(value)) {\r\n        const hasChanged = String(state.values) !== String(value);\r\n        state.values = value;\r\n        if (hasChanged) {\r\n          onValueChange?.(value);\r\n        }\r\n      } else {\r\n        state[key] = value;\r\n      }\r\n\r\n      store.notify();\r\n    },\r\n    addThumb: (index, thumbData) => {\r\n      const state = stateRef.current;\r\n      if (state) {\r\n        state.thumbs.set(index, thumbData);\r\n        store.notify();\r\n      }\r\n    },\r\n    removeThumb: (index) => {\r\n      const state = stateRef.current;\r\n      if (state) {\r\n        state.thumbs.delete(index);\r\n        store.notify();\r\n      }\r\n    },\r\n    updateValue: (value, atIndex, { commit = false } = {}) => {\r\n      const state = stateRef.current;\r\n      if (!state) return;\r\n\r\n      const { min, max, step, minStepsBetweenThumbs } = state;\r\n      const decimalCount = getDecimalCount(step);\r\n      const snapToStep = roundValue(\r\n        Math.round((value - min) / step) * step + min,\r\n        decimalCount,\r\n      );\r\n      const nextValue = clamp(snapToStep, [min, max]);\r\n\r\n      const nextValues = getNextSortedValues(state.values, nextValue, atIndex);\r\n\r\n      if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\r\n        state.valueIndexToChange = nextValues.indexOf(nextValue);\r\n        const hasChanged = String(nextValues) !== String(state.values);\r\n\r\n        if (hasChanged) {\r\n          state.values = nextValues;\r\n          onValueChange?.(nextValues);\r\n          if (commit) onValueCommit?.(nextValues);\r\n          store.notify();\r\n        }\r\n      }\r\n    },\r\n    getValueFromPointer: (clientX, clientY, rect) => {\r\n      const state = stateRef.current;\r\n      if (!state) return 0;\r\n\r\n      const { min, max, inverted, startAngle, endAngle } = state;\r\n      const centerX = rect.left + rect.width / 2;\r\n      const centerY = rect.top + rect.height / 2;\r\n\r\n      const deltaX = clientX - centerX;\r\n      const deltaY = clientY - centerY;\r\n      let angle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;\r\n\r\n      if (angle < 0) angle += 360;\r\n\r\n      angle = (angle - startAngle + 360) % 360;\r\n\r\n      const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n\r\n      let percent = angle / totalAngle;\r\n      if (inverted) percent = 1 - percent;\r\n\r\n      return min + percent * (max - min);\r\n    },\r\n    getAngleFromValue: (value) => {\r\n      const state = stateRef.current;\r\n      if (!state) return 0;\r\n\r\n      const { min, max, inverted, startAngle, endAngle } = state;\r\n      let percent = (value - min) / (max - min);\r\n      if (inverted) percent = 1 - percent;\r\n\r\n      const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n      const angle = startAngle + percent * totalAngle;\r\n\r\n      return angle;\r\n    },\r\n    getPositionFromAngle: (angle) => {\r\n      const state = stateRef.current;\r\n      if (!state) return { x: 0, y: 0 };\r\n\r\n      const { size } = state;\r\n      const radians = (angle * Math.PI) / 180;\r\n\r\n      return {\r\n        x: size * Math.cos(radians),\r\n        y: size * Math.sin(radians),\r\n      };\r\n    },\r\n    notify: () => {\r\n      if (listenersRef.current) {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      }\r\n    },\r\n  };\r\n\r\n  return store;\r\n}\r\n\r\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\r\n\r\nfunction useDirection(dirProp?: Direction): Direction {\r\n  const contextDir = React.useContext(DirectionContext);\r\n  return dirProp ?? contextDir ?? \"ltr\";\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface SliderContextValue {\r\n  dir: Direction;\r\n  name?: string;\r\n  form?: string;\r\n}\r\n\r\nconst SliderContext = React.createContext<SliderContextValue | null>(null);\r\n\r\nfunction useSliderContext(consumerName: string) {\r\n  const context = React.useContext(SliderContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface AngleSliderRootProps extends Omit<DivProps, \"defaultValue\"> {\r\n  value?: number[];\r\n  defaultValue?: number[];\r\n  onValueChange?: (value: number[]) => void;\r\n  onValueCommit?: (value: number[]) => void;\r\n  min?: number;\r\n  max?: number;\r\n  step?: number;\r\n  minStepsBetweenThumbs?: number;\r\n  size?: number;\r\n  thickness?: number;\r\n  startAngle?: number;\r\n  endAngle?: number;\r\n  dir?: Direction;\r\n  form?: string;\r\n  name?: string;\r\n  disabled?: boolean;\r\n  inverted?: boolean;\r\n}\r\n\r\nfunction AngleSliderRoot(props: AngleSliderRootProps) {\r\n  const {\r\n    value,\r\n    defaultValue = [0],\r\n    onValueChange,\r\n    onValueCommit,\r\n    min = 0,\r\n    max = 100,\r\n    step = 1,\r\n    minStepsBetweenThumbs = 0,\r\n    size = 60,\r\n    thickness = 8,\r\n    startAngle = -90,\r\n    endAngle = 270,\r\n    dir: dirProp,\r\n    form,\r\n    name,\r\n    disabled = false,\r\n    inverted = false,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    values: value ?? defaultValue,\r\n    thumbs: new Map(),\r\n    valueIndexToChange: 0,\r\n    min,\r\n    max,\r\n    step,\r\n    minStepsBetweenThumbs,\r\n    disabled,\r\n    inverted,\r\n    size,\r\n    thickness,\r\n    startAngle,\r\n    endAngle,\r\n  }));\r\n\r\n  const store = React.useMemo(\r\n    () => createStore(listenersRef, stateRef, onValueChange, onValueCommit),\r\n    [listenersRef, stateRef, onValueChange, onValueCommit],\r\n  );\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (value !== undefined) {\r\n      store.setState(\"values\", value);\r\n    }\r\n  }, [value, store]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const currentState = store.getState();\r\n\r\n    if (currentState.min !== min) {\r\n      store.setState(\"min\", min);\r\n    }\r\n    if (currentState.max !== max) {\r\n      store.setState(\"max\", max);\r\n    }\r\n    if (currentState.step !== step) {\r\n      store.setState(\"step\", step);\r\n    }\r\n    if (currentState.minStepsBetweenThumbs !== minStepsBetweenThumbs) {\r\n      store.setState(\"minStepsBetweenThumbs\", minStepsBetweenThumbs);\r\n    }\r\n    if (currentState.size !== size) {\r\n      store.setState(\"size\", size);\r\n    }\r\n    if (currentState.thickness !== thickness) {\r\n      store.setState(\"thickness\", thickness);\r\n    }\r\n    if (currentState.startAngle !== startAngle) {\r\n      store.setState(\"startAngle\", startAngle);\r\n    }\r\n    if (currentState.endAngle !== endAngle) {\r\n      store.setState(\"endAngle\", endAngle);\r\n    }\r\n    if (currentState.disabled !== disabled) {\r\n      store.setState(\"disabled\", disabled);\r\n    }\r\n    if (currentState.inverted !== inverted) {\r\n      store.setState(\"inverted\", inverted);\r\n    }\r\n  }, [\r\n    store,\r\n    min,\r\n    max,\r\n    step,\r\n    minStepsBetweenThumbs,\r\n    size,\r\n    thickness,\r\n    startAngle,\r\n    endAngle,\r\n    disabled,\r\n    inverted,\r\n  ]);\r\n\r\n  const dir = useDirection(dirProp);\r\n\r\n  const [sliderElement, setSliderElement] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, setSliderElement);\r\n  const valuesBeforeSlideStartRef = React.useRef(value ?? defaultValue);\r\n\r\n  const contextValue = React.useMemo<SliderContextValue>(\r\n    () => ({\r\n      dir,\r\n      name,\r\n      form,\r\n    }),\r\n    [dir, name, form],\r\n  );\r\n\r\n  const onSliderStart = React.useCallback(\r\n    (pointerValue: number) => {\r\n      if (disabled) return;\r\n\r\n      const values = store.getState().values;\r\n      const closestIndex = getClosestValueIndex(values, pointerValue);\r\n      store.setState(\"valueIndexToChange\", closestIndex);\r\n      store.updateValue(pointerValue, closestIndex);\r\n    },\r\n    [store, disabled],\r\n  );\r\n\r\n  const onSliderMove = React.useCallback(\r\n    (pointerValue: number) => {\r\n      if (disabled) return;\r\n\r\n      const valueIndexToChange = store.getState().valueIndexToChange;\r\n      store.updateValue(pointerValue, valueIndexToChange);\r\n    },\r\n    [store, disabled],\r\n  );\r\n\r\n  const onSliderEnd = React.useCallback(() => {\r\n    if (disabled) return;\r\n\r\n    const state = store.getState();\r\n    const prevValue =\r\n      valuesBeforeSlideStartRef.current[state.valueIndexToChange];\r\n    const nextValue = state.values[state.valueIndexToChange];\r\n    const hasChanged = nextValue !== prevValue;\r\n\r\n    if (hasChanged) {\r\n      onValueCommit?.(state.values);\r\n    }\r\n  }, [store, disabled, onValueCommit]);\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<RootElement>) => {\r\n      rootProps.onKeyDown?.(event);\r\n      if (event.defaultPrevented || disabled) return;\r\n\r\n      const state = store.getState();\r\n      const { values, valueIndexToChange, min, max, step } = state;\r\n      const currentValue = values[valueIndexToChange] ?? min;\r\n\r\n      if (event.key === \"Home\") {\r\n        event.preventDefault();\r\n        store.updateValue(min, 0, { commit: true });\r\n      } else if (event.key === \"End\") {\r\n        event.preventDefault();\r\n        store.updateValue(max, values.length - 1, { commit: true });\r\n      } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\r\n        event.preventDefault();\r\n\r\n        const isPageKey = PAGE_KEYS.includes(event.key);\r\n        const isSkipKey =\r\n          isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\r\n        const multiplier = isSkipKey ? 10 : 1;\r\n\r\n        let direction = 0;\r\n        const isDecreaseKey = [\"ArrowLeft\", \"ArrowUp\", \"PageUp\"].includes(\r\n          event.key,\r\n        );\r\n        direction = isDecreaseKey ? -1 : 1;\r\n        if (inverted) direction *= -1;\r\n\r\n        const stepInDirection = step * multiplier * direction;\r\n        store.updateValue(currentValue + stepInDirection, valueIndexToChange, {\r\n          commit: true,\r\n        });\r\n      }\r\n    },\r\n    [rootProps.onKeyDown, disabled, store, inverted],\r\n  );\r\n\r\n  const onPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      rootProps.onPointerDown?.(event);\r\n      if (event.defaultPrevented || disabled) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n      target.setPointerCapture(event.pointerId);\r\n      event.preventDefault();\r\n\r\n      if (!disabled) {\r\n        valuesBeforeSlideStartRef.current = store.getState().values;\r\n\r\n        const thumbs = Array.from(store.getState().thumbs.values());\r\n        const clickedThumb = thumbs.find((thumb) =>\r\n          thumb.element.contains(target),\r\n        );\r\n\r\n        if (clickedThumb) {\r\n          clickedThumb.element.focus();\r\n          store.setState(\"valueIndexToChange\", clickedThumb.index);\r\n        } else if (sliderElement) {\r\n          const rect = sliderElement.getBoundingClientRect();\r\n          const pointerValue = store.getValueFromPointer(\r\n            event.clientX,\r\n            event.clientY,\r\n            rect,\r\n          );\r\n          onSliderStart(pointerValue);\r\n        }\r\n      }\r\n    },\r\n    [rootProps.onPointerDown, disabled, store, sliderElement, onSliderStart],\r\n  );\r\n\r\n  const onPointerMove = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      rootProps.onPointerMove?.(event);\r\n      if (event.defaultPrevented || disabled) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n      if (target.hasPointerCapture(event.pointerId) && sliderElement) {\r\n        const rect = sliderElement.getBoundingClientRect();\r\n        const pointerValue = store.getValueFromPointer(\r\n          event.clientX,\r\n          event.clientY,\r\n          rect,\r\n        );\r\n        onSliderMove(pointerValue);\r\n      }\r\n    },\r\n    [rootProps.onPointerMove, disabled, sliderElement, store, onSliderMove],\r\n  );\r\n\r\n  const onPointerUp = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      rootProps.onPointerUp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const target = event.target as RootElement;\r\n      if (target.hasPointerCapture(event.pointerId)) {\r\n        target.releasePointerCapture(event.pointerId);\r\n        onSliderEnd();\r\n      }\r\n    },\r\n    [rootProps.onPointerUp, onSliderEnd],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <SliderContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-slot=\"angle-slider\"\r\n          dir={dir}\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\r\n            \"relative touch-none select-none\",\r\n            disabled && \"opacity-50\",\r\n            className,\r\n          )}\r\n          style={{\r\n            width: `${size * 2 + 40}px`,\r\n            height: `${size * 2 + 40}px`,\r\n          }}\r\n          onKeyDown={onKeyDown}\r\n          onPointerDown={onPointerDown}\r\n          onPointerMove={onPointerMove}\r\n          onPointerUp={onPointerUp}\r\n        >\r\n          {children}\r\n        </RootPrimitive>\r\n      </SliderContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nfunction AngleSliderTrack(props: React.ComponentProps<\"svg\">) {\r\n  const { className, children, ...trackProps } = props;\r\n\r\n  const disabled = useStore((state) => state.disabled);\r\n  const size = useStore((state) => state.size);\r\n  const thickness = useStore((state) => state.thickness);\r\n  const startAngle = useStore((state) => state.startAngle);\r\n  const endAngle = useStore((state) => state.endAngle);\r\n\r\n  const center = size + 20;\r\n  const trackRadius = size;\r\n\r\n  const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n  const isFullCircle = totalAngle >= 359;\r\n\r\n  const startRadians = (startAngle * Math.PI) / 180;\r\n  const endRadians = (endAngle * Math.PI) / 180;\r\n\r\n  const startX = center + trackRadius * Math.cos(startRadians);\r\n  const startY = center + trackRadius * Math.sin(startRadians);\r\n  const endX = center + trackRadius * Math.cos(endRadians);\r\n  const endY = center + trackRadius * Math.sin(endRadians);\r\n\r\n  const largeArcFlag = totalAngle > 180 ? 1 : 0;\r\n\r\n  return (\r\n    <svg\r\n      aria-hidden=\"true\"\r\n      focusable=\"false\"\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-slot=\"angle-slider-track\"\r\n      width={center * 2}\r\n      height={center * 2}\r\n      {...trackProps}\r\n      className={cn(\"absolute inset-0\", className)}\r\n    >\r\n      {isFullCircle ? (\r\n        <circle\r\n          data-slot=\"angle-slider-track-rail\"\r\n          cx={center}\r\n          cy={center}\r\n          r={trackRadius}\r\n          fill=\"none\"\r\n          stroke=\"currentColor\"\r\n          strokeWidth={thickness}\r\n          strokeLinecap=\"round\"\r\n          vectorEffect=\"non-scaling-stroke\"\r\n          className=\"stroke-muted\"\r\n        />\r\n      ) : (\r\n        <path\r\n          data-slot=\"angle-slider-track-rail\"\r\n          d={`M ${startX} ${startY} A ${trackRadius} ${trackRadius} 0 ${largeArcFlag} 1 ${endX} ${endY}`}\r\n          fill=\"none\"\r\n          stroke=\"currentColor\"\r\n          strokeWidth={thickness}\r\n          strokeLinecap=\"round\"\r\n          vectorEffect=\"non-scaling-stroke\"\r\n          className=\"stroke-muted\"\r\n        />\r\n      )}\r\n      {children}\r\n    </svg>\r\n  );\r\n}\r\n\r\nfunction AngleSliderRange(props: React.ComponentProps<\"path\">) {\r\n  const { className, ...rangeProps } = props;\r\n\r\n  const values = useStore((state) => state.values);\r\n  const min = useStore((state) => state.min);\r\n  const max = useStore((state) => state.max);\r\n  const disabled = useStore((state) => state.disabled);\r\n  const size = useStore((state) => state.size);\r\n  const thickness = useStore((state) => state.thickness);\r\n  const startAngle = useStore((state) => state.startAngle);\r\n  const endAngle = useStore((state) => state.endAngle);\r\n\r\n  const center = size + 20;\r\n  const trackRadius = size;\r\n\r\n  const sortedValues = [...values].sort((a, b) => a - b);\r\n\r\n  const rangeStart = values.length <= 1 ? min : (sortedValues[0] ?? min);\r\n  const rangeEnd =\r\n    values.length <= 1\r\n      ? (sortedValues[0] ?? min)\r\n      : (sortedValues[sortedValues.length - 1] ?? max);\r\n\r\n  const rangeStartPercent = (rangeStart - min) / (max - min);\r\n  const rangeEndPercent = (rangeEnd - min) / (max - min);\r\n\r\n  const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n  const rangeStartAngle = startAngle + rangeStartPercent * totalAngle;\r\n  const rangeEndAngle = startAngle + rangeEndPercent * totalAngle;\r\n\r\n  const rangeStartRadians = (rangeStartAngle * Math.PI) / 180;\r\n  const rangeEndRadians = (rangeEndAngle * Math.PI) / 180;\r\n\r\n  const startX = center + trackRadius * Math.cos(rangeStartRadians);\r\n  const startY = center + trackRadius * Math.sin(rangeStartRadians);\r\n  const endX = center + trackRadius * Math.cos(rangeEndRadians);\r\n  const endY = center + trackRadius * Math.sin(rangeEndRadians);\r\n\r\n  const rangeAngle = (rangeEndAngle - rangeStartAngle + 360) % 360;\r\n  const largeArcFlag = rangeAngle > 180 ? 1 : 0;\r\n\r\n  if (rangeStart === rangeEnd) return null;\r\n\r\n  return (\r\n    <path\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-slot=\"angle-slider-range\"\r\n      d={`M ${startX} ${startY} A ${trackRadius} ${trackRadius} 0 ${largeArcFlag} 1 ${endX} ${endY}`}\r\n      fill=\"none\"\r\n      stroke=\"currentColor\"\r\n      strokeWidth={thickness}\r\n      strokeLinecap=\"round\"\r\n      vectorEffect=\"non-scaling-stroke\"\r\n      {...rangeProps}\r\n      className={cn(\"stroke-primary\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface AngleSliderThumbProps extends DivProps {\r\n  index?: number;\r\n}\r\n\r\nfunction AngleSliderThumb(props: AngleSliderThumbProps) {\r\n  const { index: indexProp, className, asChild, ref, ...thumbProps } = props;\r\n\r\n  const context = useSliderContext(THUMB_NAME);\r\n  const store = useStoreContext(THUMB_NAME);\r\n  const values = useStore((state) => state.values);\r\n  const min = useStore((state) => state.min);\r\n  const max = useStore((state) => state.max);\r\n  const step = useStore((state) => state.step);\r\n  const disabled = useStore((state) => state.disabled);\r\n  const size = useStore((state) => state.size);\r\n\r\n  const thumbId = React.useId();\r\n  const [thumbElement, setThumbElement] = React.useState<ThumbElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, setThumbElement);\r\n\r\n  const isFormControl = thumbElement\r\n    ? context.form || !!thumbElement.closest(\"form\")\r\n    : true;\r\n\r\n  const index = indexProp ?? 0;\r\n  const value = values[index];\r\n\r\n  React.useEffect(() => {\r\n    if (thumbElement && value !== undefined) {\r\n      store.addThumb(index, {\r\n        id: thumbId,\r\n        element: thumbElement,\r\n        index,\r\n        value,\r\n      });\r\n\r\n      return () => {\r\n        store.removeThumb(index);\r\n      };\r\n    }\r\n  }, [thumbElement, thumbId, index, value, store]);\r\n\r\n  const thumbStyle = React.useMemo<React.CSSProperties>(() => {\r\n    if (value === undefined) return {};\r\n\r\n    const angle = store.getAngleFromValue(value);\r\n    const position = store.getPositionFromAngle(angle);\r\n    const center = size + 20;\r\n\r\n    return {\r\n      position: \"absolute\",\r\n      left: `${center + position.x}px`,\r\n      top: `${center + position.y}px`,\r\n      transform: \"translate(-50%, -50%)\",\r\n    };\r\n  }, [value, store, size]);\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<ThumbElement>) => {\r\n      props.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"valueIndexToChange\", index);\r\n    },\r\n    [props.onFocus, store, index],\r\n  );\r\n\r\n  const ThumbPrimitive = asChild ? Slot : \"div\";\r\n\r\n  if (value === undefined) return null;\r\n\r\n  return (\r\n    <span style={thumbStyle}>\r\n      <ThumbPrimitive\r\n        id={thumbId}\r\n        role=\"slider\"\r\n        aria-valuemin={min}\r\n        aria-valuenow={value}\r\n        aria-valuemax={max}\r\n        aria-orientation=\"vertical\"\r\n        data-disabled={disabled ? \"\" : undefined}\r\n        data-slot=\"angle-slider-thumb\"\r\n        tabIndex={disabled ? undefined : 0}\r\n        {...thumbProps}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"block size-4 shrink-0 rounded-full border border-primary bg-background shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\",\r\n          className,\r\n        )}\r\n        onFocus={onFocus}\r\n      />\r\n      {isFormControl && value !== undefined && (\r\n        <VisuallyHiddenInput\r\n          key={index}\r\n          control={thumbElement}\r\n          name={\r\n            context.name\r\n              ? context.name + (values.length > 1 ? \"[]\" : \"\")\r\n              : undefined\r\n          }\r\n          form={context.form}\r\n          value={value.toString()}\r\n          type=\"number\"\r\n          min={min}\r\n          max={max}\r\n          step={step}\r\n          disabled={disabled}\r\n        />\r\n      )}\r\n    </span>\r\n  );\r\n}\r\n\r\ninterface AngleSliderValueProps extends DivProps {\r\n  unit?: string;\r\n  formatValue?: (value: number | number[]) => string;\r\n}\r\n\r\nfunction AngleSliderValue(props: AngleSliderValueProps) {\r\n  const {\r\n    unit = \"Â°\",\r\n    formatValue,\r\n    className,\r\n    style,\r\n    asChild,\r\n    children,\r\n    ...valueProps\r\n  } = props;\r\n\r\n  const values = useStore((state) => state.values);\r\n  const size = useStore((state) => state.size);\r\n  const disabled = useStore((state) => state.disabled);\r\n\r\n  const center = size + 20;\r\n\r\n  const displayValue = React.useMemo(() => {\r\n    if (formatValue) {\r\n      return formatValue(values.length === 1 ? (values[0] ?? 0) : values);\r\n    }\r\n\r\n    if (values.length === 1) {\r\n      return `${values[0] ?? 0}${unit}`;\r\n    }\r\n\r\n    const sortedValues = [...values].sort((a, b) => a - b);\r\n    return `${sortedValues[0]}${unit} - ${sortedValues[sortedValues.length - 1]}${unit}`;\r\n  }, [values, formatValue, unit]);\r\n\r\n  const valueStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      position: \"absolute\",\r\n      left: `${center}px`,\r\n      top: `${center}px`,\r\n      transform: \"translate(-50%, -50%)\",\r\n    }),\r\n    [center],\r\n  );\r\n\r\n  const ValuePrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ValuePrimitive\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-slot=\"angle-slider-value\"\r\n      {...valueProps}\r\n      className={cn(\r\n        \"pointer-events-none flex select-none items-center justify-center font-medium text-foreground text-sm\",\r\n        className,\r\n      )}\r\n      style={{\r\n        ...valueStyle,\r\n        ...style,\r\n      }}\r\n    >\r\n      {children ?? displayValue}\r\n    </ValuePrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  AngleSliderRoot as Root,\r\n  AngleSliderTrack as Track,\r\n  AngleSliderRange as Range,\r\n  AngleSliderThumb as Thumb,\r\n  AngleSliderValue as Value,\r\n  //\r\n  AngleSliderRoot as AngleSlider,\r\n  AngleSliderTrack,\r\n  AngleSliderRange,\r\n  AngleSliderThumb,\r\n  AngleSliderValue,\r\n  //\r\n  useStore as useAngleSlider,\r\n  //\r\n  type AngleSliderRootProps as AngleSliderProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}