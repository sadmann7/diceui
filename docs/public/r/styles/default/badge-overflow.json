{
  "name": "badge-overflow",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/badge-overflow.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst badgeWidthCache = new Map<string, number>();\r\n\r\ninterface MeasureBadgeWidthProps {\r\n  label: string;\r\n  cacheKey: string;\r\n  iconSize?: number;\r\n  maxWidth?: number;\r\n}\r\n\r\nfunction measureBadgeWidth({\r\n  label,\r\n  cacheKey,\r\n  iconSize,\r\n  maxWidth,\r\n}: MeasureBadgeWidthProps): number {\r\n  const cached = badgeWidthCache.get(cacheKey);\r\n  if (cached !== undefined) {\r\n    return cached;\r\n  }\r\n\r\n  const measureEl = document.createElement(\"div\");\r\n  measureEl.className =\r\n    \"inline-flex items-center rounded-md border px-1.5 text-xs font-semibold h-5 gap-1 shrink-0 absolute invisible pointer-events-none\";\r\n  measureEl.style.whiteSpace = \"nowrap\";\r\n\r\n  if (iconSize) {\r\n    const icon = document.createElement(\"span\");\r\n    icon.className = \"shrink-0\";\r\n    icon.style.width = `${iconSize}px`;\r\n    icon.style.height = `${iconSize}px`;\r\n    measureEl.appendChild(icon);\r\n  }\r\n\r\n  if (maxWidth) {\r\n    const text = document.createElement(\"span\");\r\n    text.className = \"truncate\";\r\n    text.style.maxWidth = `${maxWidth}px`;\r\n    text.textContent = label;\r\n    measureEl.appendChild(text);\r\n  } else {\r\n    measureEl.textContent = label;\r\n  }\r\n\r\n  document.body.appendChild(measureEl);\r\n  const width = measureEl.offsetWidth;\r\n  document.body.removeChild(measureEl);\r\n\r\n  badgeWidthCache.set(cacheKey, width);\r\n  return width;\r\n}\r\n\r\nfunction clearBadgeWidthCache(): void {\r\n  badgeWidthCache.clear();\r\n}\r\n\r\ninterface GetBadgeLabel<T> {\r\n  /**\r\n   * Callback that returns a label string for each badge item.\r\n   * Optional for primitive arrays (strings, numbers), required for object arrays.\r\n   * @example getBadgeLabel={(item) => item.name}\r\n   */\r\n  getBadgeLabel: (item: T) => string;\r\n}\r\n\r\ntype BadgeOverflowElement = React.ComponentRef<typeof BadgeOverflow>;\r\n\r\ntype BadgeOverflowProps<T = string> = React.ComponentProps<\"div\"> &\r\n  (T extends object ? GetBadgeLabel<T> : Partial<GetBadgeLabel<T>>) & {\r\n    items: T[];\r\n    lineCount?: number;\r\n    cacheKeyPrefix?: string;\r\n    badgeIconSize?: number;\r\n    badgeMaxWidth?: number;\r\n    renderBadge: (item: T, label: string) => React.ReactNode;\r\n    renderOverflow?: (count: number) => React.ReactNode;\r\n    asChild?: boolean;\r\n  };\r\n\r\nfunction BadgeOverflow<T = string>(props: BadgeOverflowProps<T>) {\r\n  const {\r\n    items,\r\n    getBadgeLabel: getBadgeLabelProp,\r\n    lineCount = 1,\r\n    cacheKeyPrefix = \"\",\r\n    badgeMaxWidth,\r\n    badgeIconSize,\r\n    renderBadge,\r\n    renderOverflow,\r\n    asChild,\r\n    className,\r\n    style,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const getBadgeLabel = React.useCallback(\r\n    (item: T): string => {\r\n      if (typeof item === \"object\" && !getBadgeLabelProp) {\r\n        throw new Error(\r\n          \"`getBadgeLabel` is required when using array of objects\",\r\n        );\r\n      }\r\n      return getBadgeLabelProp ? getBadgeLabelProp(item) : (item as string);\r\n    },\r\n    [getBadgeLabelProp],\r\n  );\r\n\r\n  const rootRef = React.useRef<BadgeOverflowElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, rootRef);\r\n  const [containerWidth, setContainerWidth] = React.useState(0);\r\n  const [badgeGap, setBadgeGap] = React.useState(4);\r\n  const [badgeHeight, setBadgeHeight] = React.useState(20);\r\n  const [overflowBadgeWidth, setOverflowBadgeWidth] = React.useState(40);\r\n  const [isMeasured, setIsMeasured] = React.useState(false);\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!rootRef.current) return;\r\n\r\n    function measureContainer() {\r\n      if (!rootRef.current) return;\r\n\r\n      const computedStyle = getComputedStyle(rootRef.current);\r\n\r\n      const gapValue = computedStyle.gap;\r\n      const gap = gapValue ? parseFloat(gapValue) : 4;\r\n      setBadgeGap(gap);\r\n\r\n      const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;\r\n      const paddingRight = parseFloat(computedStyle.paddingRight) || 0;\r\n      const totalPadding = paddingLeft + paddingRight;\r\n\r\n      const tempBadge = document.createElement(\"div\");\r\n      tempBadge.className =\r\n        \"inline-flex items-center rounded-md border px-1.5 text-xs font-semibold h-5 gap-1 shrink-0 absolute invisible pointer-events-none\";\r\n      tempBadge.textContent = \"Measure\";\r\n      document.body.appendChild(tempBadge);\r\n      const measuredBadgeHeight = tempBadge.offsetHeight;\r\n      document.body.removeChild(tempBadge);\r\n      setBadgeHeight(measuredBadgeHeight || 20);\r\n\r\n      const tempOverflow = document.createElement(\"div\");\r\n      tempOverflow.className =\r\n        \"inline-flex h-5 shrink-0 items-center rounded-md border px-1.5 font-semibold text-xs absolute invisible pointer-events-none\";\r\n      tempOverflow.textContent = \"+99\";\r\n      document.body.appendChild(tempOverflow);\r\n      const measuredOverflowWidth = tempOverflow.offsetWidth;\r\n      document.body.removeChild(tempOverflow);\r\n      setOverflowBadgeWidth(measuredOverflowWidth || 40);\r\n\r\n      const width = rootRef.current.clientWidth - totalPadding;\r\n      setContainerWidth(width);\r\n      setIsMeasured(true);\r\n    }\r\n\r\n    measureContainer();\r\n\r\n    const resizeObserver = new ResizeObserver(measureContainer);\r\n    resizeObserver.observe(rootRef.current);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  const placeholderHeight = React.useMemo(\r\n    () => badgeHeight * lineCount + badgeGap * (lineCount - 1),\r\n    [badgeHeight, badgeGap, lineCount],\r\n  );\r\n\r\n  const { visibleItems, hiddenCount } = React.useMemo(() => {\r\n    if (!containerWidth || items.length === 0) {\r\n      return { visibleItems: items, hiddenCount: 0 };\r\n    }\r\n\r\n    let currentLineWidth = 0;\r\n    let currentLine = 1;\r\n    const visible: T[] = [];\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n      const item = items[i];\r\n      if (!item) continue;\r\n\r\n      const label = getBadgeLabel(item);\r\n      const cacheKey = cacheKeyPrefix ? `${cacheKeyPrefix}:${label}` : label;\r\n\r\n      const badgeWidth = measureBadgeWidth({\r\n        label,\r\n        cacheKey,\r\n        iconSize: badgeIconSize,\r\n        maxWidth: badgeMaxWidth,\r\n      });\r\n\r\n      const widthWithGap = badgeWidth + badgeGap;\r\n      const isLastLine = currentLine === lineCount;\r\n      const hasMoreItems = i < items.length - 1;\r\n\r\n      // Reserve space for overflow badge on last line if there are more items\r\n      const availableWidth =\r\n        isLastLine && hasMoreItems\r\n          ? containerWidth - overflowBadgeWidth - badgeGap\r\n          : containerWidth;\r\n\r\n      if (currentLineWidth + widthWithGap <= availableWidth) {\r\n        currentLineWidth += widthWithGap;\r\n        visible.push(item);\r\n      } else if (currentLine < lineCount) {\r\n        currentLine++;\r\n        currentLineWidth = widthWithGap;\r\n        visible.push(item);\r\n      } else {\r\n        // We're on the last line and this badge doesn't fit\r\n        break;\r\n      }\r\n    }\r\n\r\n    return {\r\n      visibleItems: visible,\r\n      hiddenCount: Math.max(0, items.length - visible.length),\r\n    };\r\n  }, [\r\n    items,\r\n    getBadgeLabel,\r\n    containerWidth,\r\n    lineCount,\r\n    cacheKeyPrefix,\r\n    badgeIconSize,\r\n    badgeMaxWidth,\r\n    badgeGap,\r\n    overflowBadgeWidth,\r\n  ]);\r\n\r\n  const Comp = asChild ? Slot : \"div\";\r\n\r\n  if (!isMeasured) {\r\n    const baseCount = lineCount * 3;\r\n    const skeletonCount = Math.min(\r\n      items.length,\r\n      lineCount > 1 ? baseCount - 1 : baseCount,\r\n    );\r\n    const skeletonItems = items.slice(0, skeletonCount);\r\n\r\n    return (\r\n      <Comp\r\n        data-slot=\"badge-overflow\"\r\n        {...rootProps}\r\n        ref={composedRef}\r\n        className={cn(\"flex flex-wrap\", className)}\r\n        style={{\r\n          gap: badgeGap,\r\n          minHeight: placeholderHeight,\r\n          ...style,\r\n        }}\r\n      >\r\n        {skeletonItems.map((item, index) => (\r\n          <React.Fragment key={index}>\r\n            {renderBadge(item, getBadgeLabel(item))}\r\n          </React.Fragment>\r\n        ))}\r\n      </Comp>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Comp\r\n      data-slot=\"badge-overflow\"\r\n      {...rootProps}\r\n      ref={composedRef}\r\n      className={cn(\"flex flex-wrap\", className)}\r\n      style={{\r\n        gap: badgeGap,\r\n        ...style,\r\n      }}\r\n    >\r\n      {visibleItems.map((item, index) => (\r\n        <React.Fragment key={index}>\r\n          {renderBadge(item, getBadgeLabel(item))}\r\n        </React.Fragment>\r\n      ))}\r\n      {hiddenCount > 0 &&\r\n        (renderOverflow ? (\r\n          renderOverflow(hiddenCount)\r\n        ) : (\r\n          <div className=\"inline-flex h-5 shrink-0 items-center rounded-md border px-1.5 font-semibold text-xs\">\r\n            +{hiddenCount}\r\n          </div>\r\n        ))}\r\n    </Comp>\r\n  );\r\n}\r\n\r\nexport {\r\n  BadgeOverflow,\r\n  //\r\n  clearBadgeWidthCache,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}