{
  "name": "badge-overflow",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/badge-overflow.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst badgeWidthCache = new Map<string, number>();\n\ninterface MeasureBadgeWidthProps {\n  label: string;\n  cacheKey: string;\n  iconSize?: number;\n  maxWidth?: number;\n}\n\nfunction measureBadgeWidth({\n  label,\n  cacheKey,\n  iconSize,\n  maxWidth,\n}: MeasureBadgeWidthProps): number {\n  const cached = badgeWidthCache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const measureEl = document.createElement(\"div\");\n  measureEl.className =\n    \"inline-flex items-center rounded-md border px-1.5 text-xs font-semibold h-5 gap-1 shrink-0 absolute invisible pointer-events-none\";\n  measureEl.style.whiteSpace = \"nowrap\";\n\n  if (iconSize) {\n    const icon = document.createElement(\"span\");\n    icon.className = \"shrink-0\";\n    icon.style.width = `${iconSize}px`;\n    icon.style.height = `${iconSize}px`;\n    measureEl.appendChild(icon);\n  }\n\n  if (maxWidth) {\n    const text = document.createElement(\"span\");\n    text.className = \"truncate\";\n    text.style.maxWidth = `${maxWidth}px`;\n    text.textContent = label;\n    measureEl.appendChild(text);\n  } else {\n    measureEl.textContent = label;\n  }\n\n  document.body.appendChild(measureEl);\n  const width = measureEl.offsetWidth;\n  document.body.removeChild(measureEl);\n\n  badgeWidthCache.set(cacheKey, width);\n  return width;\n}\n\nfunction clearBadgeWidthCache(): void {\n  badgeWidthCache.clear();\n}\n\ninterface GetBadgeLabel<T> {\n  /**\n   * Callback that returns a label string for each badge item.\n   * Optional for primitive arrays (strings, numbers), required for object arrays.\n   * @example getBadgeLabel={(item) => item.name}\n   */\n  getBadgeLabel: (item: T) => string;\n}\n\ntype BadgeOverflowElement = React.ComponentRef<typeof BadgeOverflow>;\n\ntype BadgeOverflowProps<T = string> = React.ComponentProps<\"div\"> &\n  (T extends object ? GetBadgeLabel<T> : Partial<GetBadgeLabel<T>>) & {\n    items: T[];\n    lineCount?: number;\n    cacheKeyPrefix?: string;\n    badgeIconSize?: number;\n    badgeMaxWidth?: number;\n    renderBadge: (item: T, label: string) => React.ReactNode;\n    renderOverflow?: (count: number) => React.ReactNode;\n    asChild?: boolean;\n  };\n\nfunction BadgeOverflow<T = string>(props: BadgeOverflowProps<T>) {\n  const {\n    items,\n    getBadgeLabel: getBadgeLabelProp,\n    lineCount = 1,\n    cacheKeyPrefix = \"\",\n    badgeMaxWidth,\n    badgeIconSize,\n    renderBadge,\n    renderOverflow,\n    asChild,\n    className,\n    style,\n    ref,\n    ...rootProps\n  } = props;\n\n  const getBadgeLabel = React.useCallback(\n    (item: T): string => {\n      if (typeof item === \"object\" && !getBadgeLabelProp) {\n        throw new Error(\n          \"`getBadgeLabel` is required when using array of objects\",\n        );\n      }\n      return getBadgeLabelProp ? getBadgeLabelProp(item) : (item as string);\n    },\n    [getBadgeLabelProp],\n  );\n\n  const rootRef = React.useRef<BadgeOverflowElement | null>(null);\n  const composedRef = useComposedRefs(ref, rootRef);\n  const [containerWidth, setContainerWidth] = React.useState(0);\n  const [badgeGap, setBadgeGap] = React.useState(4);\n  const [badgeHeight, setBadgeHeight] = React.useState(20);\n  const [overflowBadgeWidth, setOverflowBadgeWidth] = React.useState(40);\n  const [isMeasured, setIsMeasured] = React.useState(false);\n\n  React.useLayoutEffect(() => {\n    if (!rootRef.current) return;\n\n    function measureContainer() {\n      if (!rootRef.current) return;\n\n      const computedStyle = getComputedStyle(rootRef.current);\n\n      // Measure gap from computed styles\n      const gapValue = computedStyle.gap;\n      const gap = gapValue ? parseFloat(gapValue) : 4;\n      setBadgeGap(gap);\n\n      // Measure padding from computed styles\n      const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;\n      const paddingRight = parseFloat(computedStyle.paddingRight) || 0;\n      const totalPadding = paddingLeft + paddingRight;\n\n      // Measure badge height by rendering a temporary badge\n      const tempBadge = document.createElement(\"div\");\n      tempBadge.className =\n        \"inline-flex items-center rounded-md border px-1.5 text-xs font-semibold h-5 gap-1 shrink-0 absolute invisible pointer-events-none\";\n      tempBadge.textContent = \"Measure\";\n      document.body.appendChild(tempBadge);\n      const measuredBadgeHeight = tempBadge.offsetHeight;\n      document.body.removeChild(tempBadge);\n      setBadgeHeight(measuredBadgeHeight || 20);\n\n      // Measure overflow badge width\n      const tempOverflow = document.createElement(\"div\");\n      tempOverflow.className =\n        \"inline-flex h-5 shrink-0 items-center rounded-md border px-1.5 font-semibold text-xs absolute invisible pointer-events-none\";\n      tempOverflow.textContent = \"+99\";\n      document.body.appendChild(tempOverflow);\n      const measuredOverflowWidth = tempOverflow.offsetWidth;\n      document.body.removeChild(tempOverflow);\n      setOverflowBadgeWidth(measuredOverflowWidth || 40);\n\n      // Measure container width\n      const width = rootRef.current.clientWidth - totalPadding;\n      setContainerWidth(width);\n      setIsMeasured(true);\n    }\n\n    measureContainer();\n\n    const resizeObserver = new ResizeObserver(measureContainer);\n    resizeObserver.observe(rootRef.current);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  const placeholderHeight = React.useMemo(\n    () => badgeHeight * lineCount + badgeGap * (lineCount - 1),\n    [badgeHeight, badgeGap, lineCount],\n  );\n\n  const { visibleItems, hiddenCount } = React.useMemo(() => {\n    if (!containerWidth || items.length === 0) {\n      return { visibleItems: items, hiddenCount: 0 };\n    }\n\n    let currentLineWidth = 0;\n    let currentLine = 1;\n    const visible: T[] = [];\n\n    for (const item of items) {\n      const label = getBadgeLabel(item);\n      const cacheKey = cacheKeyPrefix ? `${cacheKeyPrefix}:${label}` : label;\n\n      const badgeWidth = measureBadgeWidth({\n        label,\n        cacheKey,\n        iconSize: badgeIconSize,\n        maxWidth: badgeMaxWidth,\n      });\n\n      const widthWithGap = badgeWidth + badgeGap;\n\n      if (currentLineWidth + widthWithGap <= containerWidth) {\n        currentLineWidth += widthWithGap;\n        visible.push(item);\n      } else if (currentLine < lineCount) {\n        currentLine++;\n        currentLineWidth = widthWithGap;\n        visible.push(item);\n      } else {\n        if (\n          currentLineWidth + overflowBadgeWidth > containerWidth &&\n          visible.length > 0\n        ) {\n          visible.pop();\n        }\n        break;\n      }\n    }\n\n    return {\n      visibleItems: visible,\n      hiddenCount: Math.max(0, items.length - visible.length),\n    };\n  }, [\n    items,\n    getBadgeLabel,\n    containerWidth,\n    lineCount,\n    cacheKeyPrefix,\n    badgeIconSize,\n    badgeMaxWidth,\n    badgeGap,\n    overflowBadgeWidth,\n  ]);\n\n  const Comp = asChild ? Slot : \"div\";\n\n  if (!isMeasured) {\n    return (\n      <Comp\n        data-slot=\"badge-overflow\"\n        {...rootProps}\n        ref={composedRef}\n        className={cn(\"flex flex-wrap\", className)}\n        style={{\n          gap: badgeGap,\n          minHeight: placeholderHeight,\n          ...style,\n        }}\n      />\n    );\n  }\n\n  return (\n    <Comp\n      data-slot=\"badge-overflow\"\n      {...rootProps}\n      ref={composedRef}\n      className={cn(\"flex flex-wrap\", className)}\n      style={{\n        gap: badgeGap,\n        ...style,\n      }}\n    >\n      {visibleItems.map((item, index) => (\n        <React.Fragment key={index}>\n          {renderBadge(item, getBadgeLabel(item))}\n        </React.Fragment>\n      ))}\n      {hiddenCount > 0 &&\n        (renderOverflow ? (\n          renderOverflow(hiddenCount)\n        ) : (\n          <div className=\"inline-flex h-5 shrink-0 items-center rounded-md border px-1.5 font-semibold text-xs\">\n            +{hiddenCount}\n          </div>\n        ))}\n    </Comp>\n  );\n}\n\nexport {\n  BadgeOverflow,\n  //\n  clearBadgeWidthCache,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}