{
  "name": "mask-input",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/mask-input.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\ninterface MaskPattern {\n  pattern: string;\n  placeholder: string;\n  transform?: (value: string) => string;\n  validate?: (value: string) => boolean;\n}\n\ntype MaskPatternKey =\n  | \"phone\"\n  | \"ssn\"\n  | \"date\"\n  | \"time\"\n  | \"creditCard\"\n  | \"zipCode\"\n  | \"zipCodeExtended\"\n  | \"currency\"\n  | \"currencyEur\"\n  | \"percentage\"\n  | \"licensePlate\"\n  | \"ipAddress\"\n  | \"macAddress\"\n  | \"isbn\"\n  | \"ein\";\n\nconst MASK_PATTERNS: Record<MaskPatternKey, MaskPattern> = {\n  phone: {\n    pattern: \"(###) ###-####\",\n    placeholder: \"(___) ___-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{10}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  ssn: {\n    pattern: \"###-##-####\",\n    placeholder: \"___-__-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  date: {\n    pattern: \"##/##/####\",\n    placeholder: \"mm/dd/yyyy\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => {\n      const cleaned = value.replace(/\\D/g, \"\");\n      if (cleaned.length !== 8) return false;\n      const month = parseInt(cleaned.substring(0, 2), 10);\n      const day = parseInt(cleaned.substring(2, 4), 10);\n      const year = parseInt(cleaned.substring(4, 8), 10);\n\n      // Basic range checks\n      if (month < 1 || month > 12 || day < 1 || year < 1900) return false;\n\n      // Days per month validation\n      const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n      // Check for leap year\n      const isLeapYear =\n        (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n      if (isLeapYear && month === 2) {\n        daysInMonth[1] = 29;\n      }\n\n      return day <= (daysInMonth[month - 1] ?? 31);\n    },\n  },\n  time: {\n    pattern: \"##:##\",\n    placeholder: \"hh:mm\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => {\n      const cleaned = value.replace(/\\D/g, \"\");\n      if (cleaned.length !== 4) return false;\n      const hours = parseInt(cleaned.substring(0, 2), 10);\n      const minutes = parseInt(cleaned.substring(2, 4), 10);\n      return hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59;\n    },\n  },\n  creditCard: {\n    pattern: \"#### #### #### ####\",\n    placeholder: \"____ ____ ____ ____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{16}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  zipCode: {\n    pattern: \"#####\",\n    placeholder: \"_____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{5}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  zipCodeExtended: {\n    pattern: \"#####-####\",\n    placeholder: \"_____-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  currency: {\n    pattern: \"$###,###.##\",\n    placeholder: \"$0.00\",\n    transform: (value) => {\n      // Remove everything except digits and decimal point\n      const cleaned = value.replace(/[^\\d.]/g, \"\");\n      // Ensure only one decimal point\n      const parts = cleaned.split(\".\");\n      if (parts.length > 2) {\n        return `${parts[0]}.${parts.slice(1).join(\"\")}`;\n      }\n      // Limit to 2 decimal places\n      if (parts[1] && parts[1].length > 2) {\n        return `${parts[0]}.${parts[1].substring(0, 2)}`;\n      }\n      return cleaned;\n    },\n    validate: (value) => {\n      if (!/^\\d+(\\.\\d{1,2})?$/.test(value)) return false;\n      const num = parseFloat(value);\n      return !Number.isNaN(num) && num >= 0 && num <= 999999999.99;\n    },\n  },\n  currencyEur: {\n    pattern: \"€###,###.##\",\n    placeholder: \"€0.00\",\n    transform: (value) => {\n      const cleaned = value.replace(/[^\\d.]/g, \"\");\n      const parts = cleaned.split(\".\");\n      if (parts.length > 2) {\n        return `${parts[0]}.${parts.slice(1).join(\"\")}`;\n      }\n      if (parts[1] && parts[1].length > 2) {\n        return `${parts[0]}.${parts[1].substring(0, 2)}`;\n      }\n      return cleaned;\n    },\n    validate: (value) => {\n      if (!/^\\d+(\\.\\d{1,2})?$/.test(value)) return false;\n      const num = parseFloat(value);\n      return !Number.isNaN(num) && num >= 0 && num <= 999999999.99;\n    },\n  },\n  percentage: {\n    pattern: \"##.##%\",\n    placeholder: \"0.00%\",\n    transform: (value) => {\n      const cleaned = value.replace(/[^\\d.]/g, \"\");\n      const parts = cleaned.split(\".\");\n      if (parts.length > 2) {\n        return `${parts[0]}.${parts.slice(1).join(\"\")}`;\n      }\n      if (parts[1] && parts[1].length > 2) {\n        return `${parts[0]}.${parts[1].substring(0, 2)}`;\n      }\n      return cleaned;\n    },\n    validate: (value) => {\n      const num = parseFloat(value);\n      return !Number.isNaN(num) && num >= 0 && num <= 100;\n    },\n  },\n  licensePlate: {\n    pattern: \"###-###\",\n    placeholder: \"ABC-123\",\n    transform: (value) => value.replace(/[^A-Z0-9]/gi, \"\").toUpperCase(),\n    validate: (value) => /^[A-Z0-9]{6}$/.test(value),\n  },\n  ipAddress: {\n    pattern: \"###.###.###.###\",\n    placeholder: \"192.168.1.1\",\n    transform: (value) => value.replace(/[^\\d.]/g, \"\"),\n    validate: (value) => {\n      const parts = value.split(\".\");\n      if (parts.length !== 4) return false;\n      return parts.every((part) => {\n        // Check for empty parts or leading zeros (except \"0\" itself)\n        if (!part || (part.length > 1 && part.startsWith(\"0\"))) return false;\n        const num = parseInt(part, 10);\n        return !Number.isNaN(num) && num >= 0 && num <= 255;\n      });\n    },\n  },\n  macAddress: {\n    pattern: \"##:##:##:##:##:##\",\n    placeholder: \"00:1B:44:11:3A:B7\",\n    transform: (value) => value.replace(/[^A-F0-9]/gi, \"\").toUpperCase(),\n    validate: (value) => /^[A-F0-9]{12}$/.test(value),\n  },\n  isbn: {\n    pattern: \"###-#-###-#####-#\",\n    placeholder: \"978-0-123-45678-9\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{13}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  ein: {\n    pattern: \"##-#######\",\n    placeholder: \"12-3456789\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n};\n\nfunction applyMask(\n  value: string,\n  pattern: string,\n  transform?: (value: string) => string,\n): string {\n  const cleanValue = transform ? transform(value) : value;\n\n  // Special handling for currency patterns\n  if (pattern.includes(\"$\") || pattern.includes(\"€\")) {\n    return applyCurrencyMask(cleanValue, pattern);\n  }\n\n  // Special handling for percentage\n  if (pattern.includes(\"%\")) {\n    return applyPercentageMask(cleanValue);\n  }\n\n  // Default mask application for other patterns\n  let masked = \"\";\n  let valueIndex = 0;\n\n  for (let i = 0; i < pattern.length && valueIndex < cleanValue.length; i++) {\n    const patternChar = pattern[i];\n    const valueChar = cleanValue[valueIndex];\n\n    if (patternChar === \"#\") {\n      masked += valueChar;\n      valueIndex++;\n    } else {\n      masked += patternChar;\n    }\n  }\n\n  return masked;\n}\n\nfunction applyCurrencyMask(value: string, pattern: string): string {\n  if (!value) return \"\";\n\n  const currencySymbol = pattern.includes(\"$\") ? \"$\" : \"€\";\n  const parts = value.split(\".\");\n  let integerPart = parts[0] || \"\";\n  const decimalPart = parts[1] || \"\";\n\n  // Add commas to integer part (only if there are digits)\n  if (integerPart && integerPart.length > 3) {\n    integerPart = integerPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n  }\n\n  let result = `${currencySymbol}${integerPart || \"0\"}`;\n\n  // Only add decimal part if user has typed a decimal point or decimal digits\n  if (value.includes(\".\")) {\n    result += `.${(decimalPart || \"\").substring(0, 2)}`;\n  }\n\n  return result;\n}\n\nfunction applyPercentageMask(value: string): string {\n  if (!value) return \"\";\n\n  const parts = value.split(\".\");\n  let result = parts[0] || \"0\";\n\n  // Only add decimal part if user has typed a decimal point\n  if (value.includes(\".\")) {\n    result += `.${(parts[1] || \"\").substring(0, 2)}`;\n  }\n\n  return `${result}%`;\n}\n\nfunction getUnmaskedValue(\n  value: string,\n  transform?: (value: string) => string,\n): string {\n  return transform ? transform(value) : value.replace(/\\D/g, \"\");\n}\n\nfunction calculateCursorPosition(\n  maskedValue: string,\n  pattern: string,\n  currentUnmaskedLength: number,\n  _previousUnmaskedLength: number,\n): number {\n  // For dynamic patterns (currency, percentage), position at end\n  if (pattern.includes(\"$\") || pattern.includes(\"€\") || pattern.includes(\"%\")) {\n    return maskedValue.length;\n  }\n\n  // For fixed patterns, find position after the last user character\n  let position = 0;\n  let unmaskedCount = 0;\n\n  for (let i = 0; i < pattern.length && i < maskedValue.length; i++) {\n    if (pattern[i] === \"#\") {\n      unmaskedCount++;\n      if (unmaskedCount <= currentUnmaskedLength) {\n        position = i + 1;\n      }\n    }\n  }\n\n  return position;\n}\n\nfunction toUnmaskedIndex(\n  masked: string,\n  pattern: string,\n  caret: number,\n): number {\n  let idx = 0;\n  for (let i = 0; i < caret && i < masked.length && i < pattern.length; i++) {\n    if (pattern[i] === \"#\") {\n      idx++;\n    }\n  }\n  return idx;\n}\n\nfunction fromUnmaskedIndex(\n  masked: string,\n  pattern: string,\n  uIdx: number,\n): number {\n  let seen = 0;\n  for (let i = 0; i < masked.length && i < pattern.length; i++) {\n    if (pattern[i] === \"#\") {\n      seen++;\n      if (seen === uIdx) {\n        return i + 1;\n      }\n    }\n  }\n  return masked.length;\n}\n\ntype InputElement = HTMLInputElement;\n\ninterface MaskInputProps extends React.ComponentProps<\"input\"> {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (\n    maskedValue: string,\n    unmaskedValue: string,\n    event: React.ChangeEvent<InputElement>,\n  ) => void;\n  onValidate?: (isValid: boolean, unmaskedValue: string) => void;\n  mask?: MaskPatternKey | MaskPattern;\n  asChild?: boolean;\n  invalid?: boolean;\n  withoutMask?: boolean;\n}\n\nfunction MaskInput(props: MaskInputProps) {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange: onValueChangeProp,\n    onValidate,\n    onBlur: onBlurProp,\n    onFocus: onFocusProp,\n    onKeyDown: onKeyDownProp,\n    onPaste: onPasteProp,\n    onCompositionStart: onCompositionStartProp,\n    onCompositionEnd: onCompositionEndProp,\n    mask,\n    placeholder: placeholderProp,\n    asChild = false,\n    disabled = false,\n    invalid = false,\n    readOnly = false,\n    required = false,\n    withoutMask = false,\n    className,\n    ref,\n    ...inputProps\n  } = props;\n\n  const [internalValue, setInternalValue] = React.useState(defaultValue ?? \"\");\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [composing, setComposing] = React.useState(false);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const composedRef = useComposedRefs(ref, inputRef);\n\n  const isControlled = valueProp !== undefined;\n  const value = isControlled ? valueProp : internalValue;\n\n  const maskPattern = React.useMemo(() => {\n    if (typeof mask === \"string\") {\n      return MASK_PATTERNS[mask];\n    }\n    return mask;\n  }, [mask]);\n\n  const placeholder = React.useMemo(() => {\n    return (\n      placeholderProp ??\n      (isFocused && !withoutMask ? maskPattern?.placeholder : undefined)\n    );\n  }, [placeholderProp, withoutMask, maskPattern, isFocused]);\n\n  const displayValue = React.useMemo(() => {\n    if (withoutMask || !maskPattern || !value) return value ?? \"\";\n    return applyMask(value, maskPattern.pattern, maskPattern.transform);\n  }, [value, maskPattern, withoutMask]);\n\n  // Calculate maxLength and inputMode for fixed patterns\n  const tokenCount = React.useMemo(() => {\n    if (!maskPattern || /[€$%]/.test(maskPattern.pattern)) return undefined;\n    return maskPattern.pattern.match(/#/g)?.length ?? 0;\n  }, [maskPattern]);\n\n  const calculatedMaxLength = tokenCount\n    ? maskPattern?.pattern.length\n    : inputProps.maxLength;\n\n  const calculatedInputMode = React.useMemo(() => {\n    if (inputProps.inputMode) return inputProps.inputMode;\n    if (!maskPattern) return undefined;\n\n    const numericPatterns =\n      /^(phone|zipCode|zipCodeExtended|ssn|ein|time|date|creditCard)$/;\n    if (typeof mask === \"string\" && numericPatterns.test(mask)) {\n      return \"numeric\";\n    }\n    return undefined;\n  }, [maskPattern, mask, inputProps.inputMode]);\n\n  const onValueChange = React.useCallback(\n    (event: React.ChangeEvent<InputElement>) => {\n      const inputValue = event.target.value;\n      let newValue = inputValue;\n      let unmaskedValue = inputValue;\n\n      // Skip masking during IME composition\n      if (composing) {\n        if (!isControlled) {\n          setInternalValue(inputValue);\n        }\n        return;\n      }\n\n      // Early exit when masking is disabled\n      if (withoutMask || !maskPattern) {\n        if (!isControlled) {\n          setInternalValue(inputValue);\n        }\n        onValidate?.(true, inputValue);\n        onValueChangeProp?.(inputValue, inputValue, event);\n        return;\n      }\n\n      if (maskPattern) {\n        const previousValue = inputRef.current?.value ?? \"\";\n\n        unmaskedValue = getUnmaskedValue(inputValue, maskPattern.transform);\n        newValue = applyMask(\n          unmaskedValue,\n          maskPattern.pattern,\n          maskPattern.transform,\n        );\n\n        // Calculate the correct cursor position based on the change\n        if (inputRef.current && newValue !== inputValue) {\n          // Guard against non-input elements when using asChild\n          if (asChild && inputRef.current.tagName !== \"INPUT\") {\n            if (process.env.NODE_ENV === \"development\") {\n              console.warn(\n                \"MaskInput: asChild should only be used with input elements for proper cursor positioning\",\n              );\n            }\n            inputRef.current.value = newValue;\n          } else {\n            inputRef.current.value = newValue;\n\n            const previousUnmasked = getUnmaskedValue(\n              previousValue,\n              maskPattern.transform,\n            );\n            const currentUnmasked = getUnmaskedValue(\n              newValue,\n              maskPattern.transform,\n            );\n\n            let newCursorPosition = calculateCursorPosition(\n              newValue,\n              maskPattern.pattern,\n              currentUnmasked.length,\n              previousUnmasked.length,\n            );\n\n            // Apply pattern-specific cursor constraints\n            if (\n              maskPattern.pattern.includes(\"$\") ||\n              maskPattern.pattern.includes(\"€\")\n            ) {\n              newCursorPosition = Math.max(1, newCursorPosition); // After currency symbol\n            } else if (maskPattern.pattern.includes(\"%\")) {\n              newCursorPosition = Math.min(\n                newValue.length - 1,\n                newCursorPosition,\n              ); // Before % symbol\n            }\n\n            newCursorPosition = Math.min(newCursorPosition, newValue.length);\n\n            inputRef.current.setSelectionRange(\n              newCursorPosition,\n              newCursorPosition,\n            );\n          }\n        }\n      }\n\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n\n      // Validate if validation function is provided\n      if (onValidate && maskPattern?.validate) {\n        const isValid = maskPattern.validate(unmaskedValue);\n        onValidate(isValid, unmaskedValue);\n      }\n\n      onValueChangeProp?.(newValue, unmaskedValue, event);\n    },\n    [\n      maskPattern,\n      isControlled,\n      onValueChangeProp,\n      onValidate,\n      composing,\n      withoutMask,\n      asChild,\n    ],\n  );\n\n  const onFocus = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onFocusProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsFocused(true);\n    },\n    [onFocusProp],\n  );\n\n  const onBlur = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onBlurProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsFocused(false);\n    },\n    [onBlurProp],\n  );\n\n  const onCompositionStart = React.useCallback(\n    (event: React.CompositionEvent<InputElement>) => {\n      onCompositionStartProp?.(event);\n      setComposing(true);\n    },\n    [onCompositionStartProp],\n  );\n\n  const onCompositionEnd = React.useCallback(\n    (event: React.CompositionEvent<InputElement>) => {\n      onCompositionEndProp?.(event);\n      setComposing(false);\n      // Apply masking after composition ends\n      onValueChange(event as unknown as React.ChangeEvent<InputElement>);\n    },\n    [onCompositionEndProp, onValueChange],\n  );\n\n  const onPaste = React.useCallback(\n    (event: React.ClipboardEvent<InputElement>) => {\n      onPasteProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (!maskPattern) return;\n\n      event.preventDefault();\n      const pastedText = event.clipboardData.getData(\"text\");\n      const target = event.target as InputElement;\n      const cursorPosition = target.selectionStart ?? 0;\n      const currentValue = target.value;\n\n      // Get the unmasked pasted text\n      const unmaskedPasted = getUnmaskedValue(\n        pastedText,\n        maskPattern.transform,\n      );\n\n      // Get current unmasked value\n      const currentUnmasked = getUnmaskedValue(\n        currentValue,\n        maskPattern.transform,\n      );\n\n      // Calculate where to insert in the unmasked value\n      let insertPosition = 0;\n      let patternIndex = 0;\n\n      for (\n        let i = 0;\n        i < cursorPosition &&\n        i < currentValue.length &&\n        patternIndex < maskPattern.pattern.length;\n        i++\n      ) {\n        const currentChar = currentValue[i];\n        const patternChar = maskPattern.pattern[patternIndex];\n\n        if (patternChar === \"#\") {\n          // This is a user-inputtable position\n          if (\n            currentChar &&\n            currentChar !== (maskPattern.placeholder?.[i] ?? \"_\")\n          ) {\n            insertPosition++;\n          }\n          patternIndex++;\n        } else if (currentChar === patternChar) {\n          // This is a literal character that matches the pattern\n          patternIndex++;\n        } else {\n          // Mismatch - try to sync up\n          break;\n        }\n      }\n\n      // Limit pasted content to remaining pattern capacity\n      const maxLength = maskPattern.pattern.split(\"#\").length - 1; // Count of # characters\n      const availableLength = maxLength - currentUnmasked.length;\n      const limitedPasted = unmaskedPasted.slice(\n        0,\n        Math.max(0, availableLength),\n      );\n\n      if (limitedPasted.length === 0) {\n        // Nothing to paste\n        return;\n      }\n\n      // Create new unmasked value with pasted content\n      const newUnmaskedValue =\n        currentUnmasked.slice(0, insertPosition) +\n        limitedPasted +\n        currentUnmasked.slice(insertPosition);\n\n      // Apply mask to the new value\n      const newMaskedValue = applyMask(\n        newUnmaskedValue,\n        maskPattern.pattern,\n        maskPattern.transform,\n      );\n\n      // Update the input\n      target.value = newMaskedValue;\n\n      // Position cursor after pasted content\n      let newCursorPosition = 0;\n      let unmaskedIndex = 0;\n      const targetUnmaskedLength = insertPosition + limitedPasted.length;\n\n      for (\n        let i = 0;\n        i < newMaskedValue.length && unmaskedIndex < targetUnmaskedLength;\n        i++\n      ) {\n        if (maskPattern.pattern[i] === \"#\") {\n          unmaskedIndex++;\n          if (unmaskedIndex <= targetUnmaskedLength) {\n            newCursorPosition = i + 1;\n          }\n        }\n      }\n\n      target.setSelectionRange(newCursorPosition, newCursorPosition);\n\n      // Call the value change handler directly\n      if (!isControlled) {\n        setInternalValue(newMaskedValue);\n      }\n\n      if (onValidate && maskPattern?.validate) {\n        const isValid = maskPattern.validate(newUnmaskedValue);\n        onValidate(isValid, newUnmaskedValue);\n      }\n\n      onValueChangeProp?.(\n        newMaskedValue,\n        newUnmaskedValue,\n        event as unknown as React.ChangeEvent<InputElement>,\n      );\n    },\n    [maskPattern, onPasteProp, isControlled, onValueChangeProp, onValidate],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<InputElement>) => {\n      onKeyDownProp?.(event);\n      if (event.defaultPrevented) return;\n\n      // Handle backspace to remove mask characters properly\n      if (event.key === \"Backspace\" && maskPattern) {\n        const target = event.target as InputElement;\n        const cursorPosition = target.selectionStart ?? 0;\n        const selectionEnd = target.selectionEnd ?? 0;\n        const currentValue = target.value;\n\n        // Special handling for currency and percentage patterns\n        if (\n          maskPattern.pattern.includes(\"$\") ||\n          maskPattern.pattern.includes(\"€\") ||\n          maskPattern.pattern.includes(\"%\")\n        ) {\n          // For currency/percentage, let the normal backspace work\n          // The transform function will handle the cleanup\n          return;\n        }\n\n        // Handle text selection deletion\n        if (cursorPosition !== selectionEnd) {\n          return; // Let default behavior handle selection deletion\n        }\n\n        if (cursorPosition > 0) {\n          const charBeforeCursor = currentValue[cursorPosition - 1];\n\n          // Check if character is a mask literal (not a user-inputtable character)\n          const isLiteral = maskPattern.pattern[cursorPosition - 1] !== \"#\";\n\n          if (charBeforeCursor && isLiteral) {\n            event.preventDefault();\n\n            // Use proper caret to unmasked index mapping\n            const uIdx = toUnmaskedIndex(\n              currentValue,\n              maskPattern.pattern,\n              cursorPosition,\n            );\n            if (uIdx > 0) {\n              const currentUnmasked = getUnmaskedValue(\n                currentValue,\n                maskPattern.transform,\n              );\n              const nextUnmasked =\n                currentUnmasked.slice(0, uIdx - 1) +\n                currentUnmasked.slice(uIdx);\n              const nextMasked = applyMask(\n                nextUnmasked,\n                maskPattern.pattern,\n                maskPattern.transform,\n              );\n\n              target.value = nextMasked;\n              const nextCaret = fromUnmaskedIndex(\n                nextMasked,\n                maskPattern.pattern,\n                uIdx - 1,\n              );\n              target.setSelectionRange(nextCaret, nextCaret);\n\n              const syntheticEvent = {\n                ...event,\n                target: { ...target, value: nextMasked },\n              } as React.ChangeEvent<InputElement>;\n\n              onValueChange(syntheticEvent);\n            }\n            return;\n          }\n        }\n      }\n    },\n    [maskPattern, onKeyDownProp, onValueChange],\n  );\n\n  const InputPrimitive = asChild ? Slot : \"input\";\n\n  return (\n    <InputPrimitive\n      aria-invalid={invalid}\n      data-disabled={disabled ? \"\" : undefined}\n      data-readonly={readOnly ? \"\" : undefined}\n      data-required={required ? \"\" : undefined}\n      data-invalid={invalid ? \"\" : undefined}\n      data-slot=\"mask-input\"\n      {...inputProps}\n      ref={composedRef}\n      value={displayValue}\n      placeholder={placeholder}\n      disabled={disabled}\n      readOnly={readOnly}\n      required={required}\n      maxLength={calculatedMaxLength}\n      inputMode={calculatedInputMode}\n      className={cn(\n        \"flex h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs outline-none transition-[color,box-shadow] selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30\",\n        \"focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50\",\n        \"aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40\",\n        className,\n      )}\n      onChange={onValueChange}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onKeyDown={onKeyDown}\n      onPaste={onPaste}\n      onCompositionStart={onCompositionStart}\n      onCompositionEnd={onCompositionEnd}\n    />\n  );\n}\n\nexport {\n  MaskInput,\n  MASK_PATTERNS,\n  applyMask,\n  applyCurrencyMask,\n  applyPercentageMask,\n  getUnmaskedValue,\n  calculateCursorPosition,\n  toUnmaskedIndex,\n  fromUnmaskedIndex,\n  type MaskPattern,\n  type MaskPatternKey,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}