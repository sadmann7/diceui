{
  "name": "mask-input",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/mask-input.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\ninterface MaskPattern {\n  pattern: string;\n  placeholder: string;\n  transform?: (value: string) => string;\n  validate?: (value: string) => boolean;\n}\n\ntype MaskPatternKey =\n  | \"phone\"\n  | \"ssn\"\n  | \"date\"\n  | \"time\"\n  | \"creditCard\"\n  | \"zipCode\"\n  | \"zipCodeExtended\";\n\nconst MASK_PATTERNS: Record<MaskPatternKey, MaskPattern> = {\n  phone: {\n    pattern: \"(###) ###-####\",\n    placeholder: \"(___) ___-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{10}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  ssn: {\n    pattern: \"###-##-####\",\n    placeholder: \"___-__-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  date: {\n    pattern: \"##/##/####\",\n    placeholder: \"mm/dd/yyyy\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => {\n      const cleaned = value.replace(/\\D/g, \"\");\n      if (cleaned.length !== 8) return false;\n      const month = parseInt(cleaned.substring(0, 2), 10);\n      const day = parseInt(cleaned.substring(2, 4), 10);\n      const year = parseInt(cleaned.substring(4, 8), 10);\n      return month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 1900;\n    },\n  },\n  time: {\n    pattern: \"##:##\",\n    placeholder: \"hh:mm\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => {\n      const cleaned = value.replace(/\\D/g, \"\");\n      if (cleaned.length !== 4) return false;\n      const hours = parseInt(cleaned.substring(0, 2), 10);\n      const minutes = parseInt(cleaned.substring(2, 4), 10);\n      return hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59;\n    },\n  },\n  creditCard: {\n    pattern: \"#### #### #### ####\",\n    placeholder: \"____ ____ ____ ____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{16}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  zipCode: {\n    pattern: \"#####\",\n    placeholder: \"_____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{5}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  zipCodeExtended: {\n    pattern: \"#####-####\",\n    placeholder: \"_____-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n};\n\nfunction applyMask(\n  value: string,\n  pattern: string,\n  transform?: (value: string) => string,\n): string {\n  const cleanValue = transform ? transform(value) : value;\n  let masked = \"\";\n  let valueIndex = 0;\n\n  for (let i = 0; i < pattern.length && valueIndex < cleanValue.length; i++) {\n    const patternChar = pattern[i];\n    const valueChar = cleanValue[valueIndex];\n\n    if (patternChar === \"#\") {\n      masked += valueChar;\n      valueIndex++;\n    } else {\n      masked += patternChar;\n    }\n  }\n\n  return masked;\n}\n\nfunction getUnmaskedValue(\n  value: string,\n  transform?: (value: string) => string,\n): string {\n  return transform ? transform(value) : value.replace(/\\D/g, \"\");\n}\n\ntype InputElement = React.ComponentRef<typeof MaskInput>;\n\ninterface MaskInputProps extends React.ComponentProps<\"input\"> {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (\n    value: string,\n    unmaskedValue: string,\n    event: React.ChangeEvent<InputElement>,\n  ) => void;\n  onValidate?: (isValid: boolean, value: string) => void;\n  mask?: MaskPatternKey | MaskPattern;\n  asChild?: boolean;\n  invalid?: boolean;\n  withoutMask?: boolean;\n}\n\nfunction MaskInput(props: MaskInputProps) {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange: onValueChangeProp,\n    onValidate,\n    onBlur: onBlurProp,\n    onFocus: onFocusProp,\n    onKeyDown: onKeyDownProp,\n    onPaste: onPasteProp,\n    mask,\n    placeholder: placeholderProp,\n    asChild = false,\n    disabled = false,\n    invalid = false,\n    readOnly = false,\n    required = false,\n    withoutMask = false,\n    className,\n    ref,\n    ...inputProps\n  } = props;\n\n  const [internalValue, setInternalValue] = React.useState(defaultValue || \"\");\n  const [isFocused, setIsFocused] = React.useState(false);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const composedRef = useComposedRefs(ref, inputRef);\n\n  const isControlled = valueProp !== undefined;\n  const value = isControlled ? valueProp : internalValue;\n\n  const maskPattern = React.useMemo(() => {\n    if (typeof mask === \"string\") {\n      return MASK_PATTERNS[mask];\n    }\n    return mask;\n  }, [mask]);\n\n  const placeholder = React.useMemo(() => {\n    if (placeholderProp) return placeholderProp;\n    if (!withoutMask && maskPattern && isFocused) {\n      return maskPattern.placeholder;\n    }\n    return maskPattern?.placeholder || placeholderProp;\n  }, [placeholderProp, withoutMask, maskPattern, isFocused]);\n\n  const displayValue = React.useMemo(() => {\n    if (!maskPattern || !value) return value;\n    return applyMask(value, maskPattern.pattern, maskPattern.transform);\n  }, [value, maskPattern]);\n\n  const onValueChange = React.useCallback(\n    (event: React.ChangeEvent<InputElement>) => {\n      const inputValue = event.target.value;\n      let newValue = inputValue;\n      let unmaskedValue = inputValue;\n\n      if (maskPattern) {\n        const previousValue = inputRef.current?.value || \"\";\n\n        unmaskedValue = getUnmaskedValue(inputValue, maskPattern.transform);\n        newValue = applyMask(\n          unmaskedValue,\n          maskPattern.pattern,\n          maskPattern.transform,\n        );\n\n        // Calculate the correct cursor position based on the change\n        if (inputRef.current && newValue !== inputValue) {\n          inputRef.current.value = newValue;\n\n          // Calculate new cursor position based on unmasked characters entered\n          const previousUnmasked = getUnmaskedValue(\n            previousValue,\n            maskPattern.transform,\n          );\n          const currentUnmasked = getUnmaskedValue(\n            newValue,\n            maskPattern.transform,\n          );\n\n          let newCursorPosition = 0;\n          let unmaskedIndex = 0;\n\n          // Find the cursor position by counting unmasked characters\n          for (\n            let i = 0;\n            i < newValue.length && unmaskedIndex < currentUnmasked.length;\n            i++\n          ) {\n            const patternChar = maskPattern.pattern[i];\n            if (patternChar === \"#\") {\n              unmaskedIndex++;\n              if (unmaskedIndex <= currentUnmasked.length) {\n                newCursorPosition = i + 1;\n              }\n            }\n          }\n\n          // If we're at the end of input, position cursor after last character\n          if (currentUnmasked.length > previousUnmasked.length) {\n            // Find the position after the last entered character\n            let charCount = 0;\n            for (let i = 0; i < newValue.length; i++) {\n              if (maskPattern.pattern[i] === \"#\") {\n                charCount++;\n                if (charCount === currentUnmasked.length) {\n                  newCursorPosition = i + 1;\n                  break;\n                }\n              }\n            }\n          }\n\n          newCursorPosition = Math.min(newCursorPosition, newValue.length);\n\n          // Set cursor position immediately for better responsiveness\n          inputRef.current.setSelectionRange(\n            newCursorPosition,\n            newCursorPosition,\n          );\n        }\n      }\n\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n\n      // Validate if validation function is provided\n      if (onValidate && maskPattern?.validate) {\n        const isValid = maskPattern.validate(unmaskedValue);\n        onValidate(isValid, unmaskedValue);\n      }\n\n      onValueChangeProp?.(newValue, unmaskedValue, event);\n    },\n    [maskPattern, isControlled, onValueChangeProp, onValidate],\n  );\n\n  const onFocus = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onFocusProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsFocused(true);\n    },\n    [onFocusProp],\n  );\n\n  const onBlur = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onBlurProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsFocused(false);\n    },\n    [onBlurProp],\n  );\n\n  const onPaste = React.useCallback(\n    (event: React.ClipboardEvent<InputElement>) => {\n      onPasteProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (!maskPattern) return;\n\n      event.preventDefault();\n      const pastedText = event.clipboardData.getData(\"text\");\n      const target = event.target as InputElement;\n      const cursorPosition = target.selectionStart || 0;\n      const currentValue = target.value;\n\n      // Get the unmasked pasted text\n      const unmaskedPasted = getUnmaskedValue(\n        pastedText,\n        maskPattern.transform,\n      );\n\n      // Get current unmasked value\n      const currentUnmasked = getUnmaskedValue(\n        currentValue,\n        maskPattern.transform,\n      );\n\n      // Calculate where to insert in the unmasked value\n      let insertPosition = 0;\n      let charCount = 0;\n      for (let i = 0; i < cursorPosition && i < currentValue.length; i++) {\n        if (\n          maskPattern.pattern[charCount] === \"#\" &&\n          currentValue[i] !== maskPattern.placeholder?.[i]\n        ) {\n          insertPosition++;\n        }\n        if (\n          maskPattern.pattern[charCount] === \"#\" ||\n          currentValue[i] === maskPattern.pattern[charCount]\n        ) {\n          charCount++;\n        }\n      }\n\n      // Create new unmasked value with pasted content\n      const newUnmaskedValue =\n        currentUnmasked.slice(0, insertPosition) +\n        unmaskedPasted +\n        currentUnmasked.slice(insertPosition);\n\n      // Apply mask to the new value\n      const newMaskedValue = applyMask(\n        newUnmaskedValue,\n        maskPattern.pattern,\n        maskPattern.transform,\n      );\n\n      // Update the input\n      target.value = newMaskedValue;\n\n      // Position cursor after pasted content\n      let newCursorPosition = 0;\n      let unmaskedIndex = 0;\n      const targetUnmaskedLength = insertPosition + unmaskedPasted.length;\n\n      for (\n        let i = 0;\n        i < newMaskedValue.length && unmaskedIndex < targetUnmaskedLength;\n        i++\n      ) {\n        if (maskPattern.pattern[i] === \"#\") {\n          unmaskedIndex++;\n          if (unmaskedIndex <= targetUnmaskedLength) {\n            newCursorPosition = i + 1;\n          }\n        }\n      }\n\n      target.setSelectionRange(newCursorPosition, newCursorPosition);\n\n      // Trigger change event\n      const syntheticEvent = {\n        ...event,\n        target: {\n          ...target,\n          value: newMaskedValue,\n          selectionStart: newCursorPosition,\n        },\n      } as unknown as React.ChangeEvent<InputElement>;\n\n      onValueChange(syntheticEvent);\n    },\n    [maskPattern, onValueChange, onPasteProp],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<InputElement>) => {\n      onKeyDownProp?.(event);\n      if (event.defaultPrevented) return;\n\n      // Handle backspace to remove mask characters properly\n      if (event.key === \"Backspace\" && maskPattern) {\n        const target = event.target as InputElement;\n        const cursorPosition = target.selectionStart || 0;\n        const currentValue = target.value;\n\n        if (cursorPosition > 0) {\n          const charBeforeCursor = currentValue[cursorPosition - 1];\n          // If the character before cursor is a mask character, move cursor back further\n          if (charBeforeCursor && !/\\d/.test(charBeforeCursor)) {\n            event.preventDefault();\n            const newCursorPosition = Math.max(0, cursorPosition - 2);\n            target.setSelectionRange(newCursorPosition, newCursorPosition);\n\n            const newValue =\n              currentValue.slice(0, newCursorPosition) +\n              currentValue.slice(cursorPosition);\n            const syntheticEvent = {\n              ...event,\n              target: { ...target, value: newValue },\n            } as React.ChangeEvent<InputElement>;\n\n            onValueChange(syntheticEvent);\n            return;\n          }\n        }\n      }\n    },\n    [maskPattern, onKeyDownProp, onValueChange],\n  );\n\n  const InputPrimitive = asChild ? Slot : \"input\";\n\n  return (\n    <InputPrimitive\n      aria-invalid={invalid}\n      data-disabled={disabled ? \"\" : undefined}\n      data-readonly={readOnly ? \"\" : undefined}\n      data-required={required ? \"\" : undefined}\n      data-invalid={invalid ? \"\" : undefined}\n      data-slot=\"mask-input\"\n      {...inputProps}\n      ref={composedRef}\n      value={displayValue}\n      placeholder={placeholder}\n      disabled={disabled}\n      readOnly={readOnly}\n      required={required}\n      className={cn(\n        \"flex h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs outline-none transition-[color,box-shadow] selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30\",\n        \"focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50\",\n        \"aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40\",\n        className,\n      )}\n      onChange={onValueChange}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onKeyDown={onKeyDown}\n      onPaste={onPaste}\n    />\n  );\n}\n\nexport {\n  MaskInput,\n  MASK_PATTERNS,\n  applyMask,\n  getUnmaskedValue,\n  type MaskPattern,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}