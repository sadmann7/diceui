{
  "name": "mask-input",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/mask-input.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\ninterface MaskPattern {\n  pattern: string;\n  placeholder?: string;\n  transform?: (value: string) => string;\n  validate?: (value: string) => boolean;\n}\n\ntype MaskPatternKey =\n  | \"phone\"\n  | \"ssn\"\n  | \"date\"\n  | \"time\"\n  | \"creditCard\"\n  | \"zipCode\"\n  | \"zipCodeExtended\"\n  | \"currency\"\n  | \"percentage\"\n  | \"licensePlate\"\n  | \"ipv4\"\n  | \"macAddress\"\n  | \"isbn\"\n  | \"ein\";\n\nconst MASK_PATTERNS: Record<MaskPatternKey, MaskPattern> = {\n  phone: {\n    pattern: \"(###) ###-####\",\n    placeholder: \"(___) ___-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{10}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  ssn: {\n    pattern: \"###-##-####\",\n    placeholder: \"___-__-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  date: {\n    pattern: \"##/##/####\",\n    placeholder: \"mm/dd/yyyy\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => {\n      const cleaned = value.replace(/\\D/g, \"\");\n      if (cleaned.length !== 8) return false;\n      const month = parseInt(cleaned.substring(0, 2), 10);\n      const day = parseInt(cleaned.substring(2, 4), 10);\n      const year = parseInt(cleaned.substring(4, 8), 10);\n\n      const currentYear = new Date().getFullYear();\n      const minYear = currentYear - 120;\n      const maxYear = currentYear + 10;\n      if (\n        month < 1 ||\n        month > 12 ||\n        day < 1 ||\n        year < minYear ||\n        year > maxYear\n      )\n        return false;\n\n      const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n      const isLeapYear =\n        (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n      if (isLeapYear && month === 2) {\n        daysInMonth[1] = 29;\n      }\n\n      return day <= (daysInMonth[month - 1] ?? 31);\n    },\n  },\n  time: {\n    pattern: \"##:##\",\n    placeholder: \"hh:mm\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => {\n      const cleaned = value.replace(/\\D/g, \"\");\n      if (cleaned.length !== 4) return false;\n      const hours = parseInt(cleaned.substring(0, 2), 10);\n      const minutes = parseInt(cleaned.substring(2, 4), 10);\n      return hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59;\n    },\n  },\n  creditCard: {\n    pattern: \"#### #### #### ####\",\n    placeholder: \"____ ____ ____ ____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{16}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  zipCode: {\n    pattern: \"#####\",\n    placeholder: \"_____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{5}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  zipCodeExtended: {\n    pattern: \"#####-####\",\n    placeholder: \"_____-____\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  currency: {\n    pattern: \"$###,###.##\",\n    placeholder: \"$0.00\",\n    transform: (value, { currency = \"USD\", locale = \"en-US\" } = {}) => {\n      let localeDecimalSeparator = \".\";\n\n      try {\n        const formatter = new Intl.NumberFormat(locale, {\n          style: \"currency\",\n          currency: currency,\n          minimumFractionDigits: 0,\n          maximumFractionDigits: 2,\n        });\n        const parts = formatter.formatToParts(1234.5);\n        const decimalPart = parts.find((part) => part.type === \"decimal\");\n\n        if (decimalPart) localeDecimalSeparator = decimalPart.value;\n      } catch {\n        // Keep defaults\n      }\n\n      const cleaned = value.replace(/[^\\d.,]/g, \"\");\n\n      const dotIndex = cleaned.indexOf(\".\");\n      const commaIndex = cleaned.indexOf(\",\");\n\n      let hasDecimalSeparator = false;\n      let decimalIndex = -1;\n\n      if (localeDecimalSeparator === \",\") {\n        if (commaIndex !== -1) {\n          const afterComma = cleaned.substring(commaIndex + 1);\n\n          const looksLikeDecimal = afterComma.length <= 2;\n\n          if (looksLikeDecimal) {\n            hasDecimalSeparator = true;\n            decimalIndex = commaIndex;\n          }\n        }\n      } else {\n        if (dotIndex !== -1) {\n          const afterDot = cleaned.substring(dotIndex + 1);\n\n          const looksLikeDecimal = afterDot.length <= 2;\n\n          if (looksLikeDecimal) {\n            hasDecimalSeparator = true;\n            decimalIndex = dotIndex;\n          }\n        }\n\n        if (commaIndex !== -1 && !hasDecimalSeparator) {\n          const afterComma = cleaned.substring(commaIndex + 1);\n\n          const looksLikeThousands = commaIndex <= 3 && afterComma.length >= 3;\n\n          if (!looksLikeThousands) {\n            hasDecimalSeparator = true;\n            decimalIndex = commaIndex;\n          }\n        }\n      }\n\n      if (hasDecimalSeparator && decimalIndex !== -1) {\n        const beforeDecimal = cleaned\n          .substring(0, decimalIndex)\n          .replace(/[.,]/g, \"\");\n        const afterDecimal = cleaned\n          .substring(decimalIndex + 1)\n          .replace(/[.,]/g, \"\");\n        const result = `${beforeDecimal}.${afterDecimal.substring(0, 2)}`;\n        return result;\n      }\n\n      const digitsOnly = cleaned.replace(/[.,]/g, \"\");\n      return digitsOnly;\n    },\n    validate: (value) => {\n      if (!/^\\d+(\\.\\d{1,2})?$/.test(value)) return false;\n      const num = parseFloat(value);\n      return !Number.isNaN(num) && num >= 0 && num <= 999999999.99;\n    },\n  },\n  percentage: {\n    pattern: \"##.##%\",\n    placeholder: \"0.00%\",\n    transform: (value) => {\n      const cleaned = value.replace(/[^\\d.]/g, \"\");\n      const parts = cleaned.split(\".\");\n      if (parts.length > 2) {\n        return `${parts[0]}.${parts.slice(1).join(\"\")}`;\n      }\n      if (parts[1] && parts[1].length > 2) {\n        return `${parts[0]}.${parts[1].substring(0, 2)}`;\n      }\n      return cleaned;\n    },\n    validate: (value) => {\n      const num = parseFloat(value);\n      return !Number.isNaN(num) && num >= 0 && num <= 100;\n    },\n  },\n  licensePlate: {\n    pattern: \"###-###\",\n    placeholder: \"ABC-123\",\n    transform: (value) => value.replace(/[^A-Z0-9]/gi, \"\").toUpperCase(),\n    validate: (value) => /^[A-Z0-9]{6}$/.test(value),\n  },\n  ipv4: {\n    pattern: \"###.###.###.###\",\n    placeholder: \"192.168.1.1\",\n    transform: (value) => value.replace(/[^0-9.]/g, \"\"),\n    validate: (value) => {\n      if (value.includes(\".\")) {\n        const segments = value.split(\".\");\n        if (segments.length > 4) return false;\n\n        return segments.every((segment) => {\n          if (segment === \"\") return true;\n          if (!/^\\d{1,3}$/.test(segment)) return false;\n          const num = parseInt(segment, 10);\n          return num >= 0 && num <= 255;\n        });\n      } else {\n        if (!/^\\d+$/.test(value)) return false;\n        if (value.length > 12) return false; // Max 4 segments * 3 digits each\n\n        const chunks = [];\n        for (let i = 0; i < value.length; i += 3) {\n          chunks.push(value.substring(i, i + 3));\n        }\n\n        if (chunks.length > 4) return false;\n\n        return chunks.every((chunk) => {\n          const num = parseInt(chunk, 10);\n          return num >= 0 && num <= 255;\n        });\n      }\n    },\n  },\n  macAddress: {\n    pattern: \"##:##:##:##:##:##\",\n    placeholder: \"00:1B:44:11:3A:B7\",\n    transform: (value) => value.replace(/[^A-F0-9]/gi, \"\").toUpperCase(),\n    validate: (value) => /^[A-F0-9]{12}$/.test(value),\n  },\n  isbn: {\n    pattern: \"###-#-###-#####-#\",\n    placeholder: \"978-0-123-45678-9\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{13}$/.test(value.replace(/\\D/g, \"\")),\n  },\n  ein: {\n    pattern: \"##-#######\",\n    placeholder: \"12-3456789\",\n    transform: (value) => value.replace(/\\D/g, \"\"),\n    validate: (value) => /^\\d{9}$/.test(value.replace(/\\D/g, \"\")),\n  },\n};\n\nfunction applyMask(\n  value: string,\n  pattern: string,\n  transform?: (value: string) => string,\n  currency?: string,\n  locale?: string,\n  maskType?: string,\n): string {\n  const cleanValue = transform ? transform(value) : value;\n\n  if (\n    pattern.includes(\"$\") ||\n    pattern.includes(\"€\") ||\n    maskType === \"currency\"\n  ) {\n    return applyCurrencyMask(cleanValue, currency, locale);\n  }\n\n  if (pattern.includes(\"%\")) {\n    return applyPercentageMask(cleanValue);\n  }\n\n  if (maskType === \"ipv4\") {\n    return cleanValue;\n  }\n\n  let masked = \"\";\n  let valueIndex = 0;\n\n  for (let i = 0; i < pattern.length && valueIndex < cleanValue.length; i++) {\n    const patternChar = pattern[i];\n    const valueChar = cleanValue[valueIndex];\n\n    if (patternChar === \"#\") {\n      masked += valueChar;\n      valueIndex++;\n    } else {\n      masked += patternChar;\n    }\n  }\n\n  return masked;\n}\n\nfunction applyCurrencyMask(\n  value: string,\n  currency = \"USD\",\n  locale = \"en-US\",\n): string {\n  if (!value) return \"\";\n\n  let currencySymbol = \"$\";\n  let decimalSeparator = \".\";\n  let groupSeparator = \",\";\n\n  try {\n    const formatter = new Intl.NumberFormat(locale, {\n      style: \"currency\",\n      currency: currency,\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 2,\n    });\n    const parts = formatter.formatToParts(1234.5);\n    const currencyPart = parts.find((part) => part.type === \"currency\");\n    const decimalPart = parts.find((part) => part.type === \"decimal\");\n    const groupPart = parts.find((part) => part.type === \"group\");\n\n    if (currencyPart) currencySymbol = currencyPart.value;\n    if (decimalPart) decimalSeparator = decimalPart.value;\n    if (groupPart) groupSeparator = groupPart.value;\n  } catch {\n    currencySymbol = \"$\";\n    decimalSeparator = \".\";\n    groupSeparator = \",\";\n  }\n\n  const normalizedValue = value\n    .replace(\n      new RegExp(\n        `\\\\${groupSeparator.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\")}`,\n        \"g\",\n      ),\n      \"\",\n    )\n    .replace(decimalSeparator, \".\");\n\n  const parts = normalizedValue.split(\".\");\n  const integerPart = parts[0] ?? \"\";\n  const fractionalPart = parts[1] ?? \"\";\n\n  if (!integerPart && !fractionalPart) return \"\";\n\n  const intValue = integerPart || \"0\";\n  const fracValue = fractionalPart.slice(0, 2);\n\n  const num = Number(`${intValue}.${fracValue || \"\"}`);\n\n  if (Number.isNaN(num)) {\n    const cleanedDigits = value.replace(/[^\\d]/g, \"\");\n    if (!cleanedDigits) return \"\";\n    return `${currencySymbol}${cleanedDigits}`;\n  }\n\n  const hasExplicitDecimal =\n    value.includes(\".\") || value.includes(decimalSeparator);\n\n  try {\n    const result = new Intl.NumberFormat(locale, {\n      style: \"currency\",\n      currency: currency,\n      minimumFractionDigits: fracValue ? fracValue.length : 0,\n      maximumFractionDigits: 2,\n    }).format(num);\n\n    if (hasExplicitDecimal && !fracValue) {\n      if (result.match(/^[^\\d\\s]+/)) {\n        return result.replace(/(\\d)$/, `$1${decimalSeparator}`);\n      } else {\n        return result.replace(\n          /(\\d)(\\s*)([^\\d\\s]+)$/,\n          `$1${decimalSeparator}$2$3`,\n        );\n      }\n    }\n\n    return result;\n  } catch {\n    const formattedInt = intValue.replace(\n      /\\B(?=(\\d{3})+(?!\\d))/g,\n      groupSeparator,\n    );\n    let result = `${currencySymbol}${formattedInt}`;\n    if (hasExplicitDecimal) {\n      result += `${decimalSeparator}${fracValue}`;\n    }\n\n    return result;\n  }\n}\n\nfunction applyPercentageMask(value: string): string {\n  if (!value) return \"\";\n\n  const parts = value.split(\".\");\n  let result = parts[0] ?? \"0\";\n\n  if (value.includes(\".\")) {\n    result += `.${(parts[1] ?? \"\").substring(0, 2)}`;\n  }\n\n  return `${result}%`;\n}\n\nfunction getUnmaskedValue(\n  value: string,\n  transform?: (\n    value: string,\n    options?: { currency?: string; locale?: string },\n  ) => string,\n  currency?: string,\n  locale?: string,\n): string {\n  return transform\n    ? transform(value, { currency, locale })\n    : value.replace(/\\D/g, \"\");\n}\n\nfunction toUnmaskedIndex(\n  masked: string,\n  pattern: string,\n  caret: number,\n): number {\n  let idx = 0;\n  for (let i = 0; i < caret && i < masked.length && i < pattern.length; i++) {\n    if (pattern[i] === \"#\") {\n      idx++;\n    }\n  }\n  return idx;\n}\n\nfunction fromUnmaskedIndex(\n  masked: string,\n  pattern: string,\n  uIdx: number,\n): number {\n  let seen = 0;\n  for (let i = 0; i < masked.length && i < pattern.length; i++) {\n    if (pattern[i] === \"#\") {\n      seen++;\n      if (seen === uIdx) {\n        return i + 1;\n      }\n    }\n  }\n  return masked.length;\n}\n\ntype InputElement = HTMLInputElement;\n\ntype ValidationMode = \"onChange\" | \"onBlur\" | \"onSubmit\" | \"onTouched\" | \"all\";\n\ninterface MaskInputProps extends React.ComponentProps<\"input\"> {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (\n    maskedValue: string,\n    unmaskedValue: string,\n    event?: React.ChangeEvent<InputElement>,\n  ) => void;\n  onValidate?: (isValid: boolean, unmaskedValue: string) => void;\n  validationMode?: ValidationMode;\n  mask?: MaskPatternKey | MaskPattern;\n  asChild?: boolean;\n  invalid?: boolean;\n  withoutMask?: boolean;\n  currency?: string;\n  locale?: string;\n}\n\nfunction MaskInput(props: MaskInputProps) {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange: onValueChangeProp,\n    onValidate,\n    onBlur: onBlurProp,\n    onFocus: onFocusProp,\n    onKeyDown: onKeyDownProp,\n    onPaste: onPasteProp,\n    onCompositionStart: onCompositionStartProp,\n    onCompositionEnd: onCompositionEndProp,\n    validationMode = \"onChange\",\n    mask,\n    placeholder: placeholderProp,\n    asChild = false,\n    disabled = false,\n    invalid = false,\n    readOnly = false,\n    required = false,\n    withoutMask = false,\n    currency = \"USD\",\n    locale = \"en-US\",\n    className,\n    ref,\n    ...inputProps\n  } = props;\n\n  const [internalValue, setInternalValue] = React.useState(defaultValue ?? \"\");\n  const [focused, setFocused] = React.useState(false);\n  const [composing, setComposing] = React.useState(false);\n  const [touched, setTouched] = React.useState(false);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const composedRef = useComposedRefs(ref, inputRef);\n\n  const isControlled = valueProp !== undefined;\n  const value = isControlled ? valueProp : internalValue;\n\n  const maskPattern = React.useMemo(() => {\n    if (typeof mask === \"string\") {\n      return MASK_PATTERNS[mask];\n    }\n    return mask;\n  }, [mask]);\n\n  const maskType = typeof mask === \"string\" ? mask : undefined;\n\n  const placeholder = React.useMemo(() => {\n    if (withoutMask) return placeholderProp;\n\n    if (placeholderProp) {\n      if (focused && maskPattern) {\n        if (\n          maskType === \"currency\" ||\n          maskPattern.pattern.includes(\"$\") ||\n          maskPattern.pattern.includes(\"€\")\n        ) {\n          let currencySymbol = \"$\";\n          try {\n            const formatter = new Intl.NumberFormat(locale, {\n              style: \"currency\",\n              currency: currency,\n              minimumFractionDigits: 0,\n              maximumFractionDigits: 0,\n            });\n            const parts = formatter.formatToParts(0);\n            const currencyPart = parts.find((part) => part.type === \"currency\");\n            if (currencyPart) {\n              currencySymbol = currencyPart.value;\n            }\n          } catch {\n            currencySymbol = \"$\";\n          }\n          try {\n            const formatter = new Intl.NumberFormat(locale, {\n              style: \"currency\",\n              currency: currency,\n              minimumFractionDigits: 2,\n              maximumFractionDigits: 2,\n            });\n            return formatter.format(0);\n          } catch {\n            return `${currencySymbol}0.00`;\n          }\n        }\n        if (maskType === \"percentage\" || maskPattern.pattern.includes(\"%\")) {\n          return \"0.00%\";\n        }\n        return maskPattern?.placeholder ?? placeholderProp;\n      }\n      return placeholderProp;\n    }\n\n    if (focused && maskPattern) {\n      if (\n        maskType === \"currency\" ||\n        maskPattern.pattern.includes(\"$\") ||\n        maskPattern.pattern.includes(\"€\")\n      ) {\n        let currencySymbol = \"$\";\n        try {\n          const formatter = new Intl.NumberFormat(locale, {\n            style: \"currency\",\n            currency: currency,\n            minimumFractionDigits: 0,\n            maximumFractionDigits: 0,\n          });\n          const parts = formatter.formatToParts(0);\n          const currencyPart = parts.find((part) => part.type === \"currency\");\n          if (currencyPart) {\n            currencySymbol = currencyPart.value;\n          }\n        } catch {\n          currencySymbol = \"$\";\n        }\n        return `${currencySymbol}0.00`;\n      }\n      if (maskType === \"percentage\" || maskPattern.pattern.includes(\"%\")) {\n        return \"0.00%\";\n      }\n      return maskPattern?.placeholder;\n    }\n\n    return undefined;\n  }, [\n    placeholderProp,\n    withoutMask,\n    maskPattern,\n    focused,\n    maskType,\n    currency,\n    locale,\n  ]);\n\n  const displayValue = React.useMemo(() => {\n    if (withoutMask || !maskPattern || !value) return value ?? \"\";\n    return applyMask(\n      value,\n      maskPattern.pattern,\n      maskPattern.transform,\n      currency,\n      locale,\n      maskType,\n    );\n  }, [value, maskPattern, withoutMask, currency, locale, maskType]);\n\n  const tokenCount = React.useMemo(() => {\n    if (!maskPattern || /[€$%]/.test(maskPattern.pattern)) return undefined;\n    return maskPattern.pattern.match(/#/g)?.length ?? 0;\n  }, [maskPattern]);\n\n  const calculatedMaxLength = tokenCount\n    ? maskPattern?.pattern.length\n    : inputProps.maxLength;\n\n  const calculatedInputMode = React.useMemo(() => {\n    if (inputProps.inputMode) return inputProps.inputMode;\n    if (!maskPattern) return undefined;\n\n    // Use decimal for patterns that need decimal point input\n    if (\n      maskType === \"currency\" ||\n      maskType === \"percentage\" ||\n      maskType === \"ipv4\"\n    ) {\n      return \"decimal\";\n    }\n\n    const numericPatterns =\n      /^(phone|zipCode|zipCodeExtended|ssn|ein|time|date|creditCard)$/;\n    if (typeof mask === \"string\" && numericPatterns.test(mask)) {\n      return \"numeric\";\n    }\n    return undefined;\n  }, [maskPattern, mask, maskType, inputProps.inputMode]);\n\n  const shouldValidate = React.useCallback(\n    (trigger: \"change\" | \"blur\") => {\n      if (!onValidate || !maskPattern?.validate) return false;\n\n      switch (validationMode) {\n        case \"onChange\":\n          return trigger === \"change\";\n        case \"onBlur\":\n          return trigger === \"blur\";\n        case \"onSubmit\":\n          return false;\n        case \"onTouched\":\n          return touched ? trigger === \"change\" : trigger === \"blur\";\n        case \"all\":\n          return true;\n        default:\n          return trigger === \"change\";\n      }\n    },\n    [onValidate, maskPattern, validationMode, touched],\n  );\n\n  const onInputValidate = React.useCallback(\n    (unmaskedValue: string) => {\n      if (onValidate && maskPattern?.validate) {\n        const isValid = maskPattern.validate(unmaskedValue);\n        onValidate(isValid, unmaskedValue);\n      }\n    },\n    [onValidate, maskPattern],\n  );\n\n  const onValueChange = React.useCallback(\n    (event: React.ChangeEvent<InputElement>) => {\n      const inputValue = event.target.value;\n      let newValue = inputValue;\n      let unmaskedValue = inputValue;\n\n      if (composing) {\n        if (!isControlled) {\n          setInternalValue(inputValue);\n        }\n        return;\n      }\n\n      if (withoutMask || !maskPattern) {\n        if (!isControlled) {\n          setInternalValue(inputValue);\n        }\n        if (shouldValidate(\"change\")) {\n          onValidate?.(true, inputValue);\n        }\n        onValueChangeProp?.(inputValue, inputValue, event);\n        return;\n      }\n\n      if (maskPattern) {\n        unmaskedValue = getUnmaskedValue(\n          inputValue,\n          maskPattern.transform,\n          currency,\n          locale,\n        );\n        newValue = applyMask(\n          unmaskedValue,\n          maskPattern.pattern,\n          maskPattern.transform,\n          currency,\n          locale,\n          maskType,\n        );\n\n        if (inputRef.current && newValue !== inputValue) {\n          inputRef.current.value = newValue;\n\n          const currentUnmasked = getUnmaskedValue(\n            newValue,\n            maskPattern.transform,\n            currency,\n            locale,\n          );\n\n          let newCursorPosition: number;\n          if (\n            maskPattern.pattern.includes(\"$\") ||\n            maskPattern.pattern.includes(\"€\") ||\n            maskPattern.pattern.includes(\"%\")\n          ) {\n            if (maskType === \"currency\") {\n              try {\n                const formatter = new Intl.NumberFormat(locale, {\n                  style: \"currency\",\n                  currency: currency,\n                  minimumFractionDigits: 0,\n                  maximumFractionDigits: 0,\n                });\n                const sampleFormat = formatter.format(123);\n                const currencyAtEnd = /\\d\\s*[^\\d\\s]+$/.test(sampleFormat);\n\n                if (currencyAtEnd) {\n                  const match = newValue.match(/(\\d)\\s*([^\\d\\s]+)$/);\n                  if (match?.[1]) {\n                    newCursorPosition = newValue.lastIndexOf(match[1]) + 1;\n                  } else {\n                    newCursorPosition = newValue.length;\n                  }\n                } else {\n                  newCursorPosition = newValue.length;\n                }\n              } catch {\n                newCursorPosition = newValue.length;\n              }\n            } else {\n              newCursorPosition = newValue.length;\n            }\n          } else {\n            let position = 0;\n            let unmaskedCount = 0;\n\n            for (\n              let i = 0;\n              i < maskPattern.pattern.length && i < newValue.length;\n              i++\n            ) {\n              if (maskPattern.pattern[i] === \"#\") {\n                unmaskedCount++;\n                if (unmaskedCount <= currentUnmasked.length) {\n                  position = i + 1;\n                }\n              }\n            }\n            newCursorPosition = position;\n          }\n\n          if (\n            maskPattern.pattern.includes(\"$\") ||\n            maskPattern.pattern.includes(\"€\")\n          ) {\n            if (maskType === \"currency\") {\n              try {\n                const formatter = new Intl.NumberFormat(locale, {\n                  style: \"currency\",\n                  currency: currency,\n                  minimumFractionDigits: 0,\n                  maximumFractionDigits: 0,\n                });\n                const sampleFormat = formatter.format(123);\n                const currencyAtEnd = /\\d\\s*[^\\d\\s]+$/.test(sampleFormat);\n\n                if (!currencyAtEnd) {\n                  newCursorPosition = Math.max(1, newCursorPosition);\n                }\n              } catch {\n                newCursorPosition = Math.max(1, newCursorPosition);\n              }\n            } else {\n              newCursorPosition = Math.max(1, newCursorPosition);\n            }\n          } else if (maskPattern.pattern.includes(\"%\")) {\n            newCursorPosition = Math.min(\n              newValue.length - 1,\n              newCursorPosition,\n            );\n          }\n\n          newCursorPosition = Math.min(newCursorPosition, newValue.length);\n\n          inputRef.current.setSelectionRange(\n            newCursorPosition,\n            newCursorPosition,\n          );\n        }\n      }\n\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n\n      if (shouldValidate(\"change\")) {\n        onInputValidate(unmaskedValue);\n      }\n\n      onValueChangeProp?.(newValue, unmaskedValue, event);\n    },\n    [\n      maskPattern,\n      isControlled,\n      onValueChangeProp,\n      onValidate,\n      onInputValidate,\n      composing,\n      shouldValidate,\n      withoutMask,\n      currency,\n      locale,\n      maskType,\n    ],\n  );\n\n  const onFocus = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onFocusProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setFocused(true);\n    },\n    [onFocusProp],\n  );\n\n  const onBlur = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onBlurProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setFocused(false);\n\n      if (!touched) {\n        setTouched(true);\n      }\n\n      if (shouldValidate(\"blur\")) {\n        const currentValue = event.target.value;\n        const unmaskedValue = maskPattern\n          ? getUnmaskedValue(\n              currentValue,\n              maskPattern.transform,\n              currency,\n              locale,\n            )\n          : currentValue;\n        onInputValidate(unmaskedValue);\n      }\n    },\n    [\n      onBlurProp,\n      touched,\n      shouldValidate,\n      onInputValidate,\n      maskPattern,\n      currency,\n      locale,\n    ],\n  );\n\n  const onCompositionStart = React.useCallback(\n    (event: React.CompositionEvent<InputElement>) => {\n      onCompositionStartProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setComposing(true);\n    },\n    [onCompositionStartProp],\n  );\n\n  const onCompositionEnd = React.useCallback(\n    (event: React.CompositionEvent<InputElement>) => {\n      onCompositionEndProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setComposing(false);\n      const target = event.target as InputElement;\n      const changeEvent = {\n        ...event,\n        target,\n        currentTarget: target,\n        type: \"change\",\n      } as React.ChangeEvent<InputElement>;\n      onValueChange(changeEvent);\n    },\n    [onCompositionEndProp, onValueChange],\n  );\n\n  const onPaste = React.useCallback(\n    (event: React.ClipboardEvent<InputElement>) => {\n      onPasteProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (withoutMask || !maskPattern) return;\n\n      event.preventDefault();\n      const pastedText = event.clipboardData.getData(\"text\");\n      const target = event.target as InputElement;\n      const cursorPosition = target.selectionStart ?? 0;\n      const currentValue = target.value;\n\n      const unmaskedPasted = getUnmaskedValue(\n        pastedText,\n        maskPattern.transform,\n        currency,\n        locale,\n      );\n\n      const currentUnmasked = getUnmaskedValue(\n        currentValue,\n        maskPattern.transform,\n        currency,\n        locale,\n      );\n\n      let insertPosition = 0;\n      let patternIndex = 0;\n\n      for (\n        let i = 0;\n        i < cursorPosition &&\n        i < currentValue.length &&\n        patternIndex < maskPattern.pattern.length;\n        i++\n      ) {\n        const currentChar = currentValue[i];\n        const patternChar = maskPattern.pattern[patternIndex];\n\n        if (patternChar === \"#\") {\n          if (\n            currentChar &&\n            currentChar !== (maskPattern.placeholder?.[i] ?? \"_\")\n          ) {\n            insertPosition++;\n          }\n          patternIndex++;\n        } else if (currentChar === patternChar) {\n          patternIndex++;\n        } else {\n          break;\n        }\n      }\n\n      const maxLength = maskPattern.pattern.split(\"#\").length - 1;\n      const availableLength = maxLength - currentUnmasked.length;\n      const limitedPasted = unmaskedPasted.slice(\n        0,\n        Math.max(0, availableLength),\n      );\n\n      if (limitedPasted.length === 0) {\n        return;\n      }\n\n      const newUnmaskedValue =\n        currentUnmasked.slice(0, insertPosition) +\n        limitedPasted +\n        currentUnmasked.slice(insertPosition);\n\n      const newMaskedValue = applyMask(\n        newUnmaskedValue,\n        maskPattern.pattern,\n        maskPattern.transform,\n        currency,\n        locale,\n        maskType,\n      );\n\n      target.value = newMaskedValue;\n\n      let newCursorPosition = 0;\n      let unmaskedIndex = 0;\n      const targetUnmaskedLength = insertPosition + limitedPasted.length;\n\n      for (\n        let i = 0;\n        i < newMaskedValue.length && unmaskedIndex < targetUnmaskedLength;\n        i++\n      ) {\n        if (maskPattern.pattern[i] === \"#\") {\n          unmaskedIndex++;\n          if (unmaskedIndex <= targetUnmaskedLength) {\n            newCursorPosition = i + 1;\n          }\n        }\n      }\n\n      target.setSelectionRange(newCursorPosition, newCursorPosition);\n\n      if (!isControlled) {\n        setInternalValue(newMaskedValue);\n      }\n\n      if (shouldValidate(\"change\")) {\n        onInputValidate(newUnmaskedValue);\n      }\n\n      onValueChangeProp?.(newMaskedValue, newUnmaskedValue, undefined);\n    },\n    [\n      maskPattern,\n      onPasteProp,\n      isControlled,\n      onValueChangeProp,\n      shouldValidate,\n      onInputValidate,\n      currency,\n      locale,\n      maskType,\n      withoutMask,\n    ],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<InputElement>) => {\n      onKeyDownProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (withoutMask || !maskPattern) return;\n\n      if (event.key === \"Backspace\") {\n        const target = event.target as InputElement;\n        const cursorPosition = target.selectionStart ?? 0;\n        const selectionEnd = target.selectionEnd ?? 0;\n        const currentValue = target.value;\n\n        if (\n          maskType === \"currency\" ||\n          maskType === \"percentage\" ||\n          maskPattern.pattern.includes(\"$\") ||\n          maskPattern.pattern.includes(\"€\") ||\n          maskPattern.pattern.includes(\"%\")\n        ) {\n          return;\n        }\n\n        if (cursorPosition !== selectionEnd) {\n          return;\n        }\n\n        if (cursorPosition > 0) {\n          const charBeforeCursor = currentValue[cursorPosition - 1];\n\n          const isLiteral = maskPattern.pattern[cursorPosition - 1] !== \"#\";\n\n          if (charBeforeCursor && isLiteral) {\n            event.preventDefault();\n\n            const uIdx = toUnmaskedIndex(\n              currentValue,\n              maskPattern.pattern,\n              cursorPosition,\n            );\n            if (uIdx > 0) {\n              const currentUnmasked = getUnmaskedValue(\n                currentValue,\n                maskPattern.transform,\n                currency,\n                locale,\n              );\n              const nextUnmasked =\n                currentUnmasked.slice(0, uIdx - 1) +\n                currentUnmasked.slice(uIdx);\n              const nextMasked = applyMask(\n                nextUnmasked,\n                maskPattern.pattern,\n                maskPattern.transform,\n                currency,\n                locale,\n                maskType,\n              );\n\n              target.value = nextMasked;\n              const nextCaret = fromUnmaskedIndex(\n                nextMasked,\n                maskPattern.pattern,\n                uIdx - 1,\n              );\n              target.setSelectionRange(nextCaret, nextCaret);\n\n              onValueChangeProp?.(nextMasked, nextUnmasked, undefined);\n            }\n            return;\n          }\n        }\n      }\n\n      if (event.key === \"Delete\") {\n        const target = event.target as InputElement;\n        const cursorPosition = target.selectionStart ?? 0;\n        const selectionEnd = target.selectionEnd ?? 0;\n        const currentValue = target.value;\n\n        if (\n          maskType === \"currency\" ||\n          maskType === \"percentage\" ||\n          maskPattern.pattern.includes(\"$\") ||\n          maskPattern.pattern.includes(\"€\") ||\n          maskPattern.pattern.includes(\"%\")\n        ) {\n          return;\n        }\n\n        if (cursorPosition !== selectionEnd) {\n          return;\n        }\n\n        if (cursorPosition < currentValue.length) {\n          const charAtCursor = currentValue[cursorPosition];\n\n          const isLiteral = maskPattern.pattern[cursorPosition] !== \"#\";\n\n          if (charAtCursor && isLiteral) {\n            event.preventDefault();\n\n            const uIdx = toUnmaskedIndex(\n              currentValue,\n              maskPattern.pattern,\n              cursorPosition,\n            );\n            const currentUnmasked = getUnmaskedValue(\n              currentValue,\n              maskPattern.transform,\n              currency,\n              locale,\n            );\n\n            if (uIdx < currentUnmasked.length) {\n              const nextUnmasked =\n                currentUnmasked.slice(0, uIdx) +\n                currentUnmasked.slice(uIdx + 1);\n              const nextMasked = applyMask(\n                nextUnmasked,\n                maskPattern.pattern,\n                maskPattern.transform,\n                currency,\n                locale,\n                maskType,\n              );\n\n              target.value = nextMasked;\n              const nextCaret = fromUnmaskedIndex(\n                nextMasked,\n                maskPattern.pattern,\n                uIdx,\n              );\n              target.setSelectionRange(nextCaret, nextCaret);\n\n              onValueChangeProp?.(nextMasked, nextUnmasked, undefined);\n            }\n            return;\n          }\n        }\n      }\n    },\n    [\n      maskPattern,\n      onKeyDownProp,\n      onValueChangeProp,\n      currency,\n      locale,\n      maskType,\n      withoutMask,\n    ],\n  );\n\n  const InputPrimitive = asChild ? Slot : \"input\";\n\n  return (\n    <InputPrimitive\n      aria-invalid={invalid}\n      data-disabled={disabled ? \"\" : undefined}\n      data-readonly={readOnly ? \"\" : undefined}\n      data-required={required ? \"\" : undefined}\n      data-invalid={invalid ? \"\" : undefined}\n      data-slot=\"mask-input\"\n      {...inputProps}\n      className={cn(\n        \"flex h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs outline-none transition-[color,box-shadow] selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30\",\n        \"focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50\",\n        \"aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40\",\n        className,\n      )}\n      placeholder={placeholder}\n      ref={composedRef}\n      value={displayValue}\n      disabled={disabled}\n      maxLength={calculatedMaxLength}\n      readOnly={readOnly}\n      required={required}\n      inputMode={calculatedInputMode}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onKeyDown={onKeyDown}\n      onChange={onValueChange}\n      onPaste={onPaste}\n      onCompositionStart={onCompositionStart}\n      onCompositionEnd={onCompositionEnd}\n    />\n  );\n}\n\nexport {\n  MaskInput,\n  //\n  MASK_PATTERNS,\n  //\n  applyMask,\n  applyCurrencyMask,\n  applyPercentageMask,\n  getUnmaskedValue,\n  toUnmaskedIndex,\n  fromUnmaskedIndex,\n  //\n  type MaskPattern,\n  type MaskPatternKey,\n  type ValidationMode,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}