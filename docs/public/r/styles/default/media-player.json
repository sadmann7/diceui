{
  "name": "media-player",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "select",
    "slider",
    "tooltip"
  ],
  "files": [
    {
      "path": "ui/media-player.tsx",
      "content": "\"use client\";\r\n\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from \"@/components/ui/select\";\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipTrigger,\r\n} from \"@/components/ui/tooltip\";\r\nimport { useComposedRefs } from \"@/lib/composition\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport * as SliderPrimitive from \"@radix-ui/react-slider\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport {\r\n  CaptionsOffIcon,\r\n  DownloadIcon,\r\n  FastForwardIcon,\r\n  Maximize2Icon,\r\n  Minimize2Icon,\r\n  PauseIcon,\r\n  PictureInPicture2Icon,\r\n  PictureInPictureIcon,\r\n  PlayIcon,\r\n  Repeat1Icon,\r\n  RepeatIcon,\r\n  RewindIcon,\r\n  SubtitlesIcon,\r\n  Volume1Icon,\r\n  Volume2Icon,\r\n  VolumeXIcon,\r\n} from \"lucide-react\";\r\nimport * as React from \"react\";\r\n\r\nconst POINTER_MOVE_THROTTLE_MS = 16;\r\nconst SEEK_THROTTLE_MS = 100;\r\nconst SEEK_AMOUNT_SHORT = 5;\r\nconst SEEK_AMOUNT_LONG = 10;\r\nconst SPEEDS = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];\r\n\r\nconst ROOT_NAME = \"MediaPlayer\";\r\nconst VIDEO_NAME = \"MediaPlayerVideo\";\r\nconst AUDIO_NAME = \"MediaPlayerAudio\";\r\nconst CONTROLS_NAME = \"MediaPlayerControls\";\r\nconst OVERLAY_NAME = \"MediaPlayerOverlay\";\r\nconst PLAY_NAME = \"MediaPlayerPlay\";\r\nconst SEEK_BACKWARD_NAME = \"MediaPlayerSeekBackward\";\r\nconst SEEK_FORWARD_NAME = \"MediaPlayerSeekForward\";\r\nconst SEEK_NAME = \"MediaPlayerSeek\";\r\nconst VOLUME_NAME = \"MediaPlayerVolume\";\r\nconst TIME_NAME = \"MediaPlayerTime\";\r\nconst PLAYBACK_SPEED_NAME = \"MediaPlayerPlaybackSpeed\";\r\nconst LOOP_NAME = \"MediaPlayerLoop\";\r\nconst FULLSCREEN_NAME = \"MediaPlayerFullscreen\";\r\nconst PIP_NAME = \"MediaPlayerPiP\";\r\nconst CAPTIONS_NAME = \"MediaPlayerCaptions\";\r\nconst DOWNLOAD_NAME = \"MediaPlayerDownload\";\r\n\r\nconst MEDIA_PLAYER_ERRORS = {\r\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` must be used as root component`,\r\n  [VIDEO_NAME]: `\\`${VIDEO_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [AUDIO_NAME]: `\\`${AUDIO_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [CONTROLS_NAME]: `\\`${CONTROLS_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [OVERLAY_NAME]: `\\`${OVERLAY_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [PLAY_NAME]: `\\`${PLAY_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [SEEK_BACKWARD_NAME]: `\\`${SEEK_BACKWARD_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [SEEK_FORWARD_NAME]: `\\`${SEEK_FORWARD_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [SEEK_NAME]: `\\`${SEEK_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [VOLUME_NAME]: `\\`${VOLUME_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [TIME_NAME]: `\\`${TIME_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [PLAYBACK_SPEED_NAME]: `\\`${PLAYBACK_SPEED_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [LOOP_NAME]: `\\`${LOOP_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [FULLSCREEN_NAME]: `\\`${FULLSCREEN_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [PIP_NAME]: `\\`${PIP_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [CAPTIONS_NAME]: `\\`${CAPTIONS_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n  [DOWNLOAD_NAME]: `\\`${DOWNLOAD_NAME}\\` must be within \\`${ROOT_NAME}\\``,\r\n} as const;\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\nfunction useAsRef<T>(data: T) {\r\n  const ref = React.useRef<T>(data);\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = data;\r\n  });\r\n  return ref;\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nfunction formatTime(time: number) {\r\n  const hours = Math.floor(time / 3600);\r\n  const minutes = Math.floor((time % 3600) / 60);\r\n  const seconds = Math.floor(time % 60);\r\n\r\n  if (hours > 0) {\r\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${seconds.toString().padStart(2, \"0\")}`;\r\n  }\r\n  return `${minutes}:${seconds.toString().padStart(2, \"0\")}`;\r\n}\r\n\r\nfunction getIsVideo(\r\n  mediaRef: React.RefObject<HTMLVideoElement | HTMLAudioElement | null>,\r\n) {\r\n  return (\r\n    typeof window !== \"undefined\" &&\r\n    mediaRef.current instanceof HTMLVideoElement\r\n  );\r\n}\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\r\n\r\nfunction useDirection(dirProp?: Direction): Direction {\r\n  const contextDir = React.useContext(DirectionContext);\r\n  return dirProp ?? contextDir ?? \"ltr\";\r\n}\r\n\r\ntype LoopMode = \"off\" | \"all\" | \"one\";\r\n\r\ninterface MediaState {\r\n  isPlaying: boolean;\r\n  isMuted: boolean;\r\n  volume: number;\r\n  currentTime: number;\r\n  duration: number;\r\n  buffered: TimeRanges | null;\r\n  isFullscreen: boolean;\r\n  isLooping: boolean;\r\n  loopMode: LoopMode;\r\n  playbackRate: number;\r\n  isPictureInPicture: boolean;\r\n  captionsEnabled: boolean;\r\n}\r\n\r\ninterface StoreState {\r\n  media: MediaState;\r\n}\r\n\r\ntype StoreAction =\r\n  | { variant: \"SET_PLAYING\"; isPlaying: boolean }\r\n  | { variant: \"SET_MUTED\"; isMuted: boolean }\r\n  | { variant: \"SET_VOLUME\"; volume: number }\r\n  | { variant: \"SET_CURRENT_TIME\"; currentTime: number }\r\n  | { variant: \"SET_DURATION\"; duration: number }\r\n  | { variant: \"SET_BUFFERED\"; buffered: TimeRanges }\r\n  | { variant: \"SET_FULLSCREEN\"; isFullscreen: boolean }\r\n  | { variant: \"SET_LOOP_MODE\"; loopMode: LoopMode }\r\n  | { variant: \"SET_PLAYBACK_RATE\"; playbackRate: number }\r\n  | { variant: \"SET_PICTURE_IN_PICTURE\"; isPictureInPicture: boolean }\r\n  | { variant: \"SET_CAPTIONS_ENABLED\"; captionsEnabled: boolean };\r\n\r\nfunction createStore(listeners: Set<() => void>, initialState: MediaState) {\r\n  let state: StoreState = {\r\n    media: initialState,\r\n  };\r\n\r\n  function getState() {\r\n    return state;\r\n  }\r\n\r\n  function dispatch(action: StoreAction) {\r\n    switch (action.variant) {\r\n      case \"SET_PLAYING\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, isPlaying: action.isPlaying },\r\n        };\r\n        break;\r\n\r\n      case \"SET_MUTED\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, isMuted: action.isMuted },\r\n        };\r\n        break;\r\n\r\n      case \"SET_VOLUME\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, volume: action.volume },\r\n        };\r\n        break;\r\n\r\n      case \"SET_CURRENT_TIME\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, currentTime: action.currentTime },\r\n        };\r\n        break;\r\n\r\n      case \"SET_DURATION\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, duration: action.duration },\r\n        };\r\n        break;\r\n\r\n      case \"SET_BUFFERED\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, buffered: action.buffered },\r\n        };\r\n        break;\r\n\r\n      case \"SET_FULLSCREEN\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, isFullscreen: action.isFullscreen },\r\n        };\r\n        break;\r\n\r\n      case \"SET_LOOP_MODE\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, loopMode: action.loopMode },\r\n        };\r\n        break;\r\n\r\n      case \"SET_PLAYBACK_RATE\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, playbackRate: action.playbackRate },\r\n        };\r\n        break;\r\n\r\n      case \"SET_PICTURE_IN_PICTURE\":\r\n        state = {\r\n          ...state,\r\n          media: {\r\n            ...state.media,\r\n            isPictureInPicture: action.isPictureInPicture,\r\n          },\r\n        };\r\n        break;\r\n\r\n      case \"SET_CAPTIONS_ENABLED\":\r\n        state = {\r\n          ...state,\r\n          media: { ...state.media, captionsEnabled: action.captionsEnabled },\r\n        };\r\n        break;\r\n    }\r\n\r\n    for (const listener of listeners) {\r\n      listener();\r\n    }\r\n  }\r\n\r\n  function subscribe(listener: () => void) {\r\n    listeners.add(listener);\r\n    return () => listeners.delete(listener);\r\n  }\r\n\r\n  return { getState, dispatch, subscribe };\r\n}\r\n\r\nconst StoreContext = React.createContext<ReturnType<typeof createStore> | null>(\r\n  null,\r\n);\r\nStoreContext.displayName = ROOT_NAME;\r\n\r\nfunction useStoreContext(name: keyof typeof MEDIA_PLAYER_ERRORS) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(MEDIA_PLAYER_ERRORS[name]);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(ROOT_NAME);\r\n\r\n  const lastValueRef = useLazyRef<{ value: T; state: StoreState } | null>(\r\n    () => null,\r\n  );\r\n\r\n  const getSnapshot = React.useCallback(() => {\r\n    const state = store.getState();\r\n    const prevValue = lastValueRef.current;\r\n\r\n    if (prevValue && prevValue.state === state) {\r\n      return prevValue.value;\r\n    }\r\n\r\n    const nextValue = selector(state);\r\n    lastValueRef.current = { value: nextValue, state };\r\n    return nextValue;\r\n  }, [store, selector, lastValueRef]);\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface MediaPlayerContextValue {\r\n  mediaId: string;\r\n  labelId: string;\r\n  descriptionId: string;\r\n  dir: Direction;\r\n  disabled: boolean;\r\n  mediaRef: React.RefObject<HTMLVideoElement | HTMLAudioElement | null>;\r\n}\r\n\r\nconst MediaPlayerContext = React.createContext<MediaPlayerContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useMediaPlayerContext(name: keyof typeof MEDIA_PLAYER_ERRORS) {\r\n  const context = React.useContext(MediaPlayerContext);\r\n  if (!context) {\r\n    throw new Error(MEDIA_PLAYER_ERRORS[name]);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface MediaPlayerRootProps\r\n  extends Omit<\r\n    React.ComponentPropsWithoutRef<\"div\">,\r\n    \"onTimeUpdate\" | \"onVolumeChange\"\r\n  > {\r\n  defaultVolume?: number;\r\n  onPlay?: () => void;\r\n  onPause?: () => void;\r\n  onEnded?: () => void;\r\n  onTimeUpdate?: (time: number) => void;\r\n  onVolumeChange?: (volume: number) => void;\r\n  onMuted?: (muted: boolean) => void;\r\n  onPipError?: (error: unknown, mode: \"enter\" | \"exit\") => void;\r\n  onFullscreenChange?: (fullscreen: boolean) => void;\r\n  dir?: Direction;\r\n  label?: string;\r\n  asChild?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst MediaPlayerRoot = React.forwardRef<HTMLDivElement, MediaPlayerRootProps>(\r\n  (props, forwardedRef) => {\r\n    const {\r\n      defaultVolume = 1,\r\n      onPlay,\r\n      onPause,\r\n      onEnded,\r\n      onTimeUpdate,\r\n      onVolumeChange,\r\n      onMuted,\r\n      onPipError,\r\n      onFullscreenChange,\r\n      asChild,\r\n      disabled = false,\r\n      dir: dirProp,\r\n      label,\r\n      children,\r\n      className,\r\n      ...rootProps\r\n    } = props;\r\n\r\n    const mediaId = React.useId();\r\n    const labelId = React.useId();\r\n    const descriptionId = React.useId();\r\n\r\n    const dir = useDirection(dirProp);\r\n    const propsRef = useAsRef(props);\r\n    const listeners = useLazyRef(() => new Set<() => void>()).current;\r\n\r\n    const mediaRef = React.useRef<HTMLVideoElement | HTMLAudioElement>(null);\r\n    const previousVolumeRef = React.useRef(defaultVolume);\r\n\r\n    const initialState = React.useMemo<MediaState>(() => {\r\n      return {\r\n        isPlaying: mediaRef.current?.autoplay ?? false,\r\n        isMuted: mediaRef.current?.muted ?? false,\r\n        volume: mediaRef.current?.volume ?? defaultVolume,\r\n        currentTime: 0,\r\n        duration: 0,\r\n        buffered: null,\r\n        isFullscreen: false,\r\n        isLooping: mediaRef.current?.loop ?? false,\r\n        loopMode: mediaRef.current?.loop ? \"all\" : \"off\",\r\n        playbackRate: 1,\r\n        isPictureInPicture: false,\r\n        captionsEnabled: false,\r\n      };\r\n    }, [defaultVolume]);\r\n\r\n    const store = React.useMemo(\r\n      () => createStore(listeners, initialState),\r\n      [listeners, initialState],\r\n    );\r\n\r\n    const contextValue = React.useMemo<MediaPlayerContextValue>(\r\n      () => ({\r\n        mediaId,\r\n        labelId,\r\n        descriptionId,\r\n        mediaRef,\r\n        dir,\r\n        disabled,\r\n      }),\r\n      [mediaId, labelId, descriptionId, dir, disabled],\r\n    );\r\n\r\n    const onKeyDown = React.useCallback(\r\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n        if (disabled) return;\r\n\r\n        propsRef.current.onKeyDown?.(event);\r\n\r\n        if (event.defaultPrevented) return;\r\n\r\n        const media = mediaRef.current;\r\n        if (!media) return;\r\n\r\n        const isMediaFocused = document.activeElement === media;\r\n        const isPlayerFocused =\r\n          document.activeElement?.closest('[data-slot=\"media-player\"]') !==\r\n          null;\r\n\r\n        if (!isMediaFocused && !isPlayerFocused) return;\r\n\r\n        switch (event.key.toLowerCase()) {\r\n          case \" \":\r\n          case \"k\":\r\n            event.preventDefault();\r\n            if (media.paused) {\r\n              media.play();\r\n            } else {\r\n              media.pause();\r\n            }\r\n            break;\r\n\r\n          case \"f\":\r\n            event.preventDefault();\r\n            if (!document.fullscreenElement) {\r\n              const container = media.closest('[data-slot=\"media-player\"]');\r\n              if (container) {\r\n                container.requestFullscreen();\r\n              } else {\r\n                media.requestFullscreen();\r\n              }\r\n            } else {\r\n              document.exitFullscreen();\r\n            }\r\n            break;\r\n\r\n          case \"m\": {\r\n            event.preventDefault();\r\n            const currentVolume = store.getState().media.volume;\r\n            const currentMuted = store.getState().media.isMuted;\r\n            if (!currentMuted) {\r\n              previousVolumeRef.current =\r\n                currentVolume > 0 ? currentVolume : previousVolumeRef.current;\r\n              store.dispatch({ variant: \"SET_VOLUME\", volume: 0 });\r\n              store.dispatch({ variant: \"SET_MUTED\", isMuted: true });\r\n              if (media) {\r\n                media.volume = 0;\r\n                media.muted = true;\r\n              }\r\n            } else {\r\n              const restoredVolume = previousVolumeRef.current || 1;\r\n              store.dispatch({\r\n                variant: \"SET_VOLUME\",\r\n                volume: restoredVolume,\r\n              });\r\n              store.dispatch({ variant: \"SET_MUTED\", isMuted: false });\r\n              if (media) {\r\n                media.volume = restoredVolume;\r\n                media.muted = false;\r\n              }\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"arrowright\":\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              media.currentTime = Math.min(\r\n                media.duration,\r\n                media.currentTime + SEEK_AMOUNT_SHORT,\r\n              );\r\n            } else if (media instanceof HTMLAudioElement && event.shiftKey) {\r\n              media.currentTime = Math.min(\r\n                media.duration,\r\n                media.currentTime + SEEK_AMOUNT_SHORT,\r\n              );\r\n            }\r\n            break;\r\n\r\n          case \"arrowleft\":\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              media.currentTime = Math.max(\r\n                0,\r\n                media.currentTime - SEEK_AMOUNT_SHORT,\r\n              );\r\n            } else if (media instanceof HTMLAudioElement && event.shiftKey) {\r\n              media.currentTime = Math.max(\r\n                0,\r\n                media.currentTime - SEEK_AMOUNT_SHORT,\r\n              );\r\n            }\r\n            break;\r\n\r\n          case \"arrowup\":\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              media.volume = Math.min(1, media.volume + 0.1);\r\n            }\r\n            break;\r\n\r\n          case \"arrowdown\":\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              media.volume = Math.max(0, media.volume - 0.1);\r\n            }\r\n            break;\r\n\r\n          case \"<\": {\r\n            event.preventDefault();\r\n            const decreaseRate = store.getState().media.playbackRate;\r\n            const decreaseIndex = SPEEDS.indexOf(decreaseRate);\r\n            const newDecreaseIndex = Math.max(0, decreaseIndex - 1);\r\n            const newDecreaseRate = SPEEDS[newDecreaseIndex] ?? 1;\r\n\r\n            media.playbackRate = newDecreaseRate;\r\n            store.dispatch({\r\n              variant: \"SET_PLAYBACK_RATE\",\r\n              playbackRate: newDecreaseRate,\r\n            });\r\n            break;\r\n          }\r\n\r\n          case \">\": {\r\n            event.preventDefault();\r\n            const increaseRate = store.getState().media.playbackRate;\r\n            const increaseIndex = SPEEDS.indexOf(increaseRate);\r\n            const newIncreaseIndex = Math.min(\r\n              SPEEDS.length - 1,\r\n              increaseIndex + 1,\r\n            );\r\n            const newIncreaseRate = SPEEDS[newIncreaseIndex] ?? 1;\r\n\r\n            media.playbackRate = newIncreaseRate;\r\n            store.dispatch({\r\n              variant: \"SET_PLAYBACK_RATE\",\r\n              playbackRate: newIncreaseRate,\r\n            });\r\n            break;\r\n          }\r\n\r\n          case \"c\":\r\n            event.preventDefault();\r\n            if (\r\n              media instanceof HTMLVideoElement &&\r\n              media.textTracks.length > 0\r\n            ) {\r\n              const captionsEnabled = store.getState().media.captionsEnabled;\r\n              for (let i = 0; i < media.textTracks.length; i++) {\r\n                const track = media.textTracks[i];\r\n                if (\r\n                  track &&\r\n                  (track.kind === \"captions\" || track.kind === \"subtitles\")\r\n                ) {\r\n                  track.mode = captionsEnabled ? \"hidden\" : \"showing\";\r\n                }\r\n              }\r\n              store.dispatch({\r\n                variant: \"SET_CAPTIONS_ENABLED\",\r\n                captionsEnabled: !captionsEnabled,\r\n              });\r\n            }\r\n            break;\r\n\r\n          case \"d\": {\r\n            event.preventDefault();\r\n            if (media.currentSrc) {\r\n              const link = document.createElement(\"a\");\r\n              link.href = media.currentSrc;\r\n              link.download = \"\";\r\n              document.body.appendChild(link);\r\n              link.click();\r\n              document.body.removeChild(link);\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"p\": {\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              if (document.pictureInPictureElement === media) {\r\n                document.exitPictureInPicture().catch((error) => {\r\n                  propsRef.current.onPipError?.(error, \"exit\");\r\n                });\r\n              } else {\r\n                media.requestPictureInPicture().catch((error) => {\r\n                  propsRef.current.onPipError?.(error, \"enter\");\r\n                });\r\n              }\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"r\": {\r\n            event.preventDefault();\r\n            const currentLoopMode = store.getState().media.loopMode;\r\n            if (currentLoopMode === \"one\") {\r\n              if (media) {\r\n                media.currentTime = 0;\r\n                media.play();\r\n                store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: \"off\" });\r\n              }\r\n            } else {\r\n              store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: \"one\" });\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"j\": {\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              media.currentTime = Math.max(\r\n                0,\r\n                media.currentTime - SEEK_AMOUNT_LONG,\r\n              );\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"l\": {\r\n            event.preventDefault();\r\n            if (media instanceof HTMLVideoElement) {\r\n              media.currentTime = Math.min(\r\n                media.duration,\r\n                media.currentTime + SEEK_AMOUNT_LONG,\r\n              );\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      },\r\n      [\r\n        store,\r\n        propsRef.current.onKeyDown,\r\n        propsRef.current.onPipError,\r\n        disabled,\r\n      ],\r\n    );\r\n\r\n    const initialVolumeSetRef = React.useRef(false);\r\n\r\n    React.useEffect(() => {\r\n      const media = mediaRef.current;\r\n      if (!media) return;\r\n\r\n      if (!initialVolumeSetRef.current) {\r\n        const initialVolumeProp = propsRef.current.defaultVolume;\r\n        if (\r\n          typeof initialVolumeProp === \"number\" &&\r\n          media.volume !== initialVolumeProp\r\n        ) {\r\n          media.volume = initialVolumeProp;\r\n        }\r\n        initialVolumeSetRef.current = true;\r\n      }\r\n\r\n      if (media.muted !== store.getState().media.isMuted) {\r\n        const actualVolume = media.muted ? 0 : media.volume;\r\n        if (media.muted && store.getState().media.volume !== 0) {\r\n          previousVolumeRef.current = store.getState().media.volume;\r\n        }\r\n        store.dispatch({ variant: \"SET_MUTED\", isMuted: media.muted });\r\n        store.dispatch({ variant: \"SET_VOLUME\", volume: actualVolume });\r\n      }\r\n      if (media.volume !== store.getState().media.volume && !media.muted) {\r\n        store.dispatch({ variant: \"SET_VOLUME\", volume: media.volume });\r\n      }\r\n\r\n      const onTimeUpdate = () => {\r\n        store.dispatch({\r\n          variant: \"SET_CURRENT_TIME\",\r\n          currentTime: media.currentTime,\r\n        });\r\n        propsRef.current.onTimeUpdate?.(media.currentTime);\r\n      };\r\n\r\n      const onDurationChange = () => {\r\n        store.dispatch({\r\n          variant: \"SET_DURATION\",\r\n          duration: media.duration,\r\n        });\r\n        store.dispatch({\r\n          variant: \"SET_BUFFERED\",\r\n          buffered: media.buffered,\r\n        });\r\n      };\r\n\r\n      const onProgress = () => {\r\n        store.dispatch({\r\n          variant: \"SET_BUFFERED\",\r\n          buffered: media.buffered,\r\n        });\r\n      };\r\n\r\n      const onSeeked = () => {\r\n        store.dispatch({\r\n          variant: \"SET_BUFFERED\",\r\n          buffered: media.buffered,\r\n        });\r\n      };\r\n\r\n      const onPlay = () => {\r\n        store.dispatch({ variant: \"SET_PLAYING\", isPlaying: true });\r\n        propsRef.current.onPlay?.();\r\n      };\r\n\r\n      const onPause = () => {\r\n        store.dispatch({ variant: \"SET_PLAYING\", isPlaying: false });\r\n        propsRef.current.onPause?.();\r\n      };\r\n\r\n      const onEnded = () => {\r\n        store.dispatch({ variant: \"SET_PLAYING\", isPlaying: false });\r\n        propsRef.current.onEnded?.();\r\n        const currentLoopMode = store.getState().media.loopMode;\r\n        if (currentLoopMode === \"one\") {\r\n          if (media) {\r\n            media.currentTime = 0;\r\n            media.play();\r\n            store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: \"off\" });\r\n          }\r\n        } else {\r\n          store.dispatch({ variant: \"SET_PLAYING\", isPlaying: false });\r\n          propsRef.current.onEnded?.();\r\n        }\r\n      };\r\n\r\n      const onVolumeChange = () => {\r\n        const currentVolume = media.muted ? 0 : media.volume;\r\n        if (\r\n          media.muted &&\r\n          !store.getState().media.isMuted &&\r\n          media.volume > 0\r\n        ) {\r\n          previousVolumeRef.current = media.volume;\r\n        }\r\n        store.dispatch({ variant: \"SET_VOLUME\", volume: currentVolume });\r\n        store.dispatch({ variant: \"SET_MUTED\", isMuted: media.muted });\r\n        propsRef.current.onVolumeChange?.(media.volume);\r\n        propsRef.current.onMuted?.(media.muted);\r\n      };\r\n\r\n      const onFullscreenChange = () => {\r\n        const isFullscreen = !!document.fullscreenElement;\r\n        store.dispatch({\r\n          variant: \"SET_FULLSCREEN\",\r\n          isFullscreen: isFullscreen,\r\n        });\r\n        propsRef.current.onFullscreenChange?.(isFullscreen);\r\n      };\r\n\r\n      const onEnteredPiP = () => {\r\n        store.dispatch({\r\n          variant: \"SET_PICTURE_IN_PICTURE\",\r\n          isPictureInPicture: true,\r\n        });\r\n      };\r\n\r\n      const onExitedPiP = () => {\r\n        store.dispatch({\r\n          variant: \"SET_PICTURE_IN_PICTURE\",\r\n          isPictureInPicture: false,\r\n        });\r\n      };\r\n\r\n      const onRateChange = () => {\r\n        store.dispatch({\r\n          variant: \"SET_PLAYBACK_RATE\",\r\n          playbackRate: media.playbackRate,\r\n        });\r\n      };\r\n\r\n      media.addEventListener(\"timeupdate\", onTimeUpdate);\r\n      media.addEventListener(\"durationchange\", onDurationChange);\r\n      media.addEventListener(\"progress\", onProgress);\r\n      media.addEventListener(\"play\", onPlay);\r\n      media.addEventListener(\"pause\", onPause);\r\n      media.addEventListener(\"ended\", onEnded);\r\n      media.addEventListener(\"volumechange\", onVolumeChange);\r\n      media.addEventListener(\"ratechange\", onRateChange);\r\n      media.addEventListener(\"seeked\", onSeeked);\r\n      document.addEventListener(\"fullscreenchange\", onFullscreenChange);\r\n\r\n      if (media instanceof HTMLVideoElement) {\r\n        media.addEventListener(\"enterpictureinpicture\", onEnteredPiP);\r\n        media.addEventListener(\"leavepictureinpicture\", onExitedPiP);\r\n      }\r\n\r\n      if (media.volume !== store.getState().media.volume) {\r\n        store.dispatch({ variant: \"SET_VOLUME\", volume: media.volume });\r\n      }\r\n\r\n      if (media.muted !== store.getState().media.isMuted) {\r\n        store.dispatch({ variant: \"SET_MUTED\", isMuted: media.muted });\r\n      }\r\n\r\n      return () => {\r\n        media.removeEventListener(\"timeupdate\", onTimeUpdate);\r\n        media.removeEventListener(\"durationchange\", onDurationChange);\r\n        media.removeEventListener(\"progress\", onProgress);\r\n        media.removeEventListener(\"play\", onPlay);\r\n        media.removeEventListener(\"pause\", onPause);\r\n        media.removeEventListener(\"ended\", onEnded);\r\n        media.removeEventListener(\"volumechange\", onVolumeChange);\r\n        media.removeEventListener(\"ratechange\", onRateChange);\r\n        media.removeEventListener(\"seeked\", onSeeked);\r\n        document.removeEventListener(\"fullscreenchange\", onFullscreenChange);\r\n\r\n        if (media instanceof HTMLVideoElement) {\r\n          media.removeEventListener(\"enterpictureinpicture\", onEnteredPiP);\r\n          media.removeEventListener(\"leavepictureinpicture\", onExitedPiP);\r\n        }\r\n      };\r\n    }, [\r\n      store,\r\n      propsRef.current.defaultVolume,\r\n      propsRef.current.onVolumeChange,\r\n      propsRef.current.onTimeUpdate,\r\n      propsRef.current.onMuted,\r\n      propsRef.current.onPlay,\r\n      propsRef.current.onPause,\r\n      propsRef.current.onEnded,\r\n      propsRef.current.onFullscreenChange,\r\n    ]);\r\n\r\n    const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n    return (\r\n      <StoreContext.Provider value={store}>\r\n        <MediaPlayerContext.Provider value={contextValue}>\r\n          <RootPrimitive\r\n            aria-labelledby={labelId}\r\n            aria-describedby={descriptionId}\r\n            aria-disabled={disabled}\r\n            data-disabled={disabled ? \"\" : undefined}\r\n            data-slot=\"media-player\"\r\n            dir={dir}\r\n            tabIndex={disabled ? undefined : 0}\r\n            onKeyDown={onKeyDown}\r\n            {...rootProps}\r\n            ref={forwardedRef}\r\n            className={cn(\r\n              \"relative isolate flex flex-col overflow-hidden rounded-lg bg-background outline-none focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\r\n              \"[:fullscreen_&]:flex [:fullscreen_&]:h-full [:fullscreen_&]:max-h-screen [:fullscreen_&]:flex-col [:fullscreen_&]:justify-between\",\r\n              \"[&_[data-slider]::before]:-top-6 [&_[data-slider]::before]:-bottom-2 [&_[data-slider]::before]:absolute [&_[data-slider]::before]:inset-x-0 [&_[data-slider]::before]:z-10 [&_[data-slider]::before]:h-12 [&_[data-slider]::before]:cursor-pointer [&_[data-slider]::before]:content-[''] [&_[data-slider]]:relative\",\r\n              className,\r\n            )}\r\n          >\r\n            <span id={labelId} className=\"sr-only\">\r\n              {label ?? \"Media player\"}\r\n            </span>\r\n            {children}\r\n          </RootPrimitive>\r\n        </MediaPlayerContext.Provider>\r\n      </StoreContext.Provider>\r\n    );\r\n  },\r\n);\r\nMediaPlayerRoot.displayName = ROOT_NAME;\r\n\r\ninterface MediaPlayerVideoProps\r\n  extends React.ComponentPropsWithoutRef<\"video\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst MediaPlayerVideo = React.forwardRef<\r\n  HTMLVideoElement,\r\n  MediaPlayerVideoProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, ...videoProps } = props;\r\n\r\n  const context = useMediaPlayerContext(VIDEO_NAME);\r\n  const loopMode = useStore((state) => state.media.loopMode);\r\n  const composedRef = useComposedRefs(forwardedRef, context.mediaRef);\r\n\r\n  const onPlayToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLVideoElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      if (media.paused) {\r\n        media.play();\r\n      } else {\r\n        media.pause();\r\n      }\r\n    },\r\n    [context.mediaRef, props.onClick],\r\n  );\r\n\r\n  const VideoPrimitive = asChild ? Slot : \"video\";\r\n\r\n  return (\r\n    <VideoPrimitive\r\n      aria-labelledby={context.labelId}\r\n      aria-describedby={context.descriptionId}\r\n      data-slot=\"media-player-video\"\r\n      controlsList=\"nodownload noremoteplayback\"\r\n      {...videoProps}\r\n      ref={composedRef}\r\n      id={context.mediaId}\r\n      loop={loopMode === \"all\"}\r\n      playsInline\r\n      preload=\"metadata\"\r\n      className={cn(\"h-full w-full cursor-pointer\", className)}\r\n      onClick={onPlayToggle}\r\n    >\r\n      {children}\r\n      <span id={context.descriptionId} className=\"sr-only\">\r\n        Video player with custom controls for playback, volume, seeking, and\r\n        more. Use space bar to play/pause, arrow keys (←/→) to seek, and arrow\r\n        keys (↑/↓) to adjust volume.\r\n      </span>\r\n    </VideoPrimitive>\r\n  );\r\n});\r\nMediaPlayerVideo.displayName = VIDEO_NAME;\r\n\r\ninterface MediaPlayerAudioProps\r\n  extends React.ComponentPropsWithoutRef<\"audio\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst MediaPlayerAudio = React.forwardRef<\r\n  HTMLAudioElement,\r\n  MediaPlayerAudioProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, ...audioProps } = props;\r\n\r\n  const context = useMediaPlayerContext(AUDIO_NAME);\r\n  const loopMode = useStore((state) => state.media.loopMode);\r\n  const composedRef = useComposedRefs(forwardedRef, context.mediaRef);\r\n\r\n  const AudioPrimitive = asChild ? Slot : \"audio\";\r\n\r\n  return (\r\n    <AudioPrimitive\r\n      aria-labelledby={context.labelId}\r\n      aria-describedby={context.descriptionId}\r\n      data-slot=\"media-player-audio\"\r\n      {...audioProps}\r\n      ref={composedRef}\r\n      id={context.mediaId}\r\n      loop={loopMode === \"all\"}\r\n      preload=\"metadata\"\r\n      className={cn(\"w-full\", className)}\r\n    >\r\n      {children}\r\n      <span id={context.descriptionId} className=\"sr-only\">\r\n        Audio player with custom controls for playback, volume, seeking, and\r\n        more. Use space bar to play/pause, Shift + arrow keys (←/→) to seek, and\r\n        arrow keys (↑/↓) to adjust volume.\r\n      </span>\r\n    </AudioPrimitive>\r\n  );\r\n});\r\nMediaPlayerAudio.displayName = AUDIO_NAME;\r\n\r\ninterface MediaPlayerControlsProps\r\n  extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst MediaPlayerControls = React.forwardRef<\r\n  HTMLDivElement,\r\n  MediaPlayerControlsProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, className, ...controlsProps } = props;\r\n\r\n  const context = useMediaPlayerContext(CONTROLS_NAME);\r\n  const isFullscreen = useStore((state) => state.media.isFullscreen);\r\n\r\n  const ControlsPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ControlsPrimitive\r\n      role=\"group\"\r\n      aria-label=\"Media controls\"\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-slot=\"media-player-controls\"\r\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n      dir={context.dir}\r\n      ref={forwardedRef}\r\n      className={cn(\r\n        \"dark absolute right-0 bottom-0 left-0 z-50 flex items-center gap-2 px-4 py-3\",\r\n        \"[:fullscreen_&]:absolute [:fullscreen_&]:right-0 [:fullscreen_&]:bottom-0 [:fullscreen_&]:left-0 [:fullscreen_&]:z-50 [:fullscreen_&]:px-6 [:fullscreen_&]:py-4\",\r\n        className,\r\n      )}\r\n      {...controlsProps}\r\n    />\r\n  );\r\n});\r\nMediaPlayerControls.displayName = CONTROLS_NAME;\r\n\r\ninterface MediaPlayerOverlayProps\r\n  extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst MediaPlayerOverlay = React.forwardRef<\r\n  HTMLDivElement,\r\n  MediaPlayerOverlayProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, className, ...overlayProps } = props;\r\n\r\n  const isFullscreen = useStore((state) => state.media.isFullscreen);\r\n\r\n  const OverlayPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <OverlayPrimitive\r\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n      data-slot=\"media-player-overlay\"\r\n      {...overlayProps}\r\n      ref={forwardedRef}\r\n      className={cn(\r\n        \"-z-10 absolute inset-0 bg-gradient-to-t from-black/80 to-transparent\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n});\r\nMediaPlayerOverlay.displayName = OVERLAY_NAME;\r\n\r\ninterface MediaPlayerPlayProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\r\n\r\nconst MediaPlayerPlay = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerPlayProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, disabled, ...playButtonProps } = props;\r\n\r\n  const context = useMediaPlayerContext(PLAY_NAME);\r\n  const isPlaying = useStore((state) => state.media.isPlaying);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onPlayToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      if (isPlaying) {\r\n        media.pause();\r\n      } else {\r\n        media.play();\r\n      }\r\n    },\r\n    [context.mediaRef, props.onClick, isPlaying],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip={isPlaying ? \"Pause\" : \"Play\"} shortcut=\"Space\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={isPlaying ? \"Pause\" : \"Play\"}\r\n        aria-pressed={isPlaying}\r\n        aria-controls={context.mediaId}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-state={isPlaying ? \"playing\" : \"paused\"}\r\n        data-slot=\"media-player-play-button\"\r\n        disabled={isDisabled}\r\n        {...playButtonProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\r\n          \"size-8 [&_svg:not([class*='fill-'])]:fill-current\",\r\n          className,\r\n        )}\r\n        onClick={onPlayToggle}\r\n      >\r\n        {children ?? (isPlaying ? <PauseIcon /> : <PlayIcon />)}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerPlay.displayName = PLAY_NAME;\r\n\r\ninterface MediaPlayerSeekBackwardProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {\r\n  seconds?: number;\r\n}\r\n\r\nconst MediaPlayerSeekBackward = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerSeekBackwardProps\r\n>((props, forwardedRef) => {\r\n  const {\r\n    asChild,\r\n    children,\r\n    className,\r\n    seconds = SEEK_AMOUNT_SHORT,\r\n    ...seekBackwardProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(SEEK_BACKWARD_NAME);\r\n  const isDisabled = props.disabled || context.disabled;\r\n\r\n  const isVideo = getIsVideo(context.mediaRef);\r\n\r\n  const onSeekBackward = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      media.currentTime = Math.max(0, media.currentTime - seconds);\r\n    },\r\n    [context.mediaRef, props.onClick, seconds],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip\r\n      tooltip={`Back ${seconds}s`}\r\n      shortcut={isVideo ? [\"←\"] : [\"Shift ←\"]}\r\n    >\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={`Back ${seconds} seconds`}\r\n        aria-controls={context.mediaId}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-seek-backward\"\r\n        disabled={isDisabled}\r\n        {...seekBackwardProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onSeekBackward}\r\n      >\r\n        {children ?? <RewindIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerSeekBackward.displayName = SEEK_BACKWARD_NAME;\r\n\r\ninterface MediaPlayerSeekForwardProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {\r\n  seconds?: number;\r\n}\r\n\r\nconst MediaPlayerSeekForward = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerSeekForwardProps\r\n>((props, forwardedRef) => {\r\n  const {\r\n    asChild,\r\n    children,\r\n    className,\r\n    seconds = SEEK_AMOUNT_LONG,\r\n    ...seekForwardProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(SEEK_FORWARD_NAME);\r\n  const isDisabled = props.disabled || context.disabled;\r\n\r\n  const isVideo = getIsVideo(context.mediaRef);\r\n\r\n  const onSeekForward = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      media.currentTime = Math.min(media.duration, media.currentTime + seconds);\r\n    },\r\n    [context.mediaRef, props.onClick, seconds],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip\r\n      tooltip={`Forward ${seconds}s`}\r\n      shortcut={isVideo ? [\"→\"] : [\"Shift →\"]}\r\n    >\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={`Forward ${seconds} seconds`}\r\n        aria-controls={context.mediaId}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-seek-forward\"\r\n        disabled={isDisabled}\r\n        {...seekForwardProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onSeekForward}\r\n      >\r\n        {children ?? <FastForwardIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerSeekForward.displayName = SEEK_FORWARD_NAME;\r\n\r\ninterface MediaPlayerSeekProps\r\n  extends React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root> {\r\n  withTime?: boolean;\r\n}\r\n\r\nconst MediaPlayerSeek = React.forwardRef<HTMLDivElement, MediaPlayerSeekProps>(\r\n  (props, forwardedRef) => {\r\n    const {\r\n      asChild,\r\n      withTime = false,\r\n      className,\r\n      disabled,\r\n      ...seekProps\r\n    } = props;\r\n\r\n    const context = useMediaPlayerContext(SEEK_NAME);\r\n    const store = useStoreContext(SEEK_NAME);\r\n    const currentTime = useStore((state) => state.media.currentTime);\r\n    const duration = useStore((state) => state.media.duration);\r\n    const buffered = useStore((state) => state.media.buffered);\r\n\r\n    const seekRef = React.useRef<HTMLDivElement>(null);\r\n    const tooltipRef = React.useRef<HTMLDivElement>(null);\r\n    const composedRef = useComposedRefs(forwardedRef, seekRef);\r\n\r\n    const [tooltipPositionX, setTooltipPositionX] = React.useState(0);\r\n    const [isHoveringSeek, setIsHoveringSeek] = React.useState(false);\r\n    const [hoverTime, setHoverTime] = React.useState(0);\r\n\r\n    const formattedCurrentTime = formatTime(currentTime);\r\n    const formattedDuration = formatTime(duration);\r\n    const formattedHoverTime = formatTime(hoverTime);\r\n    const formattedRemainingTime = formatTime(duration - currentTime);\r\n\r\n    const isDisabled = disabled || context.disabled;\r\n\r\n    const pointerMoveThrottleTimeoutRef = React.useRef<NodeJS.Timeout | null>(\r\n      null,\r\n    );\r\n    const seekThrottleTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);\r\n    const latestSeekValueRef = React.useRef<number | null>(null);\r\n\r\n    const onPointerEnter = React.useCallback(() => {\r\n      if (duration > 0) {\r\n        setIsHoveringSeek(true);\r\n      }\r\n    }, [duration]);\r\n\r\n    const onPointerLeave = React.useCallback(() => {\r\n      if (pointerMoveThrottleTimeoutRef.current) {\r\n        clearTimeout(pointerMoveThrottleTimeoutRef.current);\r\n        pointerMoveThrottleTimeoutRef.current = null;\r\n      }\r\n      setIsHoveringSeek(false);\r\n    }, []);\r\n\r\n    const onPointerMove = React.useCallback(\r\n      (event: React.PointerEvent<HTMLDivElement>) => {\r\n        if (\r\n          !seekRef.current ||\r\n          duration <= 0 ||\r\n          pointerMoveThrottleTimeoutRef.current\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        const rect = seekRef.current.getBoundingClientRect();\r\n        const offsetX = event.clientX - rect.left;\r\n        const clampedOffsetX = Math.max(0, Math.min(offsetX, rect.width));\r\n        const relativeX = clampedOffsetX / rect.width;\r\n        const calculatedHoverTime = relativeX * duration;\r\n\r\n        const tooltipWidth =\r\n          tooltipRef.current?.getBoundingClientRect().width ?? 0;\r\n        const centeredPosition = clampedOffsetX - tooltipWidth / 2;\r\n\r\n        setTooltipPositionX(centeredPosition);\r\n        setHoverTime(calculatedHoverTime);\r\n\r\n        pointerMoveThrottleTimeoutRef.current = setTimeout(() => {\r\n          pointerMoveThrottleTimeoutRef.current = null;\r\n        }, POINTER_MOVE_THROTTLE_MS);\r\n      },\r\n      [duration],\r\n    );\r\n\r\n    const onSeek = React.useCallback(\r\n      (value: number[]) => {\r\n        const media = context.mediaRef.current;\r\n        if (!media) return;\r\n\r\n        const time = value[0] ?? 0;\r\n        media.currentTime = time;\r\n        latestSeekValueRef.current = time;\r\n\r\n        if (!seekThrottleTimeoutRef.current) {\r\n          store.dispatch({ variant: \"SET_CURRENT_TIME\", currentTime: time });\r\n\r\n          seekThrottleTimeoutRef.current = setTimeout(() => {\r\n            seekThrottleTimeoutRef.current = null;\r\n            if (\r\n              latestSeekValueRef.current !== null &&\r\n              latestSeekValueRef.current !== time\r\n            ) {\r\n              store.dispatch({\r\n                variant: \"SET_CURRENT_TIME\",\r\n                currentTime: latestSeekValueRef.current,\r\n              });\r\n            }\r\n          }, SEEK_THROTTLE_MS);\r\n        }\r\n      },\r\n      [context.mediaRef, store],\r\n    );\r\n\r\n    const onSeekCommit = React.useCallback(\r\n      (value: number[]) => {\r\n        const media = context.mediaRef.current;\r\n        if (!media) return;\r\n\r\n        const time = value[0] ?? 0;\r\n        if (seekThrottleTimeoutRef.current) {\r\n          clearTimeout(seekThrottleTimeoutRef.current);\r\n          seekThrottleTimeoutRef.current = null;\r\n        }\r\n        store.dispatch({ variant: \"SET_CURRENT_TIME\", currentTime: time });\r\n        latestSeekValueRef.current = null;\r\n      },\r\n      [context.mediaRef, store],\r\n    );\r\n\r\n    const bufferedRanges = React.useMemo(() => {\r\n      if (!buffered || duration <= 0) return null;\r\n\r\n      return Array.from({ length: buffered.length }).map((_, i) => {\r\n        const start = buffered.start(i);\r\n        const end = buffered.end(i);\r\n        const startPercent = (start / duration) * 100;\r\n        const widthPercent = ((end - start) / duration) * 100;\r\n\r\n        return (\r\n          <div\r\n            key={i}\r\n            data-slot=\"media-player-seek-buffered\"\r\n            className=\"absolute h-full bg-zinc-400\"\r\n            style={{\r\n              left: `${startPercent}%`,\r\n              width: `${widthPercent}%`,\r\n            }}\r\n          />\r\n        );\r\n      });\r\n    }, [buffered, duration]);\r\n\r\n    const SeekSlider = (\r\n      <Tooltip delayDuration={100} open={isHoveringSeek}>\r\n        <TooltipTrigger asChild>\r\n          <SliderPrimitive.Root\r\n            aria-label=\"Seek time\"\r\n            aria-valuetext={`${formattedCurrentTime} of ${formattedDuration}`}\r\n            aria-controls={context.mediaId}\r\n            data-slider=\"\"\r\n            data-slot=\"media-player-seek\"\r\n            disabled={isDisabled}\r\n            {...seekProps}\r\n            ref={composedRef}\r\n            min={0}\r\n            max={duration}\r\n            step={0.1}\r\n            className={cn(\r\n              \"relative flex w-full touch-none select-none items-center data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\r\n              className,\r\n            )}\r\n            value={[currentTime]}\r\n            onValueChange={onSeek}\r\n            onValueCommit={onSeekCommit}\r\n            onPointerMove={onPointerMove}\r\n          >\r\n            <SliderPrimitive.Track\r\n              aria-label=\"Video progress\"\r\n              className=\"relative h-1 w-full grow overflow-hidden rounded-full bg-zinc-500\"\r\n            >\r\n              {bufferedRanges}\r\n              <SliderPrimitive.Range\r\n                aria-label=\"Current progress\"\r\n                className=\"absolute h-full bg-primary\"\r\n              />\r\n            </SliderPrimitive.Track>\r\n            <SliderPrimitive.Thumb\r\n              aria-label=\"Seek thumb\"\r\n              className=\"relative z-10 block size-2.5 shrink-0 rounded-full bg-primary shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\"\r\n            />\r\n          </SliderPrimitive.Root>\r\n        </TooltipTrigger>\r\n        {duration > 0 && (\r\n          <TooltipContent\r\n            ref={tooltipRef}\r\n            side=\"top\"\r\n            align=\"start\"\r\n            alignOffset={tooltipPositionX}\r\n            sideOffset={10}\r\n            className=\"pointer-events-none border bg-accent text-accent-foreground dark:bg-zinc-900 [&>span]:hidden\"\r\n            role=\"tooltip\"\r\n          >\r\n            {formattedHoverTime} / {formattedDuration}\r\n          </TooltipContent>\r\n        )}\r\n      </Tooltip>\r\n    );\r\n\r\n    const SeekWrapper = (\r\n      <div\r\n        role=\"presentation\"\r\n        data-slot=\"media-player-seek-wrapper\"\r\n        className={cn(\"relative w-full\", className)}\r\n        onPointerEnter={onPointerEnter}\r\n        onPointerLeave={onPointerLeave}\r\n      >\r\n        {SeekSlider}\r\n      </div>\r\n    );\r\n\r\n    if (withTime) {\r\n      return (\r\n        <div\r\n          role=\"group\"\r\n          aria-label=\"Video progress\"\r\n          className=\"flex w-full items-center gap-2\"\r\n        >\r\n          <span aria-label=\"Current time\" className=\"text-sm\">\r\n            {formattedCurrentTime}\r\n          </span>\r\n          {SeekWrapper}\r\n          <span aria-label=\"Remaining time\" className=\"text-sm\">\r\n            {formattedRemainingTime}\r\n          </span>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return SeekWrapper;\r\n  },\r\n);\r\nMediaPlayerSeek.displayName = SEEK_NAME;\r\n\r\ninterface MediaPlayerVolumeProps\r\n  extends React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root> {\r\n  asChild?: boolean;\r\n  expandable?: boolean;\r\n}\r\n\r\nconst MediaPlayerVolume = React.forwardRef<\r\n  HTMLDivElement,\r\n  MediaPlayerVolumeProps\r\n>((props, forwardedRef) => {\r\n  const {\r\n    asChild,\r\n    expandable = false,\r\n    className,\r\n    disabled,\r\n    ...volumeProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(VOLUME_NAME);\r\n  const store = useStoreContext(VOLUME_NAME);\r\n  const volume = useStore((state) => state.media.volume);\r\n  const isMuted = useStore((state) => state.media.isMuted);\r\n\r\n  const volumeTriggerId = React.useId();\r\n  const sliderId = React.useId();\r\n  const previousVolumeRef = React.useRef(volume);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onVolumeChange = React.useCallback(\r\n    (value: number[]) => {\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      const volume = value[0] ?? 0;\r\n      media.volume = volume;\r\n      media.muted = volume === 0;\r\n      previousVolumeRef.current = volume;\r\n      store.dispatch({ variant: \"SET_VOLUME\", volume });\r\n      store.dispatch({ variant: \"SET_MUTED\", isMuted: volume === 0 });\r\n    },\r\n    [context.mediaRef, store],\r\n  );\r\n\r\n  const onMute = React.useCallback(() => {\r\n    const media = context.mediaRef.current;\r\n    if (!media) return;\r\n\r\n    if (!isMuted) {\r\n      if (volume > 0) {\r\n        previousVolumeRef.current = volume;\r\n      }\r\n      media.muted = true;\r\n    } else {\r\n      const restoredVolume =\r\n        previousVolumeRef.current > 0 ? previousVolumeRef.current : 1;\r\n      media.volume = restoredVolume;\r\n      media.muted = false;\r\n    }\r\n  }, [context.mediaRef, volume, isMuted]);\r\n\r\n  return (\r\n    <div\r\n      role=\"group\"\r\n      aria-label=\"Volume controls\"\r\n      data-disabled={isDisabled ? \"\" : undefined}\r\n      className={cn(\r\n        \"group flex items-center\",\r\n        expandable ? \"gap-0 group-hover:gap-2\" : \"gap-2\",\r\n        className,\r\n      )}\r\n    >\r\n      <MediaPlayerTooltip tooltip=\"Volume\" shortcut=\"M\">\r\n        <Button\r\n          id={volumeTriggerId}\r\n          type=\"button\"\r\n          aria-label={isMuted ? \"Unmute\" : \"Mute\"}\r\n          aria-pressed={isMuted}\r\n          aria-controls={`${context.mediaId} ${sliderId}`}\r\n          data-state={isMuted ? \"muted\" : \"unmuted\"}\r\n          data-slot=\"media-player-mute\"\r\n          variant=\"ghost\"\r\n          size=\"icon\"\r\n          className=\"size-8\"\r\n          disabled={isDisabled}\r\n          onClick={onMute}\r\n        >\r\n          {isMuted ? (\r\n            <VolumeXIcon />\r\n          ) : volume > 0.5 ? (\r\n            <Volume2Icon />\r\n          ) : (\r\n            <Volume1Icon />\r\n          )}\r\n        </Button>\r\n      </MediaPlayerTooltip>\r\n      <SliderPrimitive.Root\r\n        id={sliderId}\r\n        aria-label=\"Volume\"\r\n        aria-controls={context.mediaId}\r\n        aria-valuetext={`${Math.round(volume * 100)}% volume`}\r\n        data-slider=\"\"\r\n        data-slot=\"media-player-volume\"\r\n        {...volumeProps}\r\n        ref={forwardedRef}\r\n        min={0}\r\n        max={1}\r\n        step={0.1}\r\n        className={cn(\r\n          \"relative flex touch-none select-none items-center\",\r\n          expandable\r\n            ? \"w-0 opacity-0 transition-[width,opacity] duration-200 ease-in-out group-hover:w-16 group-hover:opacity-100\"\r\n            : \"w-16\",\r\n          className,\r\n        )}\r\n        disabled={isDisabled}\r\n        value={[volume]}\r\n        onValueChange={onVolumeChange}\r\n      >\r\n        <SliderPrimitive.Track\r\n          aria-label=\"Volume track\"\r\n          className=\"relative h-1 w-full grow overflow-hidden rounded-full bg-zinc-500\"\r\n        >\r\n          <SliderPrimitive.Range\r\n            aria-label=\"Current volume\"\r\n            className=\"absolute h-full bg-primary\"\r\n          />\r\n        </SliderPrimitive.Track>\r\n        <SliderPrimitive.Thumb\r\n          aria-label=\"Volume thumb\"\r\n          className=\"block size-2.5 shrink-0 rounded-full bg-primary shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\"\r\n        />\r\n      </SliderPrimitive.Root>\r\n    </div>\r\n  );\r\n});\r\nMediaPlayerVolume.displayName = VOLUME_NAME;\r\n\r\ninterface MediaPlayerTimeProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n  mode?: \"progress\" | \"remaining\" | \"duration\";\r\n}\r\n\r\nconst MediaPlayerTime = React.forwardRef<HTMLDivElement, MediaPlayerTimeProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, className, mode = \"progress\", ...timeProps } = props;\r\n\r\n    const context = useMediaPlayerContext(TIME_NAME);\r\n    const currentTime = useStore((state) => state.media.currentTime);\r\n    const duration = useStore((state) => state.media.duration);\r\n\r\n    const formattedCurrentTime = formatTime(currentTime);\r\n    const formattedDuration = formatTime(duration);\r\n    const formattedRemainingTime = formatTime(duration - currentTime);\r\n\r\n    const TimePrimitive = asChild ? Slot : \"div\";\r\n\r\n    if (mode === \"remaining\" || mode === \"duration\") {\r\n      return (\r\n        <TimePrimitive\r\n          aria-label={mode === \"remaining\" ? \"Remaining time\" : \"Duration\"}\r\n          data-slot=\"media-player-time\"\r\n          dir={context.dir}\r\n          {...timeProps}\r\n          ref={forwardedRef}\r\n          className={cn(\"text-foreground/80 text-sm\", className)}\r\n        >\r\n          {mode === \"remaining\" ? formattedRemainingTime : formattedDuration}\r\n        </TimePrimitive>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <TimePrimitive\r\n        aria-label=\"Time\"\r\n        data-slot=\"media-player-time\"\r\n        dir={context.dir}\r\n        {...timeProps}\r\n        ref={forwardedRef}\r\n        className={cn(\r\n          \"flex items-center gap-1 text-foreground/80 text-sm\",\r\n          className,\r\n        )}\r\n      >\r\n        <span aria-label=\"Current time\">{formattedCurrentTime}</span>\r\n        <span role=\"presentation\" aria-hidden=\"true\">\r\n          /\r\n        </span>\r\n        <span aria-label=\"Duration\">{formattedDuration}</span>\r\n      </TimePrimitive>\r\n    );\r\n  },\r\n);\r\nMediaPlayerTime.displayName = TIME_NAME;\r\n\r\ninterface MediaPlayerPlaybackSpeedProps\r\n  extends React.ComponentPropsWithoutRef<typeof SelectTrigger> {\r\n  speeds?: number[];\r\n}\r\n\r\nconst MediaPlayerPlaybackSpeed = React.forwardRef<\r\n  React.ComponentRef<typeof SelectTrigger>,\r\n  MediaPlayerPlaybackSpeedProps\r\n>((props, forwardedRef) => {\r\n  const {\r\n    asChild,\r\n    speeds = SPEEDS,\r\n    className,\r\n    disabled,\r\n    ...playbackSpeedProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(PLAYBACK_SPEED_NAME);\r\n  const store = useStoreContext(PLAYBACK_SPEED_NAME);\r\n  const playbackRate = useStore((state) => state.media.playbackRate);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onPlaybackRateChange = React.useCallback(\r\n    (value: string) => {\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      const rate = Number.parseFloat(value);\r\n      media.playbackRate = rate;\r\n      store.dispatch({ variant: \"SET_PLAYBACK_RATE\", playbackRate: rate });\r\n    },\r\n    [context.mediaRef, store],\r\n  );\r\n\r\n  return (\r\n    <Select\r\n      data-slot=\"media-player-playback-speed\"\r\n      value={playbackRate.toString()}\r\n      onValueChange={onPlaybackRateChange}\r\n    >\r\n      <MediaPlayerTooltip tooltip=\"Playback speed\" shortcut={[\"<\", \">\"]}>\r\n        <SelectTrigger\r\n          aria-controls={context.mediaId}\r\n          disabled={isDisabled}\r\n          {...playbackSpeedProps}\r\n          ref={forwardedRef}\r\n          className={cn(\r\n            \"h-8 w-16 justify-center border-none aria-expanded:bg-accent aria-[expanded=true]:bg-accent/50 dark:bg-transparent dark:aria-[expanded=true]:bg-accent/50 dark:hover:bg-accent/50 [&[data-size]]:h-8 [&_svg]:hidden\",\r\n            className,\r\n          )}\r\n        >\r\n          <SelectValue>{playbackRate}x</SelectValue>\r\n        </SelectTrigger>\r\n      </MediaPlayerTooltip>\r\n      <SelectContent\r\n        align=\"center\"\r\n        className=\"min-w-[var(--radix-select-trigger-width)]\"\r\n      >\r\n        {speeds.map((speed) => (\r\n          <SelectItem key={speed} value={speed.toString()}>\r\n            {speed}x\r\n          </SelectItem>\r\n        ))}\r\n      </SelectContent>\r\n    </Select>\r\n  );\r\n});\r\nMediaPlayerPlaybackSpeed.displayName = PLAYBACK_SPEED_NAME;\r\n\r\ninterface MediaPlayerLoopProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {\r\n  mode?: \"toggle\" | \"repeat\";\r\n}\r\n\r\nconst MediaPlayerLoop = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerLoopProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, mode = \"toggle\", ...loopProps } = props;\r\n\r\n  const context = useMediaPlayerContext(LOOP_NAME);\r\n  const store = useStoreContext(LOOP_NAME);\r\n  const loopMode = useStore((state) => state.media.loopMode);\r\n  const isDisabled = props.disabled || context.disabled;\r\n\r\n  const onLoopToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      let nextLoopMode: LoopMode = \"off\";\r\n\r\n      if (mode === \"toggle\") {\r\n        if (loopMode === \"off\") {\r\n          nextLoopMode = \"all\";\r\n        } else {\r\n          nextLoopMode = \"off\";\r\n        }\r\n      } else {\r\n        if (loopMode === \"off\") {\r\n          nextLoopMode = \"all\";\r\n        } else if (loopMode === \"all\") {\r\n          nextLoopMode = \"one\";\r\n        } else {\r\n          nextLoopMode = \"off\";\r\n        }\r\n      }\r\n\r\n      media.loop = nextLoopMode === \"all\";\r\n      store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: nextLoopMode });\r\n    },\r\n    [context.mediaRef, props.onClick, store, loopMode, mode],\r\n  );\r\n\r\n  const getTooltipText = React.useCallback(() => {\r\n    if (mode === \"toggle\") {\r\n      return loopMode === \"all\" ? \"Disable loop\" : \"Enable loop\";\r\n    }\r\n    if (loopMode === \"off\") return \"Repeat all\";\r\n    if (loopMode === \"all\") return \"Repeat one\";\r\n    return \"Disable repeat\";\r\n  }, [loopMode, mode]);\r\n\r\n  const getAriaLabel = React.useCallback(() => {\r\n    if (mode === \"toggle\") {\r\n      return loopMode === \"all\" ? \"Disable loop\" : \"Enable loop\";\r\n    }\r\n    if (loopMode === \"off\") return \"Enable repeat all\";\r\n    if (loopMode === \"all\") return \"Enable repeat one\";\r\n    return \"Disable repeat\";\r\n  }, [loopMode, mode]);\r\n\r\n  const LoopIcon = React.useCallback(() => {\r\n    if (loopMode === \"one\") return <Repeat1Icon />;\r\n    return (\r\n      <RepeatIcon className={cn(loopMode === \"off\" && \"text-foreground/60\")} />\r\n    );\r\n  }, [loopMode]);\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip={getTooltipText()} shortcut=\"R\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={getAriaLabel()}\r\n        aria-controls={context.mediaId}\r\n        aria-pressed={loopMode !== \"off\"}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-state={loopMode}\r\n        data-slot=\"media-player-loop\"\r\n        disabled={isDisabled}\r\n        {...loopProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onLoopToggle}\r\n      >\r\n        {children ?? <LoopIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerLoop.displayName = LOOP_NAME;\r\n\r\ninterface MediaPlayerFullscreenProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\r\n\r\nconst MediaPlayerFullscreen = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerFullscreenProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, disabled, ...fullscreenProps } = props;\r\n\r\n  const context = useMediaPlayerContext(FULLSCREEN_NAME);\r\n  const store = useStoreContext(FULLSCREEN_NAME);\r\n  const isFullscreen = useStore((state) => state.media.isFullscreen);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onFullscreen = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      if (!document.fullscreenElement) {\r\n        const container = media.closest('[data-slot=\"media-player\"]');\r\n        if (container) {\r\n          container.requestFullscreen();\r\n        } else {\r\n          media.requestFullscreen();\r\n        }\r\n        store.dispatch({ variant: \"SET_FULLSCREEN\", isFullscreen: true });\r\n      } else {\r\n        document.exitFullscreen();\r\n        store.dispatch({ variant: \"SET_FULLSCREEN\", isFullscreen: false });\r\n      }\r\n    },\r\n    [context.mediaRef, props.onClick, store],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Fullscreen\" shortcut=\"F\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={isFullscreen ? \"Exit fullscreen\" : \"Enter fullscreen\"}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n        data-slot=\"media-player-fullscreen\"\r\n        disabled={isDisabled}\r\n        {...fullscreenProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onFullscreen}\r\n      >\r\n        {children ?? (isFullscreen ? <Minimize2Icon /> : <Maximize2Icon />)}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerFullscreen.displayName = FULLSCREEN_NAME;\r\n\r\ninterface MediaPlayerPiPProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {\r\n  onPipError?: (error: unknown, mode: \"enter\" | \"exit\") => void;\r\n}\r\n\r\nconst MediaPlayerPiP = React.forwardRef<HTMLButtonElement, MediaPlayerPiPProps>(\r\n  (props, forwardedRef) => {\r\n    const {\r\n      asChild,\r\n      children,\r\n      className,\r\n      onPipError,\r\n      disabled,\r\n      ...pipButtonProps\r\n    } = props;\r\n\r\n    const context = useMediaPlayerContext(PIP_NAME);\r\n    const isPictureInPicture = useStore(\r\n      (state) => state.media.isPictureInPicture,\r\n    );\r\n\r\n    const isDisabled = disabled || context.disabled;\r\n\r\n    const onPictureInPicture = React.useCallback(\r\n      (event: React.MouseEvent<HTMLButtonElement>) => {\r\n        props.onClick?.(event);\r\n\r\n        if (event.defaultPrevented) return;\r\n\r\n        const media = context.mediaRef.current;\r\n        if (!media || !(media instanceof HTMLVideoElement)) return;\r\n\r\n        if (document.pictureInPictureElement === media) {\r\n          document.exitPictureInPicture().catch((error) => {\r\n            onPipError?.(error, \"exit\");\r\n          });\r\n        } else {\r\n          media.requestPictureInPicture().catch((error) => {\r\n            onPipError?.(error, \"enter\");\r\n          });\r\n        }\r\n      },\r\n      [context.mediaRef, props.onClick, onPipError],\r\n    );\r\n\r\n    return (\r\n      <MediaPlayerTooltip tooltip=\"Picture in picture\" shortcut=\"P\">\r\n        <Button\r\n          type=\"button\"\r\n          aria-label={isPictureInPicture ? \"Exit pip\" : \"Enter pip\"}\r\n          data-disabled={isDisabled ? \"\" : undefined}\r\n          data-state={isPictureInPicture ? \"pip\" : \"inline\"}\r\n          data-slot=\"media-player-pip\"\r\n          disabled={isDisabled}\r\n          {...pipButtonProps}\r\n          ref={forwardedRef}\r\n          variant=\"ghost\"\r\n          size=\"icon\"\r\n          className={cn(\"size-8\", className)}\r\n          onClick={onPictureInPicture}\r\n        >\r\n          {isPictureInPicture ? (\r\n            <PictureInPicture2Icon />\r\n          ) : (\r\n            <PictureInPictureIcon />\r\n          )}\r\n        </Button>\r\n      </MediaPlayerTooltip>\r\n    );\r\n  },\r\n);\r\nMediaPlayerPiP.displayName = PIP_NAME;\r\n\r\ninterface MediaPlayerCaptionsProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\r\n\r\nconst MediaPlayerCaptions = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerCaptionsProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, disabled, ...captionsProps } = props;\r\n\r\n  const context = useMediaPlayerContext(CAPTIONS_NAME);\r\n  const store = useStoreContext(CAPTIONS_NAME);\r\n  const captionsEnabled = useStore((state) => state.media.captionsEnabled);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onToggleCaptions = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n      const media = context.mediaRef.current;\r\n      if (!media) return;\r\n\r\n      if (media instanceof HTMLVideoElement && media.textTracks.length > 0) {\r\n        for (let i = 0; i < media.textTracks.length; i++) {\r\n          const track = media.textTracks[i];\r\n          if (\r\n            track &&\r\n            (track.kind === \"captions\" || track.kind === \"subtitles\")\r\n          ) {\r\n            track.mode = captionsEnabled ? \"hidden\" : \"showing\";\r\n          }\r\n        }\r\n      }\r\n\r\n      store.dispatch({\r\n        variant: \"SET_CAPTIONS_ENABLED\",\r\n        captionsEnabled: !captionsEnabled,\r\n      });\r\n    },\r\n    [context.mediaRef, props.onClick, store, captionsEnabled],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Captions\" shortcut=\"C\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={captionsEnabled ? \"Disable captions\" : \"Enable captions\"}\r\n        aria-controls={context.mediaId}\r\n        aria-pressed={captionsEnabled}\r\n        data-state={captionsEnabled ? \"active\" : \"inactive\"}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-captions\"\r\n        disabled={isDisabled}\r\n        {...captionsProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onToggleCaptions}\r\n      >\r\n        {children ??\r\n          (captionsEnabled ? <SubtitlesIcon /> : <CaptionsOffIcon />)}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerCaptions.displayName = CAPTIONS_NAME;\r\n\r\ninterface MediaPlayerDownloadProps\r\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\r\n\r\nconst MediaPlayerDownload = React.forwardRef<\r\n  HTMLButtonElement,\r\n  MediaPlayerDownloadProps\r\n>((props, forwardedRef) => {\r\n  const { asChild, children, className, disabled, ...downloadProps } = props;\r\n\r\n  const context = useMediaPlayerContext(DOWNLOAD_NAME);\r\n  const mediaUrl = context.mediaRef.current?.currentSrc;\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onDownload = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const media = context.mediaRef.current;\r\n      if (!media || !mediaUrl) return;\r\n\r\n      const link = document.createElement(\"a\");\r\n      link.href = mediaUrl;\r\n      link.download = \"\";\r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n    },\r\n    [context.mediaRef, mediaUrl, props.onClick],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Download\" shortcut=\"D\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-label=\"Download\"\r\n        aria-controls={context.mediaId}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-download\"\r\n        disabled={isDisabled}\r\n        {...downloadProps}\r\n        ref={forwardedRef}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onDownload}\r\n      >\r\n        {children ?? <DownloadIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n});\r\nMediaPlayerDownload.displayName = DOWNLOAD_NAME;\r\n\r\ninterface MediaPlayerTooltipProps\r\n  extends React.ComponentPropsWithoutRef<typeof Tooltip> {\r\n  tooltip?: string;\r\n  shortcut?: string | string[];\r\n}\r\n\r\nfunction MediaPlayerTooltip({\r\n  tooltip,\r\n  shortcut,\r\n  children,\r\n  ...props\r\n}: MediaPlayerTooltipProps) {\r\n  if (!tooltip && !shortcut) return <>{children}</>;\r\n\r\n  return (\r\n    <Tooltip {...props} delayDuration={600}>\r\n      <TooltipTrigger\r\n        className=\"text-foreground focus-visible:ring-ring/80\"\r\n        asChild\r\n      >\r\n        {children}\r\n      </TooltipTrigger>\r\n      <TooltipContent\r\n        sideOffset={10}\r\n        className=\"flex items-center gap-2 border bg-accent px-2 py-1 font-medium text-foreground dark:bg-zinc-900 [&>span]:hidden\"\r\n      >\r\n        <p>{tooltip}</p>\r\n        {Array.isArray(shortcut) ? (\r\n          <div className=\"flex items-center gap-1\">\r\n            {shortcut.map((shortcutKey) => (\r\n              <kbd\r\n                key={shortcutKey}\r\n                className=\"select-none rounded border bg-secondary px-1.5 py-0.5 font-mono text-[0.7rem] text-foreground shadow-xs\"\r\n              >\r\n                <abbr title={shortcutKey} className=\"no-underline\">\r\n                  {shortcutKey}\r\n                </abbr>\r\n              </kbd>\r\n            ))}\r\n          </div>\r\n        ) : (\r\n          <kbd\r\n            key={shortcut}\r\n            className=\"select-none rounded border bg-secondary px-1.5 py-px font-mono text-[0.7rem] text-foreground shadow-xs\"\r\n          >\r\n            <abbr title={shortcut} className=\"no-underline\">\r\n              {shortcut}\r\n            </abbr>\r\n          </kbd>\r\n        )}\r\n      </TooltipContent>\r\n    </Tooltip>\r\n  );\r\n}\r\n\r\nconst MediaPlayer = MediaPlayerRoot;\r\nconst Root = MediaPlayerRoot;\r\nconst Controls = MediaPlayerControls;\r\nconst Overlay = MediaPlayerOverlay;\r\nconst Play = MediaPlayerPlay;\r\nconst SeekForward = MediaPlayerSeekForward;\r\nconst SeekBackward = MediaPlayerSeekBackward;\r\nconst Seek = MediaPlayerSeek;\r\nconst Volume = MediaPlayerVolume;\r\nconst Time = MediaPlayerTime;\r\nconst Fullscreen = MediaPlayerFullscreen;\r\nconst PiP = MediaPlayerPiP;\r\nconst Video = MediaPlayerVideo;\r\nconst Audio = MediaPlayerAudio;\r\nconst PlaybackSpeed = MediaPlayerPlaybackSpeed;\r\nconst Captions = MediaPlayerCaptions;\r\nconst Download = MediaPlayerDownload;\r\nconst Loop = MediaPlayerLoop;\r\n\r\nexport {\r\n  MediaPlayer,\r\n  MediaPlayerVideo,\r\n  MediaPlayerAudio,\r\n  MediaPlayerControls,\r\n  MediaPlayerOverlay,\r\n  MediaPlayerPlay,\r\n  MediaPlayerSeekBackward,\r\n  MediaPlayerSeekForward,\r\n  MediaPlayerSeek,\r\n  MediaPlayerVolume,\r\n  MediaPlayerTime,\r\n  MediaPlayerPlaybackSpeed,\r\n  MediaPlayerLoop,\r\n  MediaPlayerFullscreen,\r\n  MediaPlayerPiP,\r\n  MediaPlayerCaptions,\r\n  MediaPlayerDownload,\r\n  //\r\n  Root,\r\n  Video,\r\n  Audio,\r\n  Controls,\r\n  Overlay,\r\n  Play,\r\n  SeekBackward,\r\n  SeekForward,\r\n  Seek,\r\n  Volume,\r\n  Time,\r\n  PlaybackSpeed,\r\n  Loop,\r\n  Fullscreen,\r\n  PiP,\r\n  Captions,\r\n  Download,\r\n  //\r\n  useStore as useMediaPlayer,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/composition.ts",
      "content": "import * as React from \"react\";\n\n/**\n * A utility to compose multiple event handlers into a single event handler.\n * Run originalEventHandler first, then ourEventHandler unless prevented.\n */\nfunction composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (\n      checkForDefaultPrevented === false ||\n      !(event as unknown as Event).defaultPrevented\n    ) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value.\n * This utility takes care of different types of refs: callback refs and RefObject(s).\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together.\n * Accepts callback refs and RefObject(s).\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs.\n * Accepts callback refs and RefObject(s).\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeEventHandlers, composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}