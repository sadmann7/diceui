{
  "name": "media-player",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "select",
    "slider",
    "tooltip"
  ],
  "files": [
    {
      "path": "ui/media-player.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { useComposedRefs } from \"@/lib/composition\";\nimport { cn } from \"@/lib/utils\";\nimport * as SliderPrimitive from \"@radix-ui/react-slider\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport {\n  CaptionsOffIcon,\n  DownloadIcon,\n  FastForwardIcon,\n  Maximize2Icon,\n  Minimize2Icon,\n  PauseIcon,\n  PictureInPicture2Icon,\n  PictureInPictureIcon,\n  PlayIcon,\n  Repeat1Icon,\n  RepeatIcon,\n  RewindIcon,\n  SubtitlesIcon,\n  Volume1Icon,\n  Volume2Icon,\n  VolumeXIcon,\n} from \"lucide-react\";\nimport * as React from \"react\";\n\nconst POINTER_MOVE_THROTTLE_MS = 16;\nconst SEEK_THROTTLE_MS = 100;\nconst SEEK_AMOUNT_SHORT = 5;\nconst SEEK_AMOUNT_LONG = 10;\nconst SPEEDS = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];\n\nconst ROOT_NAME = \"MediaPlayer\";\nconst VIDEO_NAME = \"MediaPlayerVideo\";\nconst AUDIO_NAME = \"MediaPlayerAudio\";\nconst CONTROLS_NAME = \"MediaPlayerControls\";\nconst OVERLAY_NAME = \"MediaPlayerOverlay\";\nconst PLAY_NAME = \"MediaPlayerPlay\";\nconst SEEK_BACKWARD_NAME = \"MediaPlayerSeekBackward\";\nconst SEEK_FORWARD_NAME = \"MediaPlayerSeekForward\";\nconst SEEK_NAME = \"MediaPlayerSeek\";\nconst VOLUME_NAME = \"MediaPlayerVolume\";\nconst TIME_NAME = \"MediaPlayerTime\";\nconst PLAYBACK_SPEED_NAME = \"MediaPlayerPlaybackSpeed\";\nconst LOOP_NAME = \"MediaPlayerLoop\";\nconst FULLSCREEN_NAME = \"MediaPlayerFullscreen\";\nconst PIP_NAME = \"MediaPlayerPiP\";\nconst CAPTIONS_NAME = \"MediaPlayerCaptions\";\nconst DOWNLOAD_NAME = \"MediaPlayerDownload\";\n\nconst MEDIA_PLAYER_ERRORS = {\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` must be used as root component`,\n  [VIDEO_NAME]: `\\`${VIDEO_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [AUDIO_NAME]: `\\`${AUDIO_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [CONTROLS_NAME]: `\\`${CONTROLS_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [OVERLAY_NAME]: `\\`${OVERLAY_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [PLAY_NAME]: `\\`${PLAY_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [SEEK_BACKWARD_NAME]: `\\`${SEEK_BACKWARD_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [SEEK_FORWARD_NAME]: `\\`${SEEK_FORWARD_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [SEEK_NAME]: `\\`${SEEK_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [VOLUME_NAME]: `\\`${VOLUME_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [TIME_NAME]: `\\`${TIME_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [PLAYBACK_SPEED_NAME]: `\\`${PLAYBACK_SPEED_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [LOOP_NAME]: `\\`${LOOP_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [FULLSCREEN_NAME]: `\\`${FULLSCREEN_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [PIP_NAME]: `\\`${PIP_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [CAPTIONS_NAME]: `\\`${CAPTIONS_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [DOWNLOAD_NAME]: `\\`${DOWNLOAD_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n} as const;\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nfunction useAsRef<T>(data: T) {\n  const ref = React.useRef<T>(data);\n  useIsomorphicLayoutEffect(() => {\n    ref.current = data;\n  });\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n  return ref as React.RefObject<T>;\n}\n\nfunction formatTime(time: number) {\n  const hours = Math.floor(time / 3600);\n  const minutes = Math.floor((time % 3600) / 60);\n  const seconds = Math.floor(time % 60);\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${seconds.toString().padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${seconds.toString().padStart(2, \"0\")}`;\n}\n\nfunction getIsVideo(\n  mediaRef: React.RefObject<HTMLVideoElement | HTMLAudioElement | null>,\n) {\n  return (\n    typeof window !== \"undefined\" &&\n    mediaRef.current instanceof HTMLVideoElement\n  );\n}\n\ntype Direction = \"ltr\" | \"rtl\";\n\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\nfunction useDirection(dirProp?: Direction): Direction {\n  const contextDir = React.useContext(DirectionContext);\n  return dirProp ?? contextDir ?? \"ltr\";\n}\n\ntype LoopMode = \"off\" | \"all\" | \"one\";\n\ninterface MediaState {\n  isPlaying: boolean;\n  isMuted: boolean;\n  volume: number;\n  currentTime: number;\n  duration: number;\n  buffered: TimeRanges | null;\n  isFullscreen: boolean;\n  isLooping: boolean;\n  loopMode: LoopMode;\n  playbackRate: number;\n  isPictureInPicture: boolean;\n  captionsEnabled: boolean;\n}\n\ninterface StoreState {\n  media: MediaState;\n}\n\ntype StoreAction =\n  | { variant: \"SET_PLAYING\"; isPlaying: boolean }\n  | { variant: \"SET_MUTED\"; isMuted: boolean }\n  | { variant: \"SET_VOLUME\"; volume: number }\n  | { variant: \"SET_CURRENT_TIME\"; currentTime: number }\n  | { variant: \"SET_DURATION\"; duration: number }\n  | { variant: \"SET_BUFFERED\"; buffered: TimeRanges }\n  | { variant: \"SET_FULLSCREEN\"; isFullscreen: boolean }\n  | { variant: \"SET_LOOP_MODE\"; loopMode: LoopMode }\n  | { variant: \"SET_PLAYBACK_RATE\"; playbackRate: number }\n  | { variant: \"SET_PICTURE_IN_PICTURE\"; isPictureInPicture: boolean }\n  | { variant: \"SET_CAPTIONS_ENABLED\"; captionsEnabled: boolean };\n\nfunction createStore(listeners: Set<() => void>, initialState: MediaState) {\n  let state: StoreState = {\n    media: initialState,\n  };\n\n  function getState() {\n    return state;\n  }\n\n  function dispatch(action: StoreAction) {\n    switch (action.variant) {\n      case \"SET_PLAYING\":\n        state = {\n          ...state,\n          media: { ...state.media, isPlaying: action.isPlaying },\n        };\n        break;\n\n      case \"SET_MUTED\":\n        state = {\n          ...state,\n          media: { ...state.media, isMuted: action.isMuted },\n        };\n        break;\n\n      case \"SET_VOLUME\":\n        state = {\n          ...state,\n          media: { ...state.media, volume: action.volume },\n        };\n        break;\n\n      case \"SET_CURRENT_TIME\":\n        state = {\n          ...state,\n          media: { ...state.media, currentTime: action.currentTime },\n        };\n        break;\n\n      case \"SET_DURATION\":\n        state = {\n          ...state,\n          media: { ...state.media, duration: action.duration },\n        };\n        break;\n\n      case \"SET_BUFFERED\":\n        state = {\n          ...state,\n          media: { ...state.media, buffered: action.buffered },\n        };\n        break;\n\n      case \"SET_FULLSCREEN\":\n        state = {\n          ...state,\n          media: { ...state.media, isFullscreen: action.isFullscreen },\n        };\n        break;\n\n      case \"SET_LOOP_MODE\":\n        state = {\n          ...state,\n          media: { ...state.media, loopMode: action.loopMode },\n        };\n        break;\n\n      case \"SET_PLAYBACK_RATE\":\n        state = {\n          ...state,\n          media: { ...state.media, playbackRate: action.playbackRate },\n        };\n        break;\n\n      case \"SET_PICTURE_IN_PICTURE\":\n        state = {\n          ...state,\n          media: {\n            ...state.media,\n            isPictureInPicture: action.isPictureInPicture,\n          },\n        };\n        break;\n\n      case \"SET_CAPTIONS_ENABLED\":\n        state = {\n          ...state,\n          media: { ...state.media, captionsEnabled: action.captionsEnabled },\n        };\n        break;\n    }\n\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n\n  function subscribe(listener: () => void) {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  }\n\n  return { getState, dispatch, subscribe };\n}\n\nconst StoreContext = React.createContext<ReturnType<typeof createStore> | null>(\n  null,\n);\nStoreContext.displayName = ROOT_NAME;\n\nfunction useStoreContext(name: keyof typeof MEDIA_PLAYER_ERRORS) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(MEDIA_PLAYER_ERRORS[name]);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(ROOT_NAME);\n\n  const lastValueRef = useLazyRef<{ value: T; state: StoreState } | null>(\n    () => null,\n  );\n\n  const getSnapshot = React.useCallback(() => {\n    const state = store.getState();\n    const prevValue = lastValueRef.current;\n\n    if (prevValue && prevValue.state === state) {\n      return prevValue.value;\n    }\n\n    const nextValue = selector(state);\n    lastValueRef.current = { value: nextValue, state };\n    return nextValue;\n  }, [store, selector, lastValueRef]);\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface MediaPlayerContextValue {\n  mediaId: string;\n  labelId: string;\n  descriptionId: string;\n  dir: Direction;\n  disabled: boolean;\n  mediaRef: React.RefObject<HTMLVideoElement | HTMLAudioElement | null>;\n}\n\nconst MediaPlayerContext = React.createContext<MediaPlayerContextValue | null>(\n  null,\n);\n\nfunction useMediaPlayerContext(name: keyof typeof MEDIA_PLAYER_ERRORS) {\n  const context = React.useContext(MediaPlayerContext);\n  if (!context) {\n    throw new Error(MEDIA_PLAYER_ERRORS[name]);\n  }\n  return context;\n}\n\ninterface MediaPlayerRootProps\n  extends Omit<\n    React.ComponentPropsWithoutRef<\"div\">,\n    \"onTimeUpdate\" | \"onVolumeChange\"\n  > {\n  defaultVolume?: number;\n  onPlay?: () => void;\n  onPause?: () => void;\n  onEnded?: () => void;\n  onTimeUpdate?: (time: number) => void;\n  onVolumeChange?: (volume: number) => void;\n  onMuted?: (muted: boolean) => void;\n  onPipError?: (error: unknown, mode: \"enter\" | \"exit\") => void;\n  onFullscreenChange?: (fullscreen: boolean) => void;\n  dir?: Direction;\n  label?: string;\n  asChild?: boolean;\n  disabled?: boolean;\n}\n\nconst MediaPlayerRoot = React.forwardRef<HTMLDivElement, MediaPlayerRootProps>(\n  (props, forwardedRef) => {\n    const {\n      defaultVolume = 1,\n      onPlay,\n      onPause,\n      onEnded,\n      onTimeUpdate,\n      onVolumeChange,\n      onMuted,\n      onPipError,\n      onFullscreenChange,\n      asChild,\n      disabled = false,\n      dir: dirProp,\n      label,\n      children,\n      className,\n      ...rootProps\n    } = props;\n\n    const mediaId = React.useId();\n    const labelId = React.useId();\n    const descriptionId = React.useId();\n\n    const dir = useDirection(dirProp);\n    const propsRef = useAsRef(props);\n    const listeners = useLazyRef(() => new Set<() => void>()).current;\n\n    const mediaRef = React.useRef<HTMLVideoElement | HTMLAudioElement>(null);\n    const previousVolumeRef = React.useRef(defaultVolume);\n\n    const initialState = React.useMemo<MediaState>(() => {\n      return {\n        isPlaying: mediaRef.current?.autoplay ?? false,\n        isMuted: mediaRef.current?.muted ?? false,\n        volume: mediaRef.current?.volume ?? defaultVolume,\n        currentTime: 0,\n        duration: 0,\n        buffered: null,\n        isFullscreen: false,\n        isLooping: mediaRef.current?.loop ?? false,\n        loopMode: mediaRef.current?.loop ? \"all\" : \"off\",\n        playbackRate: 1,\n        isPictureInPicture: false,\n        captionsEnabled: false,\n      };\n    }, [defaultVolume]);\n\n    const store = React.useMemo(\n      () => createStore(listeners, initialState),\n      [listeners, initialState],\n    );\n\n    const contextValue = React.useMemo<MediaPlayerContextValue>(\n      () => ({\n        mediaId,\n        labelId,\n        descriptionId,\n        mediaRef,\n        dir,\n        disabled,\n      }),\n      [mediaId, labelId, descriptionId, dir, disabled],\n    );\n\n    const onKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (disabled) return;\n\n        propsRef.current.onKeyDown?.(event);\n\n        if (event.defaultPrevented) return;\n\n        const media = mediaRef.current;\n        if (!media) return;\n\n        const isMediaFocused = document.activeElement === media;\n        const isPlayerFocused =\n          document.activeElement?.closest('[data-slot=\"media-player\"]') !==\n          null;\n\n        if (!isMediaFocused && !isPlayerFocused) return;\n\n        switch (event.key.toLowerCase()) {\n          case \" \":\n          case \"k\":\n            event.preventDefault();\n            if (media.paused) {\n              media.play();\n            } else {\n              media.pause();\n            }\n            break;\n\n          case \"f\":\n            event.preventDefault();\n            if (!document.fullscreenElement) {\n              const container = media.closest('[data-slot=\"media-player\"]');\n              if (container) {\n                container.requestFullscreen();\n              } else {\n                media.requestFullscreen();\n              }\n            } else {\n              document.exitFullscreen();\n            }\n            break;\n\n          case \"m\": {\n            event.preventDefault();\n            const currentVolume = store.getState().media.volume;\n            const currentMuted = store.getState().media.isMuted;\n            if (!currentMuted) {\n              previousVolumeRef.current =\n                currentVolume > 0 ? currentVolume : previousVolumeRef.current;\n              store.dispatch({ variant: \"SET_VOLUME\", volume: 0 });\n              store.dispatch({ variant: \"SET_MUTED\", isMuted: true });\n              if (media) {\n                media.volume = 0;\n                media.muted = true;\n              }\n            } else {\n              const restoredVolume = previousVolumeRef.current || 1;\n              store.dispatch({\n                variant: \"SET_VOLUME\",\n                volume: restoredVolume,\n              });\n              store.dispatch({ variant: \"SET_MUTED\", isMuted: false });\n              if (media) {\n                media.volume = restoredVolume;\n                media.muted = false;\n              }\n            }\n            break;\n          }\n\n          case \"arrowright\":\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              media.currentTime = Math.min(\n                media.duration,\n                media.currentTime + SEEK_AMOUNT_SHORT,\n              );\n            } else if (media instanceof HTMLAudioElement && event.shiftKey) {\n              media.currentTime = Math.min(\n                media.duration,\n                media.currentTime + SEEK_AMOUNT_SHORT,\n              );\n            }\n            break;\n\n          case \"arrowleft\":\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              media.currentTime = Math.max(\n                0,\n                media.currentTime - SEEK_AMOUNT_SHORT,\n              );\n            } else if (media instanceof HTMLAudioElement && event.shiftKey) {\n              media.currentTime = Math.max(\n                0,\n                media.currentTime - SEEK_AMOUNT_SHORT,\n              );\n            }\n            break;\n\n          case \"arrowup\":\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              media.volume = Math.min(1, media.volume + 0.1);\n            }\n            break;\n\n          case \"arrowdown\":\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              media.volume = Math.max(0, media.volume - 0.1);\n            }\n            break;\n\n          case \"<\": {\n            event.preventDefault();\n            const decreaseRate = store.getState().media.playbackRate;\n            const decreaseIndex = SPEEDS.indexOf(decreaseRate);\n            const newDecreaseIndex = Math.max(0, decreaseIndex - 1);\n            const newDecreaseRate = SPEEDS[newDecreaseIndex] ?? 1;\n\n            media.playbackRate = newDecreaseRate;\n            store.dispatch({\n              variant: \"SET_PLAYBACK_RATE\",\n              playbackRate: newDecreaseRate,\n            });\n            break;\n          }\n\n          case \">\": {\n            event.preventDefault();\n            const increaseRate = store.getState().media.playbackRate;\n            const increaseIndex = SPEEDS.indexOf(increaseRate);\n            const newIncreaseIndex = Math.min(\n              SPEEDS.length - 1,\n              increaseIndex + 1,\n            );\n            const newIncreaseRate = SPEEDS[newIncreaseIndex] ?? 1;\n\n            media.playbackRate = newIncreaseRate;\n            store.dispatch({\n              variant: \"SET_PLAYBACK_RATE\",\n              playbackRate: newIncreaseRate,\n            });\n            break;\n          }\n\n          case \"c\":\n            event.preventDefault();\n            if (\n              media instanceof HTMLVideoElement &&\n              media.textTracks.length > 0\n            ) {\n              const captionsEnabled = store.getState().media.captionsEnabled;\n              for (let i = 0; i < media.textTracks.length; i++) {\n                const track = media.textTracks[i];\n                if (\n                  track &&\n                  (track.kind === \"captions\" || track.kind === \"subtitles\")\n                ) {\n                  track.mode = captionsEnabled ? \"hidden\" : \"showing\";\n                }\n              }\n              store.dispatch({\n                variant: \"SET_CAPTIONS_ENABLED\",\n                captionsEnabled: !captionsEnabled,\n              });\n            }\n            break;\n\n          case \"d\": {\n            event.preventDefault();\n            if (media.currentSrc) {\n              const link = document.createElement(\"a\");\n              link.href = media.currentSrc;\n              link.download = \"\";\n              document.body.appendChild(link);\n              link.click();\n              document.body.removeChild(link);\n            }\n            break;\n          }\n\n          case \"p\": {\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              if (document.pictureInPictureElement === media) {\n                document.exitPictureInPicture().catch((error) => {\n                  propsRef.current.onPipError?.(error, \"exit\");\n                });\n              } else {\n                media.requestPictureInPicture().catch((error) => {\n                  propsRef.current.onPipError?.(error, \"enter\");\n                });\n              }\n            }\n            break;\n          }\n\n          case \"r\": {\n            event.preventDefault();\n            const currentLoopMode = store.getState().media.loopMode;\n            if (currentLoopMode === \"one\") {\n              if (media) {\n                media.currentTime = 0;\n                media.play();\n                store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: \"off\" });\n              }\n            } else {\n              store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: \"one\" });\n            }\n            break;\n          }\n\n          case \"j\": {\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              media.currentTime = Math.max(\n                0,\n                media.currentTime - SEEK_AMOUNT_LONG,\n              );\n            }\n            break;\n          }\n\n          case \"l\": {\n            event.preventDefault();\n            if (media instanceof HTMLVideoElement) {\n              media.currentTime = Math.min(\n                media.duration,\n                media.currentTime + SEEK_AMOUNT_LONG,\n              );\n            }\n            break;\n          }\n        }\n      },\n      [\n        store,\n        propsRef.current.onKeyDown,\n        propsRef.current.onPipError,\n        disabled,\n      ],\n    );\n\n    const initialVolumeSetRef = React.useRef(false);\n\n    React.useEffect(() => {\n      const media = mediaRef.current;\n      if (!media) return;\n\n      if (!initialVolumeSetRef.current) {\n        const initialVolumeProp = propsRef.current.defaultVolume;\n        if (\n          typeof initialVolumeProp === \"number\" &&\n          media.volume !== initialVolumeProp\n        ) {\n          media.volume = initialVolumeProp;\n        }\n        initialVolumeSetRef.current = true;\n      }\n\n      if (media.muted !== store.getState().media.isMuted) {\n        const actualVolume = media.muted ? 0 : media.volume;\n        if (media.muted && store.getState().media.volume !== 0) {\n          previousVolumeRef.current = store.getState().media.volume;\n        }\n        store.dispatch({ variant: \"SET_MUTED\", isMuted: media.muted });\n        store.dispatch({ variant: \"SET_VOLUME\", volume: actualVolume });\n      }\n      if (media.volume !== store.getState().media.volume && !media.muted) {\n        store.dispatch({ variant: \"SET_VOLUME\", volume: media.volume });\n      }\n\n      const onTimeUpdate = () => {\n        store.dispatch({\n          variant: \"SET_CURRENT_TIME\",\n          currentTime: media.currentTime,\n        });\n        propsRef.current.onTimeUpdate?.(media.currentTime);\n      };\n\n      const onDurationChange = () => {\n        store.dispatch({\n          variant: \"SET_DURATION\",\n          duration: media.duration,\n        });\n        store.dispatch({\n          variant: \"SET_BUFFERED\",\n          buffered: media.buffered,\n        });\n      };\n\n      const onProgress = () => {\n        store.dispatch({\n          variant: \"SET_BUFFERED\",\n          buffered: media.buffered,\n        });\n      };\n\n      const onSeeked = () => {\n        store.dispatch({\n          variant: \"SET_BUFFERED\",\n          buffered: media.buffered,\n        });\n      };\n\n      const onPlay = () => {\n        store.dispatch({ variant: \"SET_PLAYING\", isPlaying: true });\n        propsRef.current.onPlay?.();\n      };\n\n      const onPause = () => {\n        store.dispatch({ variant: \"SET_PLAYING\", isPlaying: false });\n        propsRef.current.onPause?.();\n      };\n\n      const onEnded = () => {\n        store.dispatch({ variant: \"SET_PLAYING\", isPlaying: false });\n        propsRef.current.onEnded?.();\n        const currentLoopMode = store.getState().media.loopMode;\n        if (currentLoopMode === \"one\") {\n          if (media) {\n            media.currentTime = 0;\n            media.play();\n            store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: \"off\" });\n          }\n        } else {\n          store.dispatch({ variant: \"SET_PLAYING\", isPlaying: false });\n          propsRef.current.onEnded?.();\n        }\n      };\n\n      const onVolumeChange = () => {\n        const currentVolume = media.muted ? 0 : media.volume;\n        if (\n          media.muted &&\n          !store.getState().media.isMuted &&\n          media.volume > 0\n        ) {\n          previousVolumeRef.current = media.volume;\n        }\n        store.dispatch({ variant: \"SET_VOLUME\", volume: currentVolume });\n        store.dispatch({ variant: \"SET_MUTED\", isMuted: media.muted });\n        propsRef.current.onVolumeChange?.(media.volume);\n        propsRef.current.onMuted?.(media.muted);\n      };\n\n      const onFullscreenChange = () => {\n        const isFullscreen = !!document.fullscreenElement;\n        store.dispatch({\n          variant: \"SET_FULLSCREEN\",\n          isFullscreen: isFullscreen,\n        });\n        propsRef.current.onFullscreenChange?.(isFullscreen);\n      };\n\n      const onEnteredPiP = () => {\n        store.dispatch({\n          variant: \"SET_PICTURE_IN_PICTURE\",\n          isPictureInPicture: true,\n        });\n      };\n\n      const onExitedPiP = () => {\n        store.dispatch({\n          variant: \"SET_PICTURE_IN_PICTURE\",\n          isPictureInPicture: false,\n        });\n      };\n\n      const onRateChange = () => {\n        store.dispatch({\n          variant: \"SET_PLAYBACK_RATE\",\n          playbackRate: media.playbackRate,\n        });\n      };\n\n      media.addEventListener(\"timeupdate\", onTimeUpdate);\n      media.addEventListener(\"durationchange\", onDurationChange);\n      media.addEventListener(\"progress\", onProgress);\n      media.addEventListener(\"play\", onPlay);\n      media.addEventListener(\"pause\", onPause);\n      media.addEventListener(\"ended\", onEnded);\n      media.addEventListener(\"volumechange\", onVolumeChange);\n      media.addEventListener(\"ratechange\", onRateChange);\n      media.addEventListener(\"seeked\", onSeeked);\n      document.addEventListener(\"fullscreenchange\", onFullscreenChange);\n\n      if (media instanceof HTMLVideoElement) {\n        media.addEventListener(\"enterpictureinpicture\", onEnteredPiP);\n        media.addEventListener(\"leavepictureinpicture\", onExitedPiP);\n      }\n\n      if (media.volume !== store.getState().media.volume) {\n        store.dispatch({ variant: \"SET_VOLUME\", volume: media.volume });\n      }\n\n      if (media.muted !== store.getState().media.isMuted) {\n        store.dispatch({ variant: \"SET_MUTED\", isMuted: media.muted });\n      }\n\n      return () => {\n        media.removeEventListener(\"timeupdate\", onTimeUpdate);\n        media.removeEventListener(\"durationchange\", onDurationChange);\n        media.removeEventListener(\"progress\", onProgress);\n        media.removeEventListener(\"play\", onPlay);\n        media.removeEventListener(\"pause\", onPause);\n        media.removeEventListener(\"ended\", onEnded);\n        media.removeEventListener(\"volumechange\", onVolumeChange);\n        media.removeEventListener(\"ratechange\", onRateChange);\n        media.removeEventListener(\"seeked\", onSeeked);\n        document.removeEventListener(\"fullscreenchange\", onFullscreenChange);\n\n        if (media instanceof HTMLVideoElement) {\n          media.removeEventListener(\"enterpictureinpicture\", onEnteredPiP);\n          media.removeEventListener(\"leavepictureinpicture\", onExitedPiP);\n        }\n      };\n    }, [\n      store,\n      propsRef.current.defaultVolume,\n      propsRef.current.onVolumeChange,\n      propsRef.current.onTimeUpdate,\n      propsRef.current.onMuted,\n      propsRef.current.onPlay,\n      propsRef.current.onPause,\n      propsRef.current.onEnded,\n      propsRef.current.onFullscreenChange,\n    ]);\n\n    const RootPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <StoreContext.Provider value={store}>\n        <MediaPlayerContext.Provider value={contextValue}>\n          <RootPrimitive\n            aria-labelledby={labelId}\n            aria-describedby={descriptionId}\n            aria-disabled={disabled}\n            data-disabled={disabled ? \"\" : undefined}\n            data-slot=\"media-player\"\n            dir={dir}\n            tabIndex={disabled ? undefined : 0}\n            onKeyDown={onKeyDown}\n            {...rootProps}\n            ref={forwardedRef}\n            className={cn(\n              \"relative isolate flex flex-col overflow-hidden rounded-lg bg-background outline-none focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n              \"[:fullscreen_&]:flex [:fullscreen_&]:h-full [:fullscreen_&]:max-h-screen [:fullscreen_&]:flex-col [:fullscreen_&]:justify-between\",\n              \"[&_[data-slider]::before]:-top-6 [&_[data-slider]::before]:-bottom-2 [&_[data-slider]::before]:absolute [&_[data-slider]::before]:inset-x-0 [&_[data-slider]::before]:z-10 [&_[data-slider]::before]:h-12 [&_[data-slider]::before]:cursor-pointer [&_[data-slider]::before]:content-[''] [&_[data-slider]]:relative\",\n              className,\n            )}\n          >\n            <span id={labelId} className=\"sr-only\">\n              {label ?? \"Media player\"}\n            </span>\n            {children}\n          </RootPrimitive>\n        </MediaPlayerContext.Provider>\n      </StoreContext.Provider>\n    );\n  },\n);\nMediaPlayerRoot.displayName = ROOT_NAME;\n\ninterface MediaPlayerVideoProps\n  extends React.ComponentPropsWithoutRef<\"video\"> {\n  asChild?: boolean;\n}\n\nconst MediaPlayerVideo = React.forwardRef<\n  HTMLVideoElement,\n  MediaPlayerVideoProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, ...videoProps } = props;\n\n  const context = useMediaPlayerContext(VIDEO_NAME);\n  const loopMode = useStore((state) => state.media.loopMode);\n  const composedRef = useComposedRefs(forwardedRef, context.mediaRef);\n\n  const onPlayToggle = React.useCallback(\n    (event: React.MouseEvent<HTMLVideoElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      if (media.paused) {\n        media.play();\n      } else {\n        media.pause();\n      }\n    },\n    [context.mediaRef, props.onClick],\n  );\n\n  const VideoPrimitive = asChild ? Slot : \"video\";\n\n  return (\n    <VideoPrimitive\n      aria-labelledby={context.labelId}\n      aria-describedby={context.descriptionId}\n      data-slot=\"media-player-video\"\n      controlsList=\"nodownload noremoteplayback\"\n      {...videoProps}\n      ref={composedRef}\n      id={context.mediaId}\n      loop={loopMode === \"all\"}\n      playsInline\n      preload=\"metadata\"\n      className={cn(\"h-full w-full cursor-pointer\", className)}\n      onClick={onPlayToggle}\n    >\n      {children}\n      <span id={context.descriptionId} className=\"sr-only\">\n        Video player with custom controls for playback, volume, seeking, and\n        more. Use space bar to play/pause, arrow keys (←/→) to seek, and arrow\n        keys (↑/↓) to adjust volume.\n      </span>\n    </VideoPrimitive>\n  );\n});\nMediaPlayerVideo.displayName = VIDEO_NAME;\n\ninterface MediaPlayerAudioProps\n  extends React.ComponentPropsWithoutRef<\"audio\"> {\n  asChild?: boolean;\n}\n\nconst MediaPlayerAudio = React.forwardRef<\n  HTMLAudioElement,\n  MediaPlayerAudioProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, ...audioProps } = props;\n\n  const context = useMediaPlayerContext(AUDIO_NAME);\n  const loopMode = useStore((state) => state.media.loopMode);\n  const composedRef = useComposedRefs(forwardedRef, context.mediaRef);\n\n  const AudioPrimitive = asChild ? Slot : \"audio\";\n\n  return (\n    <AudioPrimitive\n      aria-labelledby={context.labelId}\n      aria-describedby={context.descriptionId}\n      data-slot=\"media-player-audio\"\n      {...audioProps}\n      ref={composedRef}\n      id={context.mediaId}\n      loop={loopMode === \"all\"}\n      preload=\"metadata\"\n      className={cn(\"w-full\", className)}\n    >\n      {children}\n      <span id={context.descriptionId} className=\"sr-only\">\n        Audio player with custom controls for playback, volume, seeking, and\n        more. Use space bar to play/pause, Shift + arrow keys (←/→) to seek, and\n        arrow keys (↑/↓) to adjust volume.\n      </span>\n    </AudioPrimitive>\n  );\n});\nMediaPlayerAudio.displayName = AUDIO_NAME;\n\ninterface MediaPlayerControlsProps\n  extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst MediaPlayerControls = React.forwardRef<\n  HTMLDivElement,\n  MediaPlayerControlsProps\n>((props, forwardedRef) => {\n  const { asChild, className, ...controlsProps } = props;\n\n  const context = useMediaPlayerContext(CONTROLS_NAME);\n  const isFullscreen = useStore((state) => state.media.isFullscreen);\n\n  const ControlsPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ControlsPrimitive\n      role=\"group\"\n      aria-label=\"Media controls\"\n      data-disabled={context.disabled ? \"\" : undefined}\n      data-slot=\"media-player-controls\"\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\n      dir={context.dir}\n      ref={forwardedRef}\n      className={cn(\n        \"dark absolute right-0 bottom-0 left-0 z-50 flex items-center gap-2 px-4 py-3\",\n        \"[:fullscreen_&]:absolute [:fullscreen_&]:right-0 [:fullscreen_&]:bottom-0 [:fullscreen_&]:left-0 [:fullscreen_&]:z-50 [:fullscreen_&]:px-6 [:fullscreen_&]:py-4\",\n        className,\n      )}\n      {...controlsProps}\n    />\n  );\n});\nMediaPlayerControls.displayName = CONTROLS_NAME;\n\ninterface MediaPlayerOverlayProps\n  extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst MediaPlayerOverlay = React.forwardRef<\n  HTMLDivElement,\n  MediaPlayerOverlayProps\n>((props, forwardedRef) => {\n  const { asChild, className, ...overlayProps } = props;\n\n  const isFullscreen = useStore((state) => state.media.isFullscreen);\n\n  const OverlayPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <OverlayPrimitive\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\n      data-slot=\"media-player-overlay\"\n      {...overlayProps}\n      ref={forwardedRef}\n      className={cn(\n        \"-z-10 absolute inset-0 bg-gradient-to-t from-black/80 to-transparent\",\n        className,\n      )}\n    />\n  );\n});\nMediaPlayerOverlay.displayName = OVERLAY_NAME;\n\ninterface MediaPlayerPlayProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\n\nconst MediaPlayerPlay = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerPlayProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, disabled, ...playButtonProps } = props;\n\n  const context = useMediaPlayerContext(PLAY_NAME);\n  const isPlaying = useStore((state) => state.media.isPlaying);\n\n  const isDisabled = disabled || context.disabled;\n\n  const onPlayToggle = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      if (isPlaying) {\n        media.pause();\n      } else {\n        media.play();\n      }\n    },\n    [context.mediaRef, props.onClick, isPlaying],\n  );\n\n  return (\n    <MediaPlayerTooltip tooltip={isPlaying ? \"Pause\" : \"Play\"} shortcut=\"Space\">\n      <Button\n        type=\"button\"\n        aria-label={isPlaying ? \"Pause\" : \"Play\"}\n        aria-pressed={isPlaying}\n        aria-controls={context.mediaId}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-state={isPlaying ? \"playing\" : \"paused\"}\n        data-slot=\"media-player-play-button\"\n        disabled={isDisabled}\n        {...playButtonProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\n          \"size-8 [&_svg:not([class*='fill-'])]:fill-current\",\n          className,\n        )}\n        onClick={onPlayToggle}\n      >\n        {children ?? (isPlaying ? <PauseIcon /> : <PlayIcon />)}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerPlay.displayName = PLAY_NAME;\n\ninterface MediaPlayerSeekBackwardProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {\n  seconds?: number;\n}\n\nconst MediaPlayerSeekBackward = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerSeekBackwardProps\n>((props, forwardedRef) => {\n  const {\n    asChild,\n    children,\n    className,\n    seconds = SEEK_AMOUNT_SHORT,\n    ...seekBackwardProps\n  } = props;\n\n  const context = useMediaPlayerContext(SEEK_BACKWARD_NAME);\n  const isDisabled = props.disabled || context.disabled;\n\n  const isVideo = getIsVideo(context.mediaRef);\n\n  const onSeekBackward = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      media.currentTime = Math.max(0, media.currentTime - seconds);\n    },\n    [context.mediaRef, props.onClick, seconds],\n  );\n\n  return (\n    <MediaPlayerTooltip\n      tooltip={`Back ${seconds}s`}\n      shortcut={isVideo ? [\"←\"] : [\"Shift ←\"]}\n    >\n      <Button\n        type=\"button\"\n        aria-label={`Back ${seconds} seconds`}\n        aria-controls={context.mediaId}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-slot=\"media-player-seek-backward\"\n        disabled={isDisabled}\n        {...seekBackwardProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\"size-8\", className)}\n        onClick={onSeekBackward}\n      >\n        {children ?? <RewindIcon />}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerSeekBackward.displayName = SEEK_BACKWARD_NAME;\n\ninterface MediaPlayerSeekForwardProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {\n  seconds?: number;\n}\n\nconst MediaPlayerSeekForward = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerSeekForwardProps\n>((props, forwardedRef) => {\n  const {\n    asChild,\n    children,\n    className,\n    seconds = SEEK_AMOUNT_LONG,\n    ...seekForwardProps\n  } = props;\n\n  const context = useMediaPlayerContext(SEEK_FORWARD_NAME);\n  const isDisabled = props.disabled || context.disabled;\n\n  const isVideo = getIsVideo(context.mediaRef);\n\n  const onSeekForward = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      media.currentTime = Math.min(media.duration, media.currentTime + seconds);\n    },\n    [context.mediaRef, props.onClick, seconds],\n  );\n\n  return (\n    <MediaPlayerTooltip\n      tooltip={`Forward ${seconds}s`}\n      shortcut={isVideo ? [\"→\"] : [\"Shift →\"]}\n    >\n      <Button\n        type=\"button\"\n        aria-label={`Forward ${seconds} seconds`}\n        aria-controls={context.mediaId}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-slot=\"media-player-seek-forward\"\n        disabled={isDisabled}\n        {...seekForwardProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\"size-8\", className)}\n        onClick={onSeekForward}\n      >\n        {children ?? <FastForwardIcon />}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerSeekForward.displayName = SEEK_FORWARD_NAME;\n\ninterface MediaPlayerSeekProps\n  extends React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root> {\n  withTime?: boolean;\n}\n\nconst MediaPlayerSeek = React.forwardRef<HTMLDivElement, MediaPlayerSeekProps>(\n  (props, forwardedRef) => {\n    const {\n      asChild,\n      withTime = false,\n      className,\n      disabled,\n      ...seekProps\n    } = props;\n\n    const context = useMediaPlayerContext(SEEK_NAME);\n    const store = useStoreContext(SEEK_NAME);\n    const currentTime = useStore((state) => state.media.currentTime);\n    const duration = useStore((state) => state.media.duration);\n    const buffered = useStore((state) => state.media.buffered);\n\n    const seekRef = React.useRef<HTMLDivElement>(null);\n    const tooltipRef = React.useRef<HTMLDivElement>(null);\n    const composedRef = useComposedRefs(forwardedRef, seekRef);\n\n    const [tooltipPositionX, setTooltipPositionX] = React.useState(0);\n    const [isHoveringSeek, setIsHoveringSeek] = React.useState(false);\n    const [hoverTime, setHoverTime] = React.useState(0);\n\n    const formattedCurrentTime = formatTime(currentTime);\n    const formattedDuration = formatTime(duration);\n    const formattedHoverTime = formatTime(hoverTime);\n    const formattedRemainingTime = formatTime(duration - currentTime);\n\n    const isDisabled = disabled || context.disabled;\n\n    const pointerMoveThrottleTimeoutRef = React.useRef<NodeJS.Timeout | null>(\n      null,\n    );\n    const seekThrottleTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);\n    const latestSeekValueRef = React.useRef<number | null>(null);\n\n    const onPointerEnter = React.useCallback(() => {\n      if (duration > 0) {\n        setIsHoveringSeek(true);\n      }\n    }, [duration]);\n\n    const onPointerLeave = React.useCallback(() => {\n      if (pointerMoveThrottleTimeoutRef.current) {\n        clearTimeout(pointerMoveThrottleTimeoutRef.current);\n        pointerMoveThrottleTimeoutRef.current = null;\n      }\n      setIsHoveringSeek(false);\n    }, []);\n\n    const onPointerMove = React.useCallback(\n      (event: React.PointerEvent<HTMLDivElement>) => {\n        if (\n          !seekRef.current ||\n          duration <= 0 ||\n          pointerMoveThrottleTimeoutRef.current\n        ) {\n          return;\n        }\n\n        const rect = seekRef.current.getBoundingClientRect();\n        const offsetX = event.clientX - rect.left;\n        const clampedOffsetX = Math.max(0, Math.min(offsetX, rect.width));\n        const relativeX = clampedOffsetX / rect.width;\n        const calculatedHoverTime = relativeX * duration;\n\n        const tooltipWidth =\n          tooltipRef.current?.getBoundingClientRect().width ?? 0;\n        const centeredPosition = clampedOffsetX - tooltipWidth / 2;\n\n        setTooltipPositionX(centeredPosition);\n        setHoverTime(calculatedHoverTime);\n\n        pointerMoveThrottleTimeoutRef.current = setTimeout(() => {\n          pointerMoveThrottleTimeoutRef.current = null;\n        }, POINTER_MOVE_THROTTLE_MS);\n      },\n      [duration],\n    );\n\n    const onSeek = React.useCallback(\n      (value: number[]) => {\n        const media = context.mediaRef.current;\n        if (!media) return;\n\n        const time = value[0] ?? 0;\n        media.currentTime = time;\n        latestSeekValueRef.current = time;\n\n        if (!seekThrottleTimeoutRef.current) {\n          store.dispatch({ variant: \"SET_CURRENT_TIME\", currentTime: time });\n\n          seekThrottleTimeoutRef.current = setTimeout(() => {\n            seekThrottleTimeoutRef.current = null;\n            if (\n              latestSeekValueRef.current !== null &&\n              latestSeekValueRef.current !== time\n            ) {\n              store.dispatch({\n                variant: \"SET_CURRENT_TIME\",\n                currentTime: latestSeekValueRef.current,\n              });\n            }\n          }, SEEK_THROTTLE_MS);\n        }\n      },\n      [context.mediaRef, store],\n    );\n\n    const onSeekCommit = React.useCallback(\n      (value: number[]) => {\n        const media = context.mediaRef.current;\n        if (!media) return;\n\n        const time = value[0] ?? 0;\n        if (seekThrottleTimeoutRef.current) {\n          clearTimeout(seekThrottleTimeoutRef.current);\n          seekThrottleTimeoutRef.current = null;\n        }\n        store.dispatch({ variant: \"SET_CURRENT_TIME\", currentTime: time });\n        latestSeekValueRef.current = null;\n      },\n      [context.mediaRef, store],\n    );\n\n    const bufferedRanges = React.useMemo(() => {\n      if (!buffered || duration <= 0) return null;\n\n      return Array.from({ length: buffered.length }).map((_, i) => {\n        const start = buffered.start(i);\n        const end = buffered.end(i);\n        const startPercent = (start / duration) * 100;\n        const widthPercent = ((end - start) / duration) * 100;\n\n        return (\n          <div\n            key={i}\n            data-slot=\"media-player-seek-buffered\"\n            className=\"absolute h-full bg-zinc-400\"\n            style={{\n              left: `${startPercent}%`,\n              width: `${widthPercent}%`,\n            }}\n          />\n        );\n      });\n    }, [buffered, duration]);\n\n    const SeekSlider = (\n      <Tooltip delayDuration={100} open={isHoveringSeek}>\n        <TooltipTrigger asChild>\n          <SliderPrimitive.Root\n            aria-label=\"Seek time\"\n            aria-valuetext={`${formattedCurrentTime} of ${formattedDuration}`}\n            aria-controls={context.mediaId}\n            data-slider=\"\"\n            data-slot=\"media-player-seek\"\n            disabled={isDisabled}\n            {...seekProps}\n            ref={composedRef}\n            min={0}\n            max={duration}\n            step={0.1}\n            className={cn(\n              \"relative flex w-full touch-none select-none items-center data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n              className,\n            )}\n            value={[currentTime]}\n            onValueChange={onSeek}\n            onValueCommit={onSeekCommit}\n            onPointerMove={onPointerMove}\n          >\n            <SliderPrimitive.Track\n              aria-label=\"Video progress\"\n              className=\"relative h-1 w-full grow overflow-hidden rounded-full bg-zinc-500\"\n            >\n              {bufferedRanges}\n              <SliderPrimitive.Range\n                aria-label=\"Current progress\"\n                className=\"absolute h-full bg-primary\"\n              />\n            </SliderPrimitive.Track>\n            <SliderPrimitive.Thumb\n              aria-label=\"Seek thumb\"\n              className=\"relative z-10 block size-2.5 shrink-0 rounded-full bg-primary shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\"\n            />\n          </SliderPrimitive.Root>\n        </TooltipTrigger>\n        {duration > 0 && (\n          <TooltipContent\n            ref={tooltipRef}\n            side=\"top\"\n            align=\"start\"\n            alignOffset={tooltipPositionX}\n            sideOffset={10}\n            className=\"pointer-events-none border bg-accent text-accent-foreground dark:bg-zinc-900 [&>span]:hidden\"\n            role=\"tooltip\"\n          >\n            {formattedHoverTime} / {formattedDuration}\n          </TooltipContent>\n        )}\n      </Tooltip>\n    );\n\n    const SeekWrapper = (\n      <div\n        role=\"presentation\"\n        data-slot=\"media-player-seek-wrapper\"\n        className={cn(\"relative w-full\", className)}\n        onPointerEnter={onPointerEnter}\n        onPointerLeave={onPointerLeave}\n      >\n        {SeekSlider}\n      </div>\n    );\n\n    if (withTime) {\n      return (\n        <div\n          role=\"group\"\n          aria-label=\"Video progress\"\n          className=\"flex w-full items-center gap-2\"\n        >\n          <span aria-label=\"Current time\" className=\"text-sm\">\n            {formattedCurrentTime}\n          </span>\n          {SeekWrapper}\n          <span aria-label=\"Remaining time\" className=\"text-sm\">\n            {formattedRemainingTime}\n          </span>\n        </div>\n      );\n    }\n\n    return SeekWrapper;\n  },\n);\nMediaPlayerSeek.displayName = SEEK_NAME;\n\ninterface MediaPlayerVolumeProps\n  extends React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root> {\n  asChild?: boolean;\n  expandable?: boolean;\n}\n\nconst MediaPlayerVolume = React.forwardRef<\n  HTMLDivElement,\n  MediaPlayerVolumeProps\n>((props, forwardedRef) => {\n  const {\n    asChild,\n    expandable = false,\n    className,\n    disabled,\n    ...volumeProps\n  } = props;\n\n  const context = useMediaPlayerContext(VOLUME_NAME);\n  const store = useStoreContext(VOLUME_NAME);\n  const volume = useStore((state) => state.media.volume);\n  const isMuted = useStore((state) => state.media.isMuted);\n\n  const volumeTriggerId = React.useId();\n  const sliderId = React.useId();\n  const previousVolumeRef = React.useRef(volume);\n\n  const isDisabled = disabled || context.disabled;\n\n  const onVolumeChange = React.useCallback(\n    (value: number[]) => {\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      const volume = value[0] ?? 0;\n      media.volume = volume;\n      media.muted = volume === 0;\n      previousVolumeRef.current = volume;\n      store.dispatch({ variant: \"SET_VOLUME\", volume });\n      store.dispatch({ variant: \"SET_MUTED\", isMuted: volume === 0 });\n    },\n    [context.mediaRef, store],\n  );\n\n  const onMute = React.useCallback(() => {\n    const media = context.mediaRef.current;\n    if (!media) return;\n\n    if (!isMuted) {\n      if (volume > 0) {\n        previousVolumeRef.current = volume;\n      }\n      media.muted = true;\n    } else {\n      const restoredVolume =\n        previousVolumeRef.current > 0 ? previousVolumeRef.current : 1;\n      media.volume = restoredVolume;\n      media.muted = false;\n    }\n  }, [context.mediaRef, volume, isMuted]);\n\n  return (\n    <div\n      role=\"group\"\n      aria-label=\"Volume controls\"\n      data-disabled={isDisabled ? \"\" : undefined}\n      className={cn(\n        \"group flex items-center\",\n        expandable ? \"gap-0 group-hover:gap-2\" : \"gap-2\",\n        className,\n      )}\n    >\n      <MediaPlayerTooltip tooltip=\"Volume\" shortcut=\"M\">\n        <Button\n          id={volumeTriggerId}\n          type=\"button\"\n          aria-label={isMuted ? \"Unmute\" : \"Mute\"}\n          aria-pressed={isMuted}\n          aria-controls={`${context.mediaId} ${sliderId}`}\n          data-state={isMuted ? \"muted\" : \"unmuted\"}\n          data-slot=\"media-player-mute\"\n          variant=\"ghost\"\n          size=\"icon\"\n          className=\"size-8\"\n          disabled={isDisabled}\n          onClick={onMute}\n        >\n          {isMuted ? (\n            <VolumeXIcon />\n          ) : volume > 0.5 ? (\n            <Volume2Icon />\n          ) : (\n            <Volume1Icon />\n          )}\n        </Button>\n      </MediaPlayerTooltip>\n      <SliderPrimitive.Root\n        id={sliderId}\n        aria-label=\"Volume\"\n        aria-controls={context.mediaId}\n        aria-valuetext={`${Math.round(volume * 100)}% volume`}\n        data-slider=\"\"\n        data-slot=\"media-player-volume\"\n        {...volumeProps}\n        ref={forwardedRef}\n        min={0}\n        max={1}\n        step={0.1}\n        className={cn(\n          \"relative flex touch-none select-none items-center\",\n          expandable\n            ? \"w-0 opacity-0 transition-[width,opacity] duration-200 ease-in-out group-hover:w-16 group-hover:opacity-100\"\n            : \"w-16\",\n          className,\n        )}\n        disabled={isDisabled}\n        value={[volume]}\n        onValueChange={onVolumeChange}\n      >\n        <SliderPrimitive.Track\n          aria-label=\"Volume track\"\n          className=\"relative h-1 w-full grow overflow-hidden rounded-full bg-zinc-500\"\n        >\n          <SliderPrimitive.Range\n            aria-label=\"Current volume\"\n            className=\"absolute h-full bg-primary\"\n          />\n        </SliderPrimitive.Track>\n        <SliderPrimitive.Thumb\n          aria-label=\"Volume thumb\"\n          className=\"block size-2.5 shrink-0 rounded-full bg-primary shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\"\n        />\n      </SliderPrimitive.Root>\n    </div>\n  );\n});\nMediaPlayerVolume.displayName = VOLUME_NAME;\n\ninterface MediaPlayerTimeProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n  mode?: \"progress\" | \"remaining\" | \"duration\";\n}\n\nconst MediaPlayerTime = React.forwardRef<HTMLDivElement, MediaPlayerTimeProps>(\n  (props, forwardedRef) => {\n    const { asChild, className, mode = \"progress\", ...timeProps } = props;\n\n    const context = useMediaPlayerContext(TIME_NAME);\n    const currentTime = useStore((state) => state.media.currentTime);\n    const duration = useStore((state) => state.media.duration);\n\n    const formattedCurrentTime = formatTime(currentTime);\n    const formattedDuration = formatTime(duration);\n    const formattedRemainingTime = formatTime(duration - currentTime);\n\n    const TimePrimitive = asChild ? Slot : \"div\";\n\n    if (mode === \"remaining\" || mode === \"duration\") {\n      return (\n        <TimePrimitive\n          aria-label={mode === \"remaining\" ? \"Remaining time\" : \"Duration\"}\n          data-slot=\"media-player-time\"\n          dir={context.dir}\n          {...timeProps}\n          ref={forwardedRef}\n          className={cn(\"text-foreground/80 text-sm\", className)}\n        >\n          {mode === \"remaining\" ? formattedRemainingTime : formattedDuration}\n        </TimePrimitive>\n      );\n    }\n\n    return (\n      <TimePrimitive\n        aria-label=\"Time\"\n        data-slot=\"media-player-time\"\n        dir={context.dir}\n        {...timeProps}\n        ref={forwardedRef}\n        className={cn(\n          \"flex items-center gap-1 text-foreground/80 text-sm\",\n          className,\n        )}\n      >\n        <span aria-label=\"Current time\">{formattedCurrentTime}</span>\n        <span role=\"presentation\" aria-hidden=\"true\">\n          /\n        </span>\n        <span aria-label=\"Duration\">{formattedDuration}</span>\n      </TimePrimitive>\n    );\n  },\n);\nMediaPlayerTime.displayName = TIME_NAME;\n\ninterface MediaPlayerPlaybackSpeedProps\n  extends React.ComponentPropsWithoutRef<typeof SelectTrigger> {\n  speeds?: number[];\n}\n\nconst MediaPlayerPlaybackSpeed = React.forwardRef<\n  React.ComponentRef<typeof SelectTrigger>,\n  MediaPlayerPlaybackSpeedProps\n>((props, forwardedRef) => {\n  const {\n    asChild,\n    speeds = SPEEDS,\n    className,\n    disabled,\n    ...playbackSpeedProps\n  } = props;\n\n  const context = useMediaPlayerContext(PLAYBACK_SPEED_NAME);\n  const store = useStoreContext(PLAYBACK_SPEED_NAME);\n  const playbackRate = useStore((state) => state.media.playbackRate);\n\n  const isDisabled = disabled || context.disabled;\n\n  const onPlaybackRateChange = React.useCallback(\n    (value: string) => {\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      const rate = Number.parseFloat(value);\n      media.playbackRate = rate;\n      store.dispatch({ variant: \"SET_PLAYBACK_RATE\", playbackRate: rate });\n    },\n    [context.mediaRef, store],\n  );\n\n  return (\n    <Select\n      data-slot=\"media-player-playback-speed\"\n      value={playbackRate.toString()}\n      onValueChange={onPlaybackRateChange}\n    >\n      <MediaPlayerTooltip tooltip=\"Playback speed\" shortcut={[\"<\", \">\"]}>\n        <SelectTrigger\n          aria-controls={context.mediaId}\n          disabled={isDisabled}\n          {...playbackSpeedProps}\n          ref={forwardedRef}\n          className={cn(\n            \"h-8 w-16 justify-center border-none aria-expanded:bg-accent aria-[expanded=true]:bg-accent/50 dark:bg-transparent dark:aria-[expanded=true]:bg-accent/50 dark:hover:bg-accent/50 [&[data-size]]:h-8 [&_svg]:hidden\",\n            className,\n          )}\n        >\n          <SelectValue>{playbackRate}x</SelectValue>\n        </SelectTrigger>\n      </MediaPlayerTooltip>\n      <SelectContent\n        align=\"center\"\n        className=\"min-w-[var(--radix-select-trigger-width)]\"\n      >\n        {speeds.map((speed) => (\n          <SelectItem key={speed} value={speed.toString()}>\n            {speed}x\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  );\n});\nMediaPlayerPlaybackSpeed.displayName = PLAYBACK_SPEED_NAME;\n\ninterface MediaPlayerLoopProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {\n  mode?: \"toggle\" | \"repeat\";\n}\n\nconst MediaPlayerLoop = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerLoopProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, mode = \"toggle\", ...loopProps } = props;\n\n  const context = useMediaPlayerContext(LOOP_NAME);\n  const store = useStoreContext(LOOP_NAME);\n  const loopMode = useStore((state) => state.media.loopMode);\n  const isDisabled = props.disabled || context.disabled;\n\n  const onLoopToggle = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      let nextLoopMode: LoopMode = \"off\";\n\n      if (mode === \"toggle\") {\n        if (loopMode === \"off\") {\n          nextLoopMode = \"all\";\n        } else {\n          nextLoopMode = \"off\";\n        }\n      } else {\n        if (loopMode === \"off\") {\n          nextLoopMode = \"all\";\n        } else if (loopMode === \"all\") {\n          nextLoopMode = \"one\";\n        } else {\n          nextLoopMode = \"off\";\n        }\n      }\n\n      media.loop = nextLoopMode === \"all\";\n      store.dispatch({ variant: \"SET_LOOP_MODE\", loopMode: nextLoopMode });\n    },\n    [context.mediaRef, props.onClick, store, loopMode, mode],\n  );\n\n  const getTooltipText = React.useCallback(() => {\n    if (mode === \"toggle\") {\n      return loopMode === \"all\" ? \"Disable loop\" : \"Enable loop\";\n    }\n    if (loopMode === \"off\") return \"Repeat all\";\n    if (loopMode === \"all\") return \"Repeat one\";\n    return \"Disable repeat\";\n  }, [loopMode, mode]);\n\n  const getAriaLabel = React.useCallback(() => {\n    if (mode === \"toggle\") {\n      return loopMode === \"all\" ? \"Disable loop\" : \"Enable loop\";\n    }\n    if (loopMode === \"off\") return \"Enable repeat all\";\n    if (loopMode === \"all\") return \"Enable repeat one\";\n    return \"Disable repeat\";\n  }, [loopMode, mode]);\n\n  const LoopIcon = React.useCallback(() => {\n    if (loopMode === \"one\") return <Repeat1Icon />;\n    return (\n      <RepeatIcon className={cn(loopMode === \"off\" && \"text-foreground/60\")} />\n    );\n  }, [loopMode]);\n\n  return (\n    <MediaPlayerTooltip tooltip={getTooltipText()} shortcut=\"R\">\n      <Button\n        type=\"button\"\n        aria-label={getAriaLabel()}\n        aria-controls={context.mediaId}\n        aria-pressed={loopMode !== \"off\"}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-state={loopMode}\n        data-slot=\"media-player-loop\"\n        disabled={isDisabled}\n        {...loopProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\"size-8\", className)}\n        onClick={onLoopToggle}\n      >\n        {children ?? <LoopIcon />}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerLoop.displayName = LOOP_NAME;\n\ninterface MediaPlayerFullscreenProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\n\nconst MediaPlayerFullscreen = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerFullscreenProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, disabled, ...fullscreenProps } = props;\n\n  const context = useMediaPlayerContext(FULLSCREEN_NAME);\n  const store = useStoreContext(FULLSCREEN_NAME);\n  const isFullscreen = useStore((state) => state.media.isFullscreen);\n\n  const isDisabled = disabled || context.disabled;\n\n  const onFullscreen = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      if (!document.fullscreenElement) {\n        const container = media.closest('[data-slot=\"media-player\"]');\n        if (container) {\n          container.requestFullscreen();\n        } else {\n          media.requestFullscreen();\n        }\n        store.dispatch({ variant: \"SET_FULLSCREEN\", isFullscreen: true });\n      } else {\n        document.exitFullscreen();\n        store.dispatch({ variant: \"SET_FULLSCREEN\", isFullscreen: false });\n      }\n    },\n    [context.mediaRef, props.onClick, store],\n  );\n\n  return (\n    <MediaPlayerTooltip tooltip=\"Fullscreen\" shortcut=\"F\">\n      <Button\n        type=\"button\"\n        aria-label={isFullscreen ? \"Exit fullscreen\" : \"Enter fullscreen\"}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\n        data-slot=\"media-player-fullscreen\"\n        disabled={isDisabled}\n        {...fullscreenProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\"size-8\", className)}\n        onClick={onFullscreen}\n      >\n        {children ?? (isFullscreen ? <Minimize2Icon /> : <Maximize2Icon />)}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerFullscreen.displayName = FULLSCREEN_NAME;\n\ninterface MediaPlayerPiPProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {\n  onPipError?: (error: unknown, mode: \"enter\" | \"exit\") => void;\n}\n\nconst MediaPlayerPiP = React.forwardRef<HTMLButtonElement, MediaPlayerPiPProps>(\n  (props, forwardedRef) => {\n    const {\n      asChild,\n      children,\n      className,\n      onPipError,\n      disabled,\n      ...pipButtonProps\n    } = props;\n\n    const context = useMediaPlayerContext(PIP_NAME);\n    const isPictureInPicture = useStore(\n      (state) => state.media.isPictureInPicture,\n    );\n\n    const isDisabled = disabled || context.disabled;\n\n    const onPictureInPicture = React.useCallback(\n      (event: React.MouseEvent<HTMLButtonElement>) => {\n        props.onClick?.(event);\n\n        if (event.defaultPrevented) return;\n\n        const media = context.mediaRef.current;\n        if (!media || !(media instanceof HTMLVideoElement)) return;\n\n        if (document.pictureInPictureElement === media) {\n          document.exitPictureInPicture().catch((error) => {\n            onPipError?.(error, \"exit\");\n          });\n        } else {\n          media.requestPictureInPicture().catch((error) => {\n            onPipError?.(error, \"enter\");\n          });\n        }\n      },\n      [context.mediaRef, props.onClick, onPipError],\n    );\n\n    return (\n      <MediaPlayerTooltip tooltip=\"Picture in picture\" shortcut=\"P\">\n        <Button\n          type=\"button\"\n          aria-label={isPictureInPicture ? \"Exit pip\" : \"Enter pip\"}\n          data-disabled={isDisabled ? \"\" : undefined}\n          data-state={isPictureInPicture ? \"pip\" : \"inline\"}\n          data-slot=\"media-player-pip\"\n          disabled={isDisabled}\n          {...pipButtonProps}\n          ref={forwardedRef}\n          variant=\"ghost\"\n          size=\"icon\"\n          className={cn(\"size-8\", className)}\n          onClick={onPictureInPicture}\n        >\n          {isPictureInPicture ? (\n            <PictureInPicture2Icon />\n          ) : (\n            <PictureInPictureIcon />\n          )}\n        </Button>\n      </MediaPlayerTooltip>\n    );\n  },\n);\nMediaPlayerPiP.displayName = PIP_NAME;\n\ninterface MediaPlayerCaptionsProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\n\nconst MediaPlayerCaptions = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerCaptionsProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, disabled, ...captionsProps } = props;\n\n  const context = useMediaPlayerContext(CAPTIONS_NAME);\n  const store = useStoreContext(CAPTIONS_NAME);\n  const captionsEnabled = useStore((state) => state.media.captionsEnabled);\n\n  const isDisabled = disabled || context.disabled;\n\n  const onToggleCaptions = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n      const media = context.mediaRef.current;\n      if (!media) return;\n\n      if (media instanceof HTMLVideoElement && media.textTracks.length > 0) {\n        for (let i = 0; i < media.textTracks.length; i++) {\n          const track = media.textTracks[i];\n          if (\n            track &&\n            (track.kind === \"captions\" || track.kind === \"subtitles\")\n          ) {\n            track.mode = captionsEnabled ? \"hidden\" : \"showing\";\n          }\n        }\n      }\n\n      store.dispatch({\n        variant: \"SET_CAPTIONS_ENABLED\",\n        captionsEnabled: !captionsEnabled,\n      });\n    },\n    [context.mediaRef, props.onClick, store, captionsEnabled],\n  );\n\n  return (\n    <MediaPlayerTooltip tooltip=\"Captions\" shortcut=\"C\">\n      <Button\n        type=\"button\"\n        aria-label={captionsEnabled ? \"Disable captions\" : \"Enable captions\"}\n        aria-controls={context.mediaId}\n        aria-pressed={captionsEnabled}\n        data-state={captionsEnabled ? \"active\" : \"inactive\"}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-slot=\"media-player-captions\"\n        disabled={isDisabled}\n        {...captionsProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\"size-8\", className)}\n        onClick={onToggleCaptions}\n      >\n        {children ??\n          (captionsEnabled ? <SubtitlesIcon /> : <CaptionsOffIcon />)}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerCaptions.displayName = CAPTIONS_NAME;\n\ninterface MediaPlayerDownloadProps\n  extends React.ComponentPropsWithoutRef<typeof Button> {}\n\nconst MediaPlayerDownload = React.forwardRef<\n  HTMLButtonElement,\n  MediaPlayerDownloadProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, disabled, ...downloadProps } = props;\n\n  const context = useMediaPlayerContext(DOWNLOAD_NAME);\n  const mediaUrl = context.mediaRef.current?.currentSrc;\n\n  const isDisabled = disabled || context.disabled;\n\n  const onDownload = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      props.onClick?.(event);\n\n      if (event.defaultPrevented) return;\n\n      const media = context.mediaRef.current;\n      if (!media || !mediaUrl) return;\n\n      const link = document.createElement(\"a\");\n      link.href = mediaUrl;\n      link.download = \"\";\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    },\n    [context.mediaRef, mediaUrl, props.onClick],\n  );\n\n  return (\n    <MediaPlayerTooltip tooltip=\"Download\" shortcut=\"D\">\n      <Button\n        type=\"button\"\n        aria-label=\"Download\"\n        aria-controls={context.mediaId}\n        data-disabled={isDisabled ? \"\" : undefined}\n        data-slot=\"media-player-download\"\n        disabled={isDisabled}\n        {...downloadProps}\n        ref={forwardedRef}\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn(\"size-8\", className)}\n        onClick={onDownload}\n      >\n        {children ?? <DownloadIcon />}\n      </Button>\n    </MediaPlayerTooltip>\n  );\n});\nMediaPlayerDownload.displayName = DOWNLOAD_NAME;\n\ninterface MediaPlayerTooltipProps\n  extends React.ComponentPropsWithoutRef<typeof Tooltip> {\n  tooltip?: string;\n  shortcut?: string | string[];\n}\n\nfunction MediaPlayerTooltip({\n  tooltip,\n  shortcut,\n  children,\n  ...props\n}: MediaPlayerTooltipProps) {\n  if (!tooltip && !shortcut) return <>{children}</>;\n\n  return (\n    <Tooltip {...props} delayDuration={600}>\n      <TooltipTrigger\n        className=\"text-foreground focus-visible:ring-ring/80\"\n        asChild\n      >\n        {children}\n      </TooltipTrigger>\n      <TooltipContent\n        sideOffset={10}\n        className=\"flex items-center gap-2 border bg-accent px-2 py-1 font-medium text-foreground dark:bg-zinc-900 [&>span]:hidden\"\n      >\n        <p>{tooltip}</p>\n        {Array.isArray(shortcut) ? (\n          <div className=\"flex items-center gap-1\">\n            {shortcut.map((shortcutKey) => (\n              <kbd\n                key={shortcutKey}\n                className=\"select-none rounded border bg-secondary px-1.5 py-0.5 font-mono text-[0.7rem] text-foreground shadow-xs\"\n              >\n                <abbr title={shortcutKey} className=\"no-underline\">\n                  {shortcutKey}\n                </abbr>\n              </kbd>\n            ))}\n          </div>\n        ) : (\n          <kbd\n            key={shortcut}\n            className=\"select-none rounded border bg-secondary px-1.5 py-px font-mono text-[0.7rem] text-foreground shadow-xs\"\n          >\n            <abbr title={shortcut} className=\"no-underline\">\n              {shortcut}\n            </abbr>\n          </kbd>\n        )}\n      </TooltipContent>\n    </Tooltip>\n  );\n}\n\nconst MediaPlayer = MediaPlayerRoot;\nconst Root = MediaPlayerRoot;\nconst Controls = MediaPlayerControls;\nconst Overlay = MediaPlayerOverlay;\nconst Play = MediaPlayerPlay;\nconst SeekForward = MediaPlayerSeekForward;\nconst SeekBackward = MediaPlayerSeekBackward;\nconst Seek = MediaPlayerSeek;\nconst Volume = MediaPlayerVolume;\nconst Time = MediaPlayerTime;\nconst Fullscreen = MediaPlayerFullscreen;\nconst PiP = MediaPlayerPiP;\nconst Video = MediaPlayerVideo;\nconst Audio = MediaPlayerAudio;\nconst PlaybackSpeed = MediaPlayerPlaybackSpeed;\nconst Captions = MediaPlayerCaptions;\nconst Download = MediaPlayerDownload;\nconst Loop = MediaPlayerLoop;\n\nexport {\n  MediaPlayer,\n  MediaPlayerVideo,\n  MediaPlayerAudio,\n  MediaPlayerControls,\n  MediaPlayerOverlay,\n  MediaPlayerPlay,\n  MediaPlayerSeekBackward,\n  MediaPlayerSeekForward,\n  MediaPlayerSeek,\n  MediaPlayerVolume,\n  MediaPlayerTime,\n  MediaPlayerPlaybackSpeed,\n  MediaPlayerLoop,\n  MediaPlayerFullscreen,\n  MediaPlayerPiP,\n  MediaPlayerCaptions,\n  MediaPlayerDownload,\n  //\n  Root,\n  Video,\n  Audio,\n  Controls,\n  Overlay,\n  Play,\n  SeekBackward,\n  SeekForward,\n  Seek,\n  Volume,\n  Time,\n  PlaybackSpeed,\n  Loop,\n  Fullscreen,\n  PiP,\n  Captions,\n  Download,\n  //\n  useStore as useMediaPlayer,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/composition.ts",
      "content": "import * as React from \"react\";\n\n/**\n * A utility to compose multiple event handlers into a single event handler.\n * Run originalEventHandler first, then ourEventHandler unless prevented.\n */\nfunction composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {},\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (\n      checkForDefaultPrevented === false ||\n      !(event as unknown as Event).defaultPrevented\n    ) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value.\n * This utility takes care of different types of refs: callback refs and RefObject(s).\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together.\n * Accepts callback refs and RefObject(s).\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs.\n * Accepts callback refs and RefObject(s).\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeEventHandlers, composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}