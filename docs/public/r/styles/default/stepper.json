{
  "name": "stepper",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "class-variance-authority",
    "lucide-react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/stepper.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport { Check } from \"lucide-react\";\nimport * as React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\n\nconst ROOT_NAME = \"Stepper\";\nconst LIST_NAME = \"StepperList\";\nconst ITEM_NAME = \"StepperItem\";\nconst ITEM_TRIGGER_NAME = \"StepperItemTrigger\";\nconst ITEM_INDICATOR_NAME = \"StepperItemIndicator\";\nconst ITEM_SEPARATOR_NAME = \"StepperItemSeparator\";\nconst ITEM_TITLE_NAME = \"StepperItemTitle\";\nconst ITEM_DESCRIPTION_NAME = \"StepperItemDescription\";\nconst CONTENT_NAME = \"StepperContent\";\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\ntype Direction = \"ltr\" | \"rtl\";\n\ninterface StepState {\n  value: string;\n  completed: boolean;\n  disabled: boolean;\n}\n\ninterface StoreState {\n  steps: Map<string, StepState>;\n  currentValue?: string;\n  orientation: \"horizontal\" | \"vertical\";\n  disabled: boolean;\n  clickable: boolean;\n}\n\ntype StoreAction =\n  | { type: \"ADD_STEP\"; value: string; completed?: boolean; disabled?: boolean }\n  | { type: \"SET_CURRENT\"; value: string }\n  | { type: \"SET_COMPLETED\"; value: string; completed: boolean }\n  | { type: \"SET_DISABLED\"; value: string; disabled: boolean }\n  | { type: \"SET_GLOBAL_DISABLED\"; disabled: boolean }\n  | { type: \"REMOVE_STEP\"; value: string };\n\nfunction createStore(\n  listeners: Set<() => void>,\n  steps: Map<string, StepState>,\n  orientation: \"horizontal\" | \"vertical\",\n  disabled: boolean,\n  clickable: boolean,\n) {\n  let state: StoreState = {\n    steps,\n    currentValue: undefined,\n    orientation,\n    disabled,\n    clickable,\n  };\n\n  let onValueChange: ((value: string) => void) | undefined;\n  let onValueComplete:\n    | ((value: string, completed: boolean) => void)\n    | undefined;\n\n  function reducer(state: StoreState, action: StoreAction): StoreState {\n    switch (action.type) {\n      case \"ADD_STEP\": {\n        const newStep: StepState = {\n          value: action.value,\n          completed: action.completed ?? false,\n          disabled: action.disabled ?? false,\n        };\n        steps.set(action.value, newStep);\n        return { ...state, steps };\n      }\n\n      case \"SET_CURRENT\": {\n        const newState = { ...state, currentValue: action.value };\n        onValueChange?.(action.value);\n        return newState;\n      }\n\n      case \"SET_COMPLETED\": {\n        const step = steps.get(action.value);\n        if (step) {\n          const newCompleted = action.completed;\n          steps.set(action.value, { ...step, completed: newCompleted });\n          onValueComplete?.(action.value, newCompleted);\n        }\n        return { ...state, steps };\n      }\n\n      case \"SET_DISABLED\": {\n        const step = steps.get(action.value);\n        if (step) {\n          steps.set(action.value, { ...step, disabled: action.disabled });\n        }\n        return { ...state, steps };\n      }\n\n      case \"SET_GLOBAL_DISABLED\": {\n        return { ...state, disabled: action.disabled };\n      }\n\n      case \"REMOVE_STEP\": {\n        steps.delete(action.value);\n        return { ...state, steps };\n      }\n\n      default:\n        return state;\n    }\n  }\n\n  function getState() {\n    return state;\n  }\n\n  function dispatch(action: StoreAction) {\n    state = reducer(state, action);\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n\n  function subscribe(listener: () => void) {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  }\n\n  function setCallbacks(\n    valueChange?: (value: string) => void,\n    valueComplete?: (value: string, completed: boolean) => void,\n  ) {\n    onValueChange = valueChange;\n    onValueComplete = valueComplete;\n  }\n\n  return { getState, dispatch, subscribe, setCallbacks };\n}\n\nconst StoreContext = React.createContext<ReturnType<typeof createStore> | null>(\n  null,\n);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const lastValueRef = useLazyRef<{ value: T; state: StoreState } | null>(\n    () => null,\n  );\n\n  const getSnapshot = React.useCallback(() => {\n    const state = store.getState();\n    const prevValue = lastValueRef.current;\n\n    if (prevValue && prevValue.state === state) {\n      return prevValue.value;\n    }\n\n    const nextValue = selector(state);\n    lastValueRef.current = { value: nextValue, state };\n    return nextValue;\n  }, [store, selector, lastValueRef]);\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface StepperContextValue {\n  disabled: boolean;\n  clickable: boolean;\n  dir: Direction;\n  onValueAdd?: (value: string) => void;\n  onValueRemove?: (value: string) => void;\n  listId: string;\n  labelId: string;\n}\n\nconst StepperContext = React.createContext<StepperContextValue | null>(null);\n\nfunction useStepperContext(consumerName: string) {\n  const context = React.useContext(StepperContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface StepperRootProps extends React.ComponentProps<\"div\"> {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  onValueComplete?: (value: string, completed: boolean) => void;\n  onValueAdd?: (value: string) => void;\n  onValueRemove?: (value: string) => void;\n  dir?: Direction;\n  orientation?: \"horizontal\" | \"vertical\";\n  disabled?: boolean;\n  clickable?: boolean;\n  name?: string;\n  asChild?: boolean;\n}\n\nfunction useDirection(dirProp?: Direction): Direction {\n  return dirProp ?? \"ltr\";\n}\n\nfunction StepperRoot(props: StepperRootProps) {\n  const listeners = useLazyRef(() => new Set<() => void>());\n  const steps = useLazyRef<Map<string, StepState>>(() => new Map());\n\n  const store = React.useMemo(\n    () =>\n      createStore(\n        listeners.current,\n        steps.current,\n        props.orientation ?? \"horizontal\",\n        props.disabled ?? false,\n        props.clickable ?? true,\n      ),\n    [listeners, steps, props.orientation, props.disabled, props.clickable],\n  );\n\n  return (\n    <StoreContext.Provider value={store}>\n      <StepperRootImpl {...props} />\n    </StoreContext.Provider>\n  );\n}\n\nfunction StepperRootImpl(props: StepperRootProps) {\n  const {\n    value: controlledValue,\n    defaultValue,\n    onValueChange: onValueChangeProp,\n    onValueComplete: onValueCompleteProp,\n    onValueAdd,\n    onValueRemove,\n    dir: dirProp,\n    orientation = \"horizontal\",\n    disabled = false,\n    clickable = true,\n    name,\n    className,\n    children,\n    ref,\n    ...rootProps\n  } = props;\n\n  const dir = useDirection(dirProp);\n  const store = useStoreContext(\"StepperImpl\");\n  const isControlled = controlledValue !== undefined;\n\n  const listId = React.useId();\n  const labelId = React.useId();\n\n  const [formTrigger, setFormTrigger] = React.useState<HTMLDivElement | null>(\n    null,\n  );\n  const composedRef = useComposedRefs(ref, setFormTrigger);\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\n\n  const onValueChange = React.useCallback(\n    (value: string) => {\n      onValueChangeProp?.(value);\n    },\n    [onValueChangeProp],\n  );\n\n  const onValueComplete = React.useCallback(\n    (value: string, completed: boolean) => {\n      onValueCompleteProp?.(value, completed);\n    },\n    [onValueCompleteProp],\n  );\n\n  React.useEffect(() => {\n    store.setCallbacks(onValueChange, onValueComplete);\n  }, [store, onValueChange, onValueComplete]);\n\n  React.useEffect(() => {\n    const currentValue = controlledValue ?? defaultValue;\n    if (currentValue) {\n      store.dispatch({ type: \"SET_CURRENT\", value: currentValue });\n    }\n  }, [controlledValue, defaultValue, store]);\n\n  React.useEffect(() => {\n    if (isControlled && controlledValue) {\n      store.dispatch({ type: \"SET_CURRENT\", value: controlledValue });\n    }\n  }, [controlledValue, isControlled, store]);\n\n  const currentValue = useStore((state) => state.currentValue);\n\n  const contextValue = React.useMemo(\n    () => ({\n      disabled,\n      clickable,\n      dir,\n      onValueAdd,\n      onValueRemove,\n      listId,\n      labelId,\n    }),\n    [disabled, clickable, dir, onValueAdd, onValueRemove, listId, labelId],\n  );\n\n  const RootPrimitive = props.asChild ? Slot : \"div\";\n\n  return (\n    <StepperContext.Provider value={contextValue}>\n      <RootPrimitive\n        ref={composedRef}\n        aria-labelledby={labelId}\n        data-disabled={disabled ? \"\" : undefined}\n        data-orientation={orientation}\n        data-slot=\"stepper\"\n        dir={dir}\n        className={cn(\"flex flex-col gap-4\", className)}\n        {...rootProps}\n      >\n        <span id={labelId} className=\"sr-only\">\n          Stepper navigation\n        </span>\n        {children}\n      </RootPrimitive>\n      {isFormControl && name && (\n        <VisuallyHiddenInput\n          type=\"hidden\"\n          control={formTrigger}\n          name={name}\n          value={currentValue || \"\"}\n          disabled={disabled}\n        />\n      )}\n    </StepperContext.Provider>\n  );\n}\n\nconst stepperListVariants = cva(\"flex gap-4\", {\n  variants: {\n    orientation: {\n      horizontal: \"flex-row items-center\",\n      vertical: \"flex-col items-start\",\n    },\n  },\n  defaultVariants: {\n    orientation: \"horizontal\",\n  },\n});\n\ninterface StepperListProps extends React.ComponentProps<\"ol\"> {\n  asChild?: boolean;\n}\n\nfunction StepperList(props: StepperListProps) {\n  const { className, children, ref, asChild, ...listProps } = props;\n  const context = useStepperContext(LIST_NAME);\n  const orientation = useStore((state) => state.orientation);\n\n  const ListPrimitive = asChild ? Slot : \"ol\";\n\n  return (\n    <ListPrimitive\n      ref={ref}\n      id={context.listId}\n      role=\"tablist\"\n      aria-orientation={orientation}\n      data-orientation={orientation}\n      data-slot=\"stepper-list\"\n      dir={context.dir}\n      className={cn(stepperListVariants({ orientation }), className)}\n      {...listProps}\n    >\n      {children}\n    </ListPrimitive>\n  );\n}\n\nconst stepperItemVariants = cva(\"flex w-full\", {\n  variants: {\n    orientation: {\n      horizontal: \"flex-col items-center text-center\",\n      vertical: \"flex-row items-start gap-4 text-left\",\n    },\n  },\n  defaultVariants: {\n    orientation: \"horizontal\",\n  },\n});\n\ninterface StepperItemContextValue {\n  value: string;\n  stepState: StepState | undefined;\n  triggerId: string;\n  contentId: string;\n  titleId: string;\n  descriptionId: string;\n}\n\nconst StepperItemContext = React.createContext<StepperItemContextValue | null>(\n  null,\n);\n\nfunction useStepperItemContext(consumerName: string) {\n  const context = React.useContext(StepperItemContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\n  }\n  return context;\n}\n\ninterface StepperItemProps extends React.ComponentProps<\"li\"> {\n  value: string;\n  completed?: boolean;\n  disabled?: boolean;\n  asChild?: boolean;\n}\n\nfunction StepperItem(props: StepperItemProps) {\n  const {\n    value,\n    completed = false,\n    disabled = false,\n    className,\n    children,\n    ref,\n    asChild,\n    ...itemProps\n  } = props;\n  const context = useStepperContext(ITEM_NAME);\n  const store = useStoreContext(ITEM_NAME);\n  const orientation = useStore((state) => state.orientation);\n  const currentValue = useStore((state) => state.currentValue);\n\n  const triggerId = React.useId();\n  const contentId = React.useId();\n  const titleId = React.useId();\n  const descriptionId = React.useId();\n\n  const onValueAdd = React.useCallback(() => {\n    context.onValueAdd?.(value);\n  }, [context.onValueAdd, value]);\n\n  const onValueRemove = React.useCallback(() => {\n    context.onValueRemove?.(value);\n  }, [context.onValueRemove, value]);\n\n  React.useEffect(() => {\n    store.dispatch({\n      type: \"ADD_STEP\",\n      value,\n      completed,\n      disabled,\n    });\n    onValueAdd();\n\n    return () => {\n      store.dispatch({ type: \"REMOVE_STEP\", value });\n      onValueRemove();\n    };\n  }, [store, value, completed, disabled, onValueAdd, onValueRemove]);\n\n  React.useEffect(() => {\n    store.dispatch({ type: \"SET_COMPLETED\", value, completed });\n  }, [store, value, completed]);\n\n  React.useEffect(() => {\n    store.dispatch({ type: \"SET_DISABLED\", value, disabled });\n  }, [store, value, disabled]);\n\n  const stepState = useStore((state) => state.steps.get(value));\n  const isActive = currentValue === value;\n\n  const itemContextValue = React.useMemo(\n    () => ({\n      value,\n      stepState,\n      triggerId,\n      contentId,\n      titleId,\n      descriptionId,\n    }),\n    [value, stepState, triggerId, contentId, titleId, descriptionId],\n  );\n\n  const ItemPrimitive = asChild ? Slot : \"li\";\n\n  return (\n    <StepperItemContext.Provider value={itemContextValue}>\n      <ItemPrimitive\n        ref={ref}\n        role=\"presentation\"\n        data-value={value}\n        data-completed={stepState?.completed ? \"\" : undefined}\n        data-disabled={stepState?.disabled ? \"\" : undefined}\n        data-active={isActive ? \"\" : undefined}\n        data-orientation={orientation}\n        data-slot=\"stepper-item\"\n        dir={context.dir}\n        className={cn(stepperItemVariants({ orientation }), className)}\n        {...itemProps}\n      >\n        {children}\n      </ItemPrimitive>\n    </StepperItemContext.Provider>\n  );\n}\n\ninterface StepperItemTriggerProps extends React.ComponentProps<typeof Button> {\n  value: string;\n  asChild?: boolean;\n}\n\nfunction StepperItemTrigger(props: StepperItemTriggerProps) {\n  const {\n    value: stepValue,\n    variant = \"ghost\",\n    size = \"icon\",\n    className,\n    children,\n    asChild = false,\n    ref,\n    ...triggerProps\n  } = props;\n  const context = useStepperContext(ITEM_TRIGGER_NAME);\n  const itemContext = useStepperItemContext(ITEM_TRIGGER_NAME);\n  const store = useStoreContext(ITEM_TRIGGER_NAME);\n  const currentValue = useStore((state) => state.currentValue);\n  const stepState = useStore((state) => state.steps.get(stepValue));\n  const globalDisabled = useStore((state) => state.disabled);\n\n  const isDisabled =\n    globalDisabled || stepState?.disabled || triggerProps.disabled;\n  const isActive = currentValue === stepValue;\n\n  const onStepClick = React.useCallback(() => {\n    if (!isDisabled && context.clickable) {\n      store.dispatch({ type: \"SET_CURRENT\", value: stepValue });\n    }\n  }, [isDisabled, context.clickable, store, stepValue]);\n\n  const TriggerPrimitive = asChild ? Slot : Button;\n\n  return (\n    <TriggerPrimitive\n      ref={ref}\n      id={itemContext.triggerId}\n      role=\"tab\"\n      aria-selected={isActive}\n      aria-controls={itemContext.contentId}\n      aria-describedby={`${itemContext.titleId} ${itemContext.descriptionId}`}\n      tabIndex={isActive ? 0 : -1}\n      variant={variant}\n      size={size}\n      data-active={isActive ? \"\" : undefined}\n      data-completed={stepState?.completed ? \"\" : undefined}\n      data-disabled={isDisabled ? \"\" : undefined}\n      data-slot=\"stepper-item-trigger\"\n      className={cn(\"rounded-full\", className)}\n      disabled={isDisabled}\n      onClick={onStepClick}\n      {...triggerProps}\n    >\n      {children}\n    </TriggerPrimitive>\n  );\n}\n\nconst stepperIndicatorVariants = cva(\n  \"flex items-center justify-center rounded-full border-2 font-medium transition-colors\",\n  {\n    variants: {\n      state: {\n        inactive: \"border-muted bg-background text-muted-foreground\",\n        active: \"border-primary bg-primary text-primary-foreground\",\n        completed: \"border-primary bg-primary text-primary-foreground\",\n      },\n      size: {\n        sm: \"size-6 text-xs\",\n        default: \"size-8 text-sm\",\n        lg: \"size-10 text-base\",\n      },\n    },\n    defaultVariants: {\n      state: \"inactive\",\n      size: \"default\",\n    },\n  },\n);\n\ninterface StepperItemIndicatorProps extends React.ComponentProps<\"div\"> {\n  value: string;\n  asChild?: boolean;\n}\n\nfunction StepperItemIndicator(props: StepperItemIndicatorProps) {\n  const {\n    value: stepValue,\n    className,\n    children,\n    ref,\n    asChild,\n    ...indicatorProps\n  } = props;\n  const context = useStepperContext(ITEM_INDICATOR_NAME);\n  const currentValue = useStore((state) => state.currentValue);\n  const stepState = useStore((state) => state.steps.get(stepValue));\n\n  const isActive = stepValue === currentValue;\n  const isCompleted = stepState?.completed ?? false;\n  const state = isCompleted ? \"completed\" : isActive ? \"active\" : \"inactive\";\n\n  const IndicatorPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <IndicatorPrimitive\n      ref={ref}\n      data-state={state}\n      data-active={isActive ? \"\" : undefined}\n      data-slot=\"stepper-item-indicator\"\n      dir={context.dir}\n      className={cn(stepperIndicatorVariants({ state }), className)}\n      {...indicatorProps}\n    >\n      {isCompleted ? <Check className=\"size-4\" /> : children}\n    </IndicatorPrimitive>\n  );\n}\n\nconst stepperSeparatorVariants = cva(\"bg-border transition-colors\", {\n  variants: {\n    orientation: {\n      horizontal: \"mx-2 h-px flex-1\",\n      vertical: \"mr-1 ml-3 h-8 w-px\",\n    },\n    state: {\n      inactive: \"bg-border\",\n      active: \"bg-primary\",\n      completed: \"bg-primary\",\n    },\n  },\n  defaultVariants: {\n    orientation: \"horizontal\",\n    state: \"inactive\",\n  },\n});\n\ninterface StepperItemSeparatorProps extends React.ComponentProps<\"div\"> {\n  completed?: boolean;\n  asChild?: boolean;\n}\n\nfunction StepperItemSeparator(props: StepperItemSeparatorProps) {\n  const {\n    className,\n    completed = false,\n    asChild,\n    ref,\n    ...separatorProps\n  } = props;\n  const context = useStepperContext(ITEM_SEPARATOR_NAME);\n  const orientation = useStore((state) => state.orientation);\n\n  const state = completed ? \"completed\" : \"inactive\";\n\n  const SeparatorPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <SeparatorPrimitive\n      ref={ref}\n      data-state={state}\n      data-orientation={orientation}\n      data-slot=\"stepper-item-separator\"\n      dir={context.dir}\n      className={cn(\n        stepperSeparatorVariants({ orientation, state }),\n        className,\n      )}\n      {...separatorProps}\n    />\n  );\n}\n\ninterface StepperItemTitleProps extends React.ComponentProps<\"span\"> {\n  asChild?: boolean;\n}\n\nfunction StepperItemTitle(props: StepperItemTitleProps) {\n  const { className, asChild, ref, ...titleProps } = props;\n  const context = useStepperContext(ITEM_TITLE_NAME);\n  const itemContext = useStepperItemContext(ITEM_TITLE_NAME);\n\n  const TitlePrimitive = asChild ? Slot : \"span\";\n\n  return (\n    <TitlePrimitive\n      ref={ref}\n      id={itemContext.titleId}\n      data-slot=\"stepper-item-title\"\n      dir={context.dir}\n      className={cn(\"font-medium text-sm\", className)}\n      {...titleProps}\n    />\n  );\n}\n\ninterface StepperItemDescriptionProps extends React.ComponentProps<\"span\"> {\n  asChild?: boolean;\n}\n\nfunction StepperItemDescription(props: StepperItemDescriptionProps) {\n  const { className, asChild, ref, ...descriptionProps } = props;\n  const context = useStepperContext(ITEM_DESCRIPTION_NAME);\n  const itemContext = useStepperItemContext(ITEM_DESCRIPTION_NAME);\n\n  const DescriptionPrimitive = asChild ? Slot : \"span\";\n\n  return (\n    <DescriptionPrimitive\n      ref={ref}\n      id={itemContext.descriptionId}\n      data-slot=\"stepper-item-description\"\n      dir={context.dir}\n      className={cn(\"text-muted-foreground text-xs\", className)}\n      {...descriptionProps}\n    />\n  );\n}\n\ninterface StepperContentProps extends React.ComponentProps<\"div\"> {\n  value: string;\n  asChild?: boolean;\n}\n\nfunction StepperContent(props: StepperContentProps) {\n  const {\n    value: stepValue,\n    className,\n    children,\n    asChild,\n    ref,\n    ...contentProps\n  } = props;\n  const context = useStepperContext(CONTENT_NAME);\n  const currentValue = useStore((state) => state.currentValue);\n\n  const contentId = React.useId();\n\n  if (stepValue !== currentValue) return null;\n\n  const ContentPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ContentPrimitive\n      ref={ref}\n      id={contentId}\n      role=\"tabpanel\"\n      aria-label={`Content for step ${stepValue}`}\n      data-value={stepValue}\n      data-slot=\"stepper-content\"\n      dir={context.dir}\n      className={cn(\"mt-4\", className)}\n      {...contentProps}\n    >\n      {children}\n    </ContentPrimitive>\n  );\n}\n\nfunction useStepperActions() {\n  const store = useStoreContext(\"useStepperActions\");\n\n  const onValueComplete = React.useCallback(\n    (value: string, completed: boolean = true) => {\n      store.dispatch({ type: \"SET_COMPLETED\", value, completed });\n    },\n    [store],\n  );\n\n  const onValueDisable = React.useCallback(\n    (value: string, disabled: boolean = true) => {\n      store.dispatch({ type: \"SET_DISABLED\", value, disabled });\n    },\n    [store],\n  );\n\n  const onValueNavigate = React.useCallback(\n    (value: string) => {\n      store.dispatch({ type: \"SET_CURRENT\", value });\n    },\n    [store],\n  );\n\n  return React.useMemo(\n    () => ({\n      onValueComplete,\n      onValueDisable,\n      onValueNavigate,\n    }),\n    [onValueComplete, onValueDisable, onValueNavigate],\n  );\n}\n\nexport {\n  StepperRoot as Stepper,\n  StepperList,\n  StepperItem,\n  StepperItemTrigger,\n  StepperItemIndicator,\n  StepperItemSeparator,\n  StepperItemTitle,\n  StepperItemDescription,\n  StepperContent,\n  //\n  StepperRoot as Root,\n  StepperList as List,\n  StepperItem as Item,\n  StepperItemTrigger as ItemTrigger,\n  StepperItemIndicator as ItemIndicator,\n  StepperItemSeparator as ItemSeparator,\n  StepperItemTitle as ItemTitle,\n  StepperItemDescription as ItemDescription,\n  StepperContent as Content,\n  //\n  useStore as useStepper,\n  useStepperActions,\n  //\n  type StepperRootProps as StepperProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}