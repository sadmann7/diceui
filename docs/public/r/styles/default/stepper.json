{
  "name": "stepper",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "class-variance-authority",
    "lucide-react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/stepper.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { Check } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"Stepper\";\r\nconst LIST_NAME = \"StepperList\";\r\nconst ITEM_NAME = \"StepperItem\";\r\nconst TRIGGER_NAME = \"StepperTrigger\";\r\nconst INDICATOR_NAME = \"StepperIndicator\";\r\nconst SEPARATOR_NAME = \"StepperSeparator\";\r\nconst TITLE_NAME = \"StepperTitle\";\r\nconst DESCRIPTION_NAME = \"StepperDescription\";\r\nconst CONTENT_NAME = \"StepperContent\";\r\nconst PREV_TRIGGER_NAME = \"StepperPrevTrigger\";\r\nconst NEXT_TRIGGER_NAME = \"StepperNextTrigger\";\r\n\r\nconst ENTRY_FOCUS = \"stepperFocusGroup.onEntryFocus\";\r\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\r\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\r\n\r\nfunction getId(\r\n  id: string,\r\n  variant: \"trigger\" | \"content\" | \"title\" | \"description\",\r\n  value: string,\r\n) {\r\n  return `${id}-${variant}-${value}`;\r\n}\r\n\r\ntype FocusIntent = \"first\" | \"last\" | \"prev\" | \"next\";\r\n\r\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\r\n  ArrowLeft: \"prev\",\r\n  ArrowUp: \"prev\",\r\n  ArrowRight: \"next\",\r\n  ArrowDown: \"next\",\r\n  PageUp: \"first\",\r\n  Home: \"first\",\r\n  PageDown: \"last\",\r\n  End: \"last\",\r\n};\r\n\r\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\r\n  if (dir !== \"rtl\") return key;\r\n  return key === \"ArrowLeft\"\r\n    ? \"ArrowRight\"\r\n    : key === \"ArrowRight\"\r\n      ? \"ArrowLeft\"\r\n      : key;\r\n}\r\n\r\nfunction getFocusIntent(\r\n  event: React.KeyboardEvent<TriggerElement>,\r\n  dir?: Direction,\r\n  orientation?: Orientation,\r\n) {\r\n  const key = getDirectionAwareKey(event.key, dir);\r\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key))\r\n    return undefined;\r\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key))\r\n    return undefined;\r\n  return MAP_KEY_TO_FOCUS_INTENT[key];\r\n}\r\n\r\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\r\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\r\n  for (const candidate of candidates) {\r\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n    candidate.focus({ preventScroll });\r\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n  }\r\n}\r\n\r\nfunction wrapArray<T>(array: T[], startIndex: number) {\r\n  return array.map<T>(\r\n    (_, index) => array[(startIndex + index) % array.length] as T,\r\n  );\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\n\r\ntype NavigationDirection = \"next\" | \"prev\";\r\n\r\ntype ActivationMode = \"automatic\" | \"manual\";\r\n\r\ntype DataState = \"inactive\" | \"active\" | \"completed\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction getDataState(\r\n  value: string | undefined,\r\n  itemValue: string,\r\n  stepState: StepState | undefined,\r\n  steps: Map<string, StepState>,\r\n  variant: \"item\" | \"separator\" = \"item\",\r\n): DataState {\r\n  const stepKeys = Array.from(steps.keys());\r\n  const currentIndex = stepKeys.indexOf(itemValue);\r\n\r\n  if (stepState?.completed) return \"completed\";\r\n\r\n  if (value === itemValue) {\r\n    return variant === \"separator\" ? \"inactive\" : \"active\";\r\n  }\r\n\r\n  if (value) {\r\n    const activeIndex = stepKeys.indexOf(value);\r\n\r\n    if (activeIndex > currentIndex) return \"completed\";\r\n  }\r\n\r\n  return \"inactive\";\r\n}\r\n\r\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\r\n\r\nfunction useDirection(dirProp?: Direction): Direction {\r\n  const contextDir = React.useContext(DirectionContext);\r\n  return dirProp ?? contextDir ?? \"ltr\";\r\n}\r\n\r\ninterface StepState {\r\n  value: string;\r\n  completed: boolean;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface StoreState {\r\n  steps: Map<string, StepState>;\r\n  value?: string;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  setStateWithValidation: (\r\n    value: string,\r\n    direction: NavigationDirection,\r\n  ) => Promise<boolean>;\r\n  hasValidation: () => boolean;\r\n  notify: () => void;\r\n  addStep: (value: string, completed: boolean, disabled: boolean) => void;\r\n  removeStep: (value: string) => void;\r\n  setStep: (value: string, completed: boolean, disabled: boolean) => void;\r\n}\r\n\r\nfunction createStore(\r\n  listenersRef: React.RefObject<Set<() => void>>,\r\n  stateRef: React.RefObject<StoreState>,\r\n  onValueChange?: (value: string) => void,\r\n  onValueComplete?: (value: string, completed: boolean) => void,\r\n  onValueAdd?: (value: string) => void,\r\n  onValueRemove?: (value: string) => void,\r\n  onValidate?: (\r\n    value: string,\r\n    direction: NavigationDirection,\r\n  ) => boolean | Promise<boolean>,\r\n): Store {\r\n  const store: Store = {\r\n    subscribe: (cb) => {\r\n      if (listenersRef.current) {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current?.delete(cb);\r\n      }\r\n      return () => {};\r\n    },\r\n    getState: () =>\r\n      stateRef.current ?? {\r\n        steps: new Map(),\r\n        value: undefined,\r\n      },\r\n    setState: (key, value) => {\r\n      const state = stateRef.current;\r\n      if (!state || Object.is(state[key], value)) return;\r\n\r\n      if (key === \"value\" && typeof value === \"string\") {\r\n        state.value = value;\r\n        onValueChange?.(value);\r\n      } else {\r\n        state[key] = value;\r\n      }\r\n\r\n      store.notify();\r\n    },\r\n    setStateWithValidation: async (value, direction) => {\r\n      if (!onValidate) {\r\n        store.setState(\"value\", value);\r\n        return true;\r\n      }\r\n\r\n      try {\r\n        const isValid = await onValidate(value, direction);\r\n        if (isValid) {\r\n          store.setState(\"value\", value);\r\n        }\r\n        return isValid;\r\n      } catch {\r\n        return false;\r\n      }\r\n    },\r\n    hasValidation: () => !!onValidate,\r\n    addStep: (value, completed, disabled) => {\r\n      const state = stateRef.current;\r\n      if (state) {\r\n        const newStep: StepState = { value, completed, disabled };\r\n        state.steps.set(value, newStep);\r\n        onValueAdd?.(value);\r\n        store.notify();\r\n      }\r\n    },\r\n    removeStep: (value) => {\r\n      const state = stateRef.current;\r\n      if (state) {\r\n        state.steps.delete(value);\r\n        onValueRemove?.(value);\r\n        store.notify();\r\n      }\r\n    },\r\n    setStep: (value, completed, disabled) => {\r\n      const state = stateRef.current;\r\n      if (state) {\r\n        const step = state.steps.get(value);\r\n        if (step) {\r\n          const updatedStep: StepState = { ...step, completed, disabled };\r\n          state.steps.set(value, updatedStep);\r\n\r\n          if (completed !== step.completed) {\r\n            onValueComplete?.(value, completed);\r\n          }\r\n\r\n          store.notify();\r\n        }\r\n      }\r\n    },\r\n    notify: () => {\r\n      if (listenersRef.current) {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      }\r\n    },\r\n  };\r\n\r\n  return store;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface ItemData {\r\n  id: string;\r\n  element: HTMLElement;\r\n  value: string;\r\n  active: boolean;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface StepperContextValue {\r\n  id: string;\r\n  dir: Direction;\r\n  orientation: Orientation;\r\n  activationMode: ActivationMode;\r\n  disabled: boolean;\r\n  nonInteractive: boolean;\r\n  loop: boolean;\r\n}\r\n\r\nconst StepperContext = React.createContext<StepperContextValue | null>(null);\r\n\r\nfunction useStepperContext(consumerName: string) {\r\n  const context = React.useContext(StepperContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface StepperRootProps extends DivProps {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (value: string) => void;\r\n  onValueComplete?: (value: string, completed: boolean) => void;\r\n  onValueAdd?: (value: string) => void;\r\n  onValueRemove?: (value: string) => void;\r\n  onValidate?: (\r\n    value: string,\r\n    direction: NavigationDirection,\r\n  ) => boolean | Promise<boolean>;\r\n  activationMode?: ActivationMode;\r\n  dir?: Direction;\r\n  orientation?: Orientation;\r\n  disabled?: boolean;\r\n  loop?: boolean;\r\n  nonInteractive?: boolean;\r\n}\r\n\r\nfunction StepperRoot(props: StepperRootProps) {\r\n  const {\r\n    value,\r\n    defaultValue,\r\n    onValueChange,\r\n    onValueComplete,\r\n    onValueAdd,\r\n    onValueRemove,\r\n    onValidate,\r\n    id: idProp,\r\n    dir: dirProp,\r\n    orientation = \"horizontal\",\r\n    activationMode = \"automatic\",\r\n    asChild,\r\n    disabled = false,\r\n    nonInteractive = false,\r\n    loop = false,\r\n    className,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    steps: new Map(),\r\n    value: value ?? defaultValue,\r\n  }));\r\n\r\n  const store = React.useMemo(\r\n    () =>\r\n      createStore(\r\n        listenersRef,\r\n        stateRef,\r\n        onValueChange,\r\n        onValueComplete,\r\n        onValueAdd,\r\n        onValueRemove,\r\n        onValidate,\r\n      ),\r\n    [\r\n      listenersRef,\r\n      stateRef,\r\n      onValueChange,\r\n      onValueComplete,\r\n      onValueAdd,\r\n      onValueRemove,\r\n      onValidate,\r\n    ],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (value !== undefined) {\r\n      store.setState(\"value\", value);\r\n    }\r\n  }, [value, store]);\r\n\r\n  const dir = useDirection(dirProp);\r\n\r\n  const id = React.useId();\r\n\r\n  const rootId = idProp ?? id;\r\n\r\n  const contextValue = React.useMemo<StepperContextValue>(\r\n    () => ({\r\n      id: rootId,\r\n      dir,\r\n      orientation,\r\n      activationMode,\r\n      disabled,\r\n      nonInteractive,\r\n      loop,\r\n    }),\r\n    [rootId, dir, orientation, activationMode, disabled, nonInteractive, loop],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <StepperContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          id={rootId}\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-orientation={orientation}\r\n          data-slot=\"stepper\"\r\n          dir={dir}\r\n          {...rootProps}\r\n          className={cn(\r\n            \"flex gap-6\",\r\n            orientation === \"horizontal\" ? \"flex-col\" : \"flex-row\",\r\n            className,\r\n          )}\r\n        />\r\n      </StepperContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface FocusContextValue {\r\n  tabStopId: string | null;\r\n  onItemFocus: (tabStopId: string) => void;\r\n  onItemShiftTab: () => void;\r\n  onFocusableItemAdd: () => void;\r\n  onFocusableItemRemove: () => void;\r\n  onItemRegister: (item: ItemData) => void;\r\n  onItemUnregister: (id: string) => void;\r\n  getItems: () => ItemData[];\r\n}\r\n\r\nconst FocusContext = React.createContext<FocusContextValue | null>(null);\r\n\r\nfunction useFocusContext(consumerName: string) {\r\n  const context = React.useContext(FocusContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within a focus provider`);\r\n  }\r\n  return context;\r\n}\r\n\r\ntype ListElement = React.ComponentRef<typeof StepperList>;\r\n\r\ninterface StepperListProps extends DivProps {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction StepperList(props: StepperListProps) {\r\n  const { className, children, asChild, ref, ...listProps } = props;\r\n\r\n  const context = useStepperContext(LIST_NAME);\r\n  const orientation = context.orientation;\r\n  const currentValue = useStore((state) => state.value);\r\n\r\n  const [tabStopId, setTabStopId] = React.useState<string | null>(null);\r\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\r\n  const [focusableItemCount, setFocusableItemCount] = React.useState(0);\r\n  const isClickFocusRef = React.useRef(false);\r\n  const itemsRef = React.useRef<Map<string, ItemData>>(new Map());\r\n  const listRef = React.useRef<HTMLElement>(null);\r\n  const composedRef = useComposedRefs(ref, listRef);\r\n\r\n  const onItemFocus = React.useCallback((tabStopId: string) => {\r\n    setTabStopId(tabStopId);\r\n  }, []);\r\n\r\n  const onItemShiftTab = React.useCallback(() => {\r\n    setIsTabbingBackOut(true);\r\n  }, []);\r\n\r\n  const onFocusableItemAdd = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount + 1);\r\n  }, []);\r\n\r\n  const onFocusableItemRemove = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount - 1);\r\n  }, []);\r\n\r\n  const onItemRegister = React.useCallback((item: ItemData) => {\r\n    itemsRef.current.set(item.id, item);\r\n  }, []);\r\n\r\n  const onItemUnregister = React.useCallback((id: string) => {\r\n    itemsRef.current.delete(id);\r\n  }, []);\r\n\r\n  const getItems = React.useCallback(() => {\r\n    return Array.from(itemsRef.current.values()).sort((a, b) => {\r\n      const position = a.element.compareDocumentPosition(b.element);\r\n      if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n        return -1;\r\n      }\r\n      if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n        return 1;\r\n      }\r\n      return 0;\r\n    });\r\n  }, []);\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<ListElement>) => {\r\n      listProps.onBlur?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setIsTabbingBackOut(false);\r\n    },\r\n    [listProps.onBlur],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<ListElement>) => {\r\n      listProps.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const isKeyboardFocus = !isClickFocusRef.current;\r\n      if (\r\n        event.target === event.currentTarget &&\r\n        isKeyboardFocus &&\r\n        !isTabbingBackOut\r\n      ) {\r\n        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\r\n        event.currentTarget.dispatchEvent(entryFocusEvent);\r\n\r\n        if (!entryFocusEvent.defaultPrevented) {\r\n          const items = Array.from(itemsRef.current.values()).filter(\r\n            (item) => !item.disabled,\r\n          );\r\n          const selectedItem = currentValue\r\n            ? items.find((item) => item.value === currentValue)\r\n            : undefined;\r\n          const activeItem = items.find((item) => item.active);\r\n          const currentItem = items.find((item) => item.id === tabStopId);\r\n\r\n          const candidateItems = [\r\n            selectedItem,\r\n            activeItem,\r\n            currentItem,\r\n            ...items,\r\n          ].filter(Boolean) as ItemData[];\r\n          const candidateNodes = candidateItems.map((item) => item.element);\r\n          focusFirst(candidateNodes, false);\r\n        }\r\n      }\r\n      isClickFocusRef.current = false;\r\n    },\r\n    [listProps.onFocus, isTabbingBackOut, currentValue, tabStopId],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<ListElement>) => {\r\n      listProps.onMouseDown?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      isClickFocusRef.current = true;\r\n    },\r\n    [listProps.onMouseDown],\r\n  );\r\n\r\n  const focusContextValue = React.useMemo<FocusContextValue>(\r\n    () => ({\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    }),\r\n    [\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    ],\r\n  );\r\n\r\n  const ListPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <FocusContext.Provider value={focusContextValue}>\r\n      <ListPrimitive\r\n        role=\"tablist\"\r\n        aria-orientation={orientation}\r\n        data-orientation={orientation}\r\n        data-slot=\"stepper-list\"\r\n        dir={context.dir}\r\n        tabIndex={isTabbingBackOut || focusableItemCount === 0 ? -1 : 0}\r\n        {...listProps}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"flex outline-none\",\r\n          orientation === \"horizontal\"\r\n            ? \"flex-row items-center\"\r\n            : \"flex-col items-start\",\r\n          className,\r\n        )}\r\n        onBlur={onBlur}\r\n        onFocus={onFocus}\r\n        onMouseDown={onMouseDown}\r\n      >\r\n        {children}\r\n      </ListPrimitive>\r\n    </FocusContext.Provider>\r\n  );\r\n}\r\n\r\ninterface StepperItemContextValue {\r\n  value: string;\r\n  stepState: StepState | undefined;\r\n}\r\n\r\nconst StepperItemContext = React.createContext<StepperItemContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useStepperItemContext(consumerName: string) {\r\n  const context = React.useContext(StepperItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface StepperItemProps extends DivProps {\r\n  value: string;\r\n  completed?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nfunction StepperItem(props: StepperItemProps) {\r\n  const {\r\n    value: itemValue,\r\n    completed = false,\r\n    disabled = false,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(ITEM_NAME);\r\n  const store = useStoreContext(ITEM_NAME);\r\n  const orientation = context.orientation;\r\n  const value = useStore((state) => state.value);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    store.addStep(itemValue, completed, disabled);\r\n\r\n    return () => {\r\n      store.removeStep(itemValue);\r\n    };\r\n  }, [store, itemValue, completed, disabled]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    store.setStep(itemValue, completed, disabled);\r\n  }, [store, itemValue, completed, disabled]);\r\n\r\n  const stepState = useStore((state) => state.steps.get(itemValue));\r\n  const steps = useStore((state) => state.steps);\r\n  const dataState = getDataState(value, itemValue, stepState, steps);\r\n\r\n  const itemContextValue = React.useMemo<StepperItemContextValue>(\r\n    () => ({\r\n      value: itemValue,\r\n      stepState,\r\n    }),\r\n    [itemValue, stepState],\r\n  );\r\n\r\n  const ItemPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <StepperItemContext.Provider value={itemContextValue}>\r\n      <ItemPrimitive\r\n        data-disabled={stepState?.disabled ? \"\" : undefined}\r\n        data-orientation={orientation}\r\n        data-state={dataState}\r\n        data-slot=\"stepper-item\"\r\n        dir={context.dir}\r\n        {...itemProps}\r\n        ref={ref}\r\n        className={cn(\r\n          \"relative flex not-last:flex-1 items-center\",\r\n          orientation === \"horizontal\" ? \"flex-row\" : \"flex-col\",\r\n          className,\r\n        )}\r\n      >\r\n        {children}\r\n      </ItemPrimitive>\r\n    </StepperItemContext.Provider>\r\n  );\r\n}\r\n\r\ntype TriggerElement = React.ComponentRef<typeof StepperTrigger>;\r\n\r\nfunction StepperTrigger(props: ButtonProps) {\r\n  const { asChild, className, ref, ...triggerProps } = props;\r\n\r\n  const context = useStepperContext(TRIGGER_NAME);\r\n  const itemContext = useStepperItemContext(TRIGGER_NAME);\r\n  const store = useStoreContext(TRIGGER_NAME);\r\n  const focusContext = useFocusContext(TRIGGER_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const itemValue = itemContext.value;\r\n  const stepState = useStore((state) => state.steps.get(itemValue));\r\n  const activationMode = context.activationMode;\r\n  const orientation = context.orientation;\r\n  const loop = context.loop;\r\n\r\n  const steps = useStore((state) => state.steps);\r\n  const stepIndex = Array.from(steps.keys()).indexOf(itemValue);\r\n\r\n  const stepPosition = stepIndex + 1;\r\n  const stepCount = steps.size;\r\n\r\n  const triggerId = getId(context.id, \"trigger\", itemValue);\r\n  const contentId = getId(context.id, \"content\", itemValue);\r\n  const titleId = getId(context.id, \"title\", itemValue);\r\n  const descriptionId = getId(context.id, \"description\", itemValue);\r\n\r\n  const isDisabled =\r\n    context.disabled || stepState?.disabled || triggerProps.disabled;\r\n  const isActive = value === itemValue;\r\n  const isTabStop = focusContext.tabStopId === triggerId;\r\n  const dataState = getDataState(value, itemValue, stepState, steps);\r\n\r\n  const [triggerElement, setTriggerElement] =\r\n    React.useState<TriggerElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, setTriggerElement);\r\n  const isArrowKeyPressedRef = React.useRef(false);\r\n  const isMouseClickRef = React.useRef(false);\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (ARROW_KEYS.includes(event.key)) {\r\n        isArrowKeyPressedRef.current = true;\r\n      }\r\n    }\r\n    function onKeyUp() {\r\n      isArrowKeyPressedRef.current = false;\r\n    }\r\n    document.addEventListener(\"keydown\", onKeyDown);\r\n    document.addEventListener(\"keyup\", onKeyUp);\r\n    return () => {\r\n      document.removeEventListener(\"keydown\", onKeyDown);\r\n      document.removeEventListener(\"keyup\", onKeyUp);\r\n    };\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    if (triggerElement) {\r\n      focusContext.onItemRegister({\r\n        id: triggerId,\r\n        element: triggerElement,\r\n        value: itemValue,\r\n        active: isTabStop,\r\n        disabled: !!isDisabled,\r\n      });\r\n\r\n      if (!isDisabled) {\r\n        focusContext.onFocusableItemAdd();\r\n      }\r\n\r\n      return () => {\r\n        focusContext.onItemUnregister(triggerId);\r\n        if (!isDisabled) {\r\n          focusContext.onFocusableItemRemove();\r\n        }\r\n      };\r\n    }\r\n  }, [\r\n    triggerElement,\r\n    focusContext,\r\n    triggerId,\r\n    itemValue,\r\n    isTabStop,\r\n    isDisabled,\r\n  ]);\r\n\r\n  const onClick = React.useCallback(\r\n    async (event: React.MouseEvent<TriggerElement>) => {\r\n      triggerProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (!isDisabled && !context.nonInteractive) {\r\n        const currentStepIndex = Array.from(steps.keys()).indexOf(value ?? \"\");\r\n        const targetStepIndex = Array.from(steps.keys()).indexOf(itemValue);\r\n        const direction = targetStepIndex > currentStepIndex ? \"next\" : \"prev\";\r\n\r\n        await store.setStateWithValidation(itemValue, direction);\r\n      }\r\n    },\r\n    [\r\n      isDisabled,\r\n      context.nonInteractive,\r\n      store,\r\n      itemValue,\r\n      value,\r\n      steps,\r\n      triggerProps.onClick,\r\n    ],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    async (event: React.FocusEvent<TriggerElement>) => {\r\n      triggerProps.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      focusContext.onItemFocus(triggerId);\r\n\r\n      const isKeyboardFocus = !isMouseClickRef.current;\r\n\r\n      if (\r\n        !isActive &&\r\n        !isDisabled &&\r\n        activationMode !== \"manual\" &&\r\n        !context.nonInteractive &&\r\n        isKeyboardFocus\r\n      ) {\r\n        const currentStepIndex = Array.from(steps.keys()).indexOf(value || \"\");\r\n        const targetStepIndex = Array.from(steps.keys()).indexOf(itemValue);\r\n        const direction = targetStepIndex > currentStepIndex ? \"next\" : \"prev\";\r\n\r\n        await store.setStateWithValidation(itemValue, direction);\r\n      }\r\n\r\n      isMouseClickRef.current = false;\r\n    },\r\n    [\r\n      focusContext,\r\n      triggerId,\r\n      activationMode,\r\n      isActive,\r\n      isDisabled,\r\n      context.nonInteractive,\r\n      store,\r\n      itemValue,\r\n      value,\r\n      steps,\r\n      triggerProps.onFocus,\r\n    ],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    async (event: React.KeyboardEvent<TriggerElement>) => {\r\n      triggerProps.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Enter\" && context.nonInteractive) {\r\n        event.preventDefault();\r\n        return;\r\n      }\r\n\r\n      if (\r\n        (event.key === \"Enter\" || event.key === \" \") &&\r\n        activationMode === \"manual\" &&\r\n        !context.nonInteractive\r\n      ) {\r\n        event.preventDefault();\r\n        if (!isDisabled && triggerElement) {\r\n          triggerElement.click();\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (event.key === \"Tab\" && event.shiftKey) {\r\n        focusContext.onItemShiftTab();\r\n        return;\r\n      }\r\n\r\n      if (event.target !== event.currentTarget) return;\r\n\r\n      const focusIntent = getFocusIntent(event, context.dir, orientation);\r\n\r\n      if (focusIntent !== undefined) {\r\n        if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)\r\n          return;\r\n        event.preventDefault();\r\n\r\n        const items = focusContext.getItems().filter((item) => !item.disabled);\r\n        let candidateNodes = items.map((item) => item.element);\r\n\r\n        if (focusIntent === \"last\") {\r\n          candidateNodes.reverse();\r\n        } else if (focusIntent === \"prev\" || focusIntent === \"next\") {\r\n          if (focusIntent === \"prev\") candidateNodes.reverse();\r\n          const currentIndex = candidateNodes.indexOf(\r\n            event.currentTarget as HTMLElement,\r\n          );\r\n          candidateNodes = loop\r\n            ? wrapArray(candidateNodes, currentIndex + 1)\r\n            : candidateNodes.slice(currentIndex + 1);\r\n        }\r\n\r\n        if (store.hasValidation() && candidateNodes.length > 0) {\r\n          const nextElement = candidateNodes[0];\r\n          const nextItem = items.find((item) => item.element === nextElement);\r\n\r\n          if (nextItem && nextItem.value !== itemValue) {\r\n            const currentStepIndex = Array.from(steps.keys()).indexOf(\r\n              value || \"\",\r\n            );\r\n            const targetStepIndex = Array.from(steps.keys()).indexOf(\r\n              nextItem.value,\r\n            );\r\n            const direction: NavigationDirection =\r\n              targetStepIndex > currentStepIndex ? \"next\" : \"prev\";\r\n\r\n            if (direction === \"next\") {\r\n              const isValid = await store.setStateWithValidation(\r\n                nextItem.value,\r\n                direction,\r\n              );\r\n              if (!isValid) return;\r\n            } else {\r\n              store.setState(\"value\", nextItem.value);\r\n            }\r\n\r\n            queueMicrotask(() => nextElement?.focus());\r\n            return;\r\n          }\r\n        }\r\n\r\n        queueMicrotask(() => focusFirst(candidateNodes));\r\n      }\r\n    },\r\n    [\r\n      focusContext,\r\n      context.nonInteractive,\r\n      context.dir,\r\n      activationMode,\r\n      orientation,\r\n      loop,\r\n      isDisabled,\r\n      triggerElement,\r\n      triggerProps.onKeyDown,\r\n      store,\r\n      itemValue,\r\n      value,\r\n      steps,\r\n    ],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<TriggerElement>) => {\r\n      triggerProps.onMouseDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isMouseClickRef.current = true;\r\n\r\n      if (isDisabled) {\r\n        event.preventDefault();\r\n      } else {\r\n        focusContext.onItemFocus(triggerId);\r\n      }\r\n    },\r\n    [focusContext, triggerId, isDisabled, triggerProps.onMouseDown],\r\n  );\r\n\r\n  const TriggerPrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <TriggerPrimitive\r\n      id={triggerId}\r\n      role=\"tab\"\r\n      type=\"button\"\r\n      aria-controls={contentId}\r\n      aria-current={isActive ? \"step\" : undefined}\r\n      aria-describedby={`${titleId} ${descriptionId}`}\r\n      aria-posinset={stepPosition}\r\n      aria-selected={isActive}\r\n      aria-setsize={stepCount}\r\n      data-disabled={isDisabled ? \"\" : undefined}\r\n      data-state={dataState}\r\n      data-slot=\"stepper-trigger\"\r\n      disabled={isDisabled}\r\n      tabIndex={isTabStop ? 0 : -1}\r\n      {...triggerProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"inline-flex items-center justify-center gap-3 rounded-md text-left outline-none transition-all focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0\",\r\n        \"not-has-[[data-slot=description]]:rounded-full not-has-[[data-slot=title]]:rounded-full\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n      onMouseDown={onMouseDown}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperIndicatorProps extends Omit<DivProps, \"children\"> {\r\n  children?: React.ReactNode | ((dataState: DataState) => React.ReactNode);\r\n}\r\n\r\nfunction StepperIndicator(props: StepperIndicatorProps) {\r\n  const { className, children, asChild, ref, ...indicatorProps } = props;\r\n  const context = useStepperContext(INDICATOR_NAME);\r\n  const itemContext = useStepperItemContext(INDICATOR_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const itemValue = itemContext.value;\r\n  const stepState = useStore((state) => state.steps.get(itemValue));\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const stepPosition = Array.from(steps.keys()).indexOf(itemValue) + 1;\r\n\r\n  const dataState = getDataState(value, itemValue, stepState, steps);\r\n\r\n  const IndicatorPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <IndicatorPrimitive\r\n      data-state={dataState}\r\n      data-slot=\"stepper-indicator\"\r\n      dir={context.dir}\r\n      {...indicatorProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"flex size-7 shrink-0 items-center justify-center rounded-full border-2 border-muted bg-background font-medium text-muted-foreground text-sm transition-colors data-[state=active]:border-primary data-[state=completed]:border-primary data-[state=active]:bg-primary data-[state=completed]:bg-primary data-[state=active]:text-primary-foreground data-[state=completed]:text-primary-foreground\",\r\n        className,\r\n      )}\r\n    >\r\n      {typeof children === \"function\" ? (\r\n        children(dataState)\r\n      ) : children ? (\r\n        children\r\n      ) : dataState === \"completed\" ? (\r\n        <Check className=\"size-4\" />\r\n      ) : (\r\n        stepPosition\r\n      )}\r\n    </IndicatorPrimitive>\r\n  );\r\n}\r\n\r\ninterface StepperSeparatorProps extends DivProps {\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction StepperSeparator(props: StepperSeparatorProps) {\r\n  const {\r\n    className,\r\n    asChild,\r\n    forceMount = false,\r\n    ref,\r\n    ...separatorProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(SEPARATOR_NAME);\r\n  const itemContext = useStepperItemContext(SEPARATOR_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const orientation = context.orientation;\r\n\r\n  const steps = useStore((state) => state.steps);\r\n  const stepIndex = Array.from(steps.keys()).indexOf(itemContext.value);\r\n\r\n  const isLastStep = stepIndex === steps.size - 1;\r\n\r\n  if (isLastStep && !forceMount) {\r\n    return null;\r\n  }\r\n\r\n  const dataState = getDataState(\r\n    value,\r\n    itemContext.value,\r\n    itemContext.stepState,\r\n    steps,\r\n    \"separator\",\r\n  );\r\n\r\n  const SeparatorPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SeparatorPrimitive\r\n      role=\"separator\"\r\n      aria-hidden=\"true\"\r\n      aria-orientation={orientation}\r\n      data-orientation={orientation}\r\n      data-state={dataState}\r\n      data-slot=\"stepper-separator\"\r\n      dir={context.dir}\r\n      {...separatorProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"bg-border transition-colors data-[state=active]:bg-primary data-[state=completed]:bg-primary\",\r\n        orientation === \"horizontal\" ? \"h-px flex-1\" : \"h-10 w-px\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperTitleProps extends React.ComponentProps<\"span\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction StepperTitle(props: StepperTitleProps) {\r\n  const { className, asChild, ref, ...titleProps } = props;\r\n\r\n  const context = useStepperContext(TITLE_NAME);\r\n  const itemContext = useStepperItemContext(TITLE_NAME);\r\n\r\n  const titleId = getId(context.id, \"title\", itemContext.value);\r\n\r\n  const TitlePrimitive = asChild ? Slot : \"span\";\r\n\r\n  return (\r\n    <TitlePrimitive\r\n      id={titleId}\r\n      data-slot=\"title\"\r\n      dir={context.dir}\r\n      {...titleProps}\r\n      ref={ref}\r\n      className={cn(\"font-medium text-sm\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperDescriptionProps extends React.ComponentProps<\"span\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction StepperDescription(props: StepperDescriptionProps) {\r\n  const { className, asChild, ref, ...descriptionProps } = props;\r\n  const context = useStepperContext(DESCRIPTION_NAME);\r\n  const itemContext = useStepperItemContext(DESCRIPTION_NAME);\r\n\r\n  const descriptionId = getId(context.id, \"description\", itemContext.value);\r\n\r\n  const DescriptionPrimitive = asChild ? Slot : \"span\";\r\n\r\n  return (\r\n    <DescriptionPrimitive\r\n      id={descriptionId}\r\n      data-slot=\"description\"\r\n      dir={context.dir}\r\n      {...descriptionProps}\r\n      ref={ref}\r\n      className={cn(\"text-muted-foreground text-xs\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperContentProps extends DivProps {\r\n  value: string;\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction StepperContent(props: StepperContentProps) {\r\n  const {\r\n    value: valueProp,\r\n    asChild,\r\n    forceMount = false,\r\n    ref,\r\n    className,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(CONTENT_NAME);\r\n  const value = useStore((state) => state.value);\r\n\r\n  const contentId = getId(context.id, \"content\", valueProp);\r\n  const triggerId = getId(context.id, \"trigger\", valueProp);\r\n\r\n  if (valueProp !== value && !forceMount) return null;\r\n\r\n  const ContentPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ContentPrimitive\r\n      id={contentId}\r\n      role=\"tabpanel\"\r\n      aria-labelledby={triggerId}\r\n      data-slot=\"stepper-content\"\r\n      dir={context.dir}\r\n      {...contentProps}\r\n      ref={ref}\r\n      className={cn(\"flex-1 outline-none\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nfunction StepperPrevTrigger(props: ButtonProps) {\r\n  const { asChild, disabled, ...prevTriggerProps } = props;\r\n\r\n  const store = useStoreContext(PREV_TRIGGER_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const stepKeys = Array.from(steps.keys());\r\n  const currentIndex = value ? stepKeys.indexOf(value) : -1;\r\n  const isDisabled = disabled || currentIndex <= 0;\r\n\r\n  const onClick = React.useCallback(\r\n    async (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      prevTriggerProps.onClick?.(event);\r\n      if (event.defaultPrevented || isDisabled) return;\r\n\r\n      const prevIndex = Math.max(currentIndex - 1, 0);\r\n      const prevStepValue = stepKeys[prevIndex];\r\n\r\n      if (prevStepValue) {\r\n        store.setState(\"value\", prevStepValue);\r\n      }\r\n    },\r\n    [prevTriggerProps.onClick, isDisabled, currentIndex, stepKeys, store],\r\n  );\r\n\r\n  const PrevTriggerPrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <PrevTriggerPrimitive\r\n      type=\"button\"\r\n      data-slot=\"stepper-prev-trigger\"\r\n      disabled={isDisabled}\r\n      {...prevTriggerProps}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nfunction StepperNextTrigger(props: ButtonProps) {\r\n  const { asChild, disabled, ...nextTriggerProps } = props;\r\n\r\n  const store = useStoreContext(NEXT_TRIGGER_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const stepKeys = Array.from(steps.keys());\r\n  const currentIndex = value ? stepKeys.indexOf(value) : -1;\r\n  const isDisabled = disabled || currentIndex >= stepKeys.length - 1;\r\n\r\n  const onClick = React.useCallback(\r\n    async (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      nextTriggerProps.onClick?.(event);\r\n      if (event.defaultPrevented || isDisabled) return;\r\n\r\n      const nextIndex = Math.min(currentIndex + 1, stepKeys.length - 1);\r\n      const nextStepValue = stepKeys[nextIndex];\r\n\r\n      if (nextStepValue) {\r\n        await store.setStateWithValidation(nextStepValue, \"next\");\r\n      }\r\n    },\r\n    [nextTriggerProps.onClick, isDisabled, currentIndex, stepKeys, store],\r\n  );\r\n\r\n  const NextTriggerPrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <NextTriggerPrimitive\r\n      type=\"button\"\r\n      data-slot=\"stepper-next-trigger\"\r\n      disabled={isDisabled}\r\n      {...nextTriggerProps}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  StepperRoot as Root,\r\n  StepperList as List,\r\n  StepperItem as Item,\r\n  StepperTrigger as Trigger,\r\n  StepperIndicator as ItemIndicator,\r\n  StepperSeparator as Separator,\r\n  StepperTitle as Title,\r\n  StepperDescription as Description,\r\n  StepperContent as Content,\r\n  StepperPrevTrigger as PrevTrigger,\r\n  StepperNextTrigger as NextTrigger,\r\n  //\r\n  StepperRoot as Stepper,\r\n  StepperList,\r\n  StepperItem,\r\n  StepperTrigger,\r\n  StepperIndicator,\r\n  StepperSeparator,\r\n  StepperTitle,\r\n  StepperDescription,\r\n  StepperContent,\r\n  StepperPrevTrigger,\r\n  StepperNextTrigger,\r\n  //\r\n  useStore as useStepper,\r\n  //\r\n  type StepperRootProps as StepperProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}