{
  "name": "key-value",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/key-value.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { PlusIcon, XIcon } from \"lucide-react\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\n\nconst ROOT_NAME = \"KeyValue\";\nconst LIST_NAME = \"KeyValueList\";\nconst ITEM_NAME = \"KeyValueItem\";\nconst KEY_INPUT_NAME = \"KeyValueKeyInput\";\nconst VALUE_INPUT_NAME = \"KeyValueValueInput\";\nconst REMOVE_NAME = \"KeyValueRemove\";\nconst ADD_NAME = \"KeyValueAdd\";\nconst ERROR_NAME = \"KeyValueError\";\n\ntype Orientation = \"vertical\" | \"horizontal\";\ntype Field = \"key\" | \"value\";\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ntype RootElement = React.ComponentRef<typeof KeyValueRoot>;\ntype KeyInputElement = React.ComponentRef<typeof KeyValueKeyInput>;\ntype ValueInputElement = React.ComponentRef<typeof KeyValueValueInput>;\ntype RemoveElement = React.ComponentRef<typeof KeyValueRemove>;\ntype AddElement = React.ComponentRef<typeof KeyValueAdd>;\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nfunction getErrorId(rootId: string, entryId: string, field: Field) {\n  return `${rootId}-${entryId}-${field}-error`;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => KeyValueState;\n  setState: <K extends keyof KeyValueState>(\n    key: K,\n    value: KeyValueState[K],\n  ) => void;\n  notify: () => void;\n}\n\nfunction useStore<T>(selector: (state: KeyValueState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface KeyValueEntry {\n  id: string;\n  key: string;\n  value: string;\n}\n\ninterface KeyValueState {\n  value: KeyValueEntry[];\n  focusedId: string | null;\n  errors: Record<string, { key?: string; value?: string }>;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface KeyValueContextValue {\n  rootId: string;\n  maxEntries?: number;\n  minEntries: number;\n  keyPlaceholder: string;\n  valuePlaceholder: string;\n  allowDuplicateKeys: boolean;\n  enablePaste: boolean;\n  trim: boolean;\n  disabled: boolean;\n  readOnly: boolean;\n  required: boolean;\n}\n\nconst KeyValueContext = React.createContext<KeyValueContextValue | null>(null);\n\nfunction useKeyValueContext(consumerName: string) {\n  const context = React.useContext(KeyValueContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface KeyValueRootProps extends Omit<DivProps, \"onPaste\" | \"defaultValue\"> {\n  id?: string;\n  defaultValue?: KeyValueEntry[];\n  value?: KeyValueEntry[];\n  onValueChange?: (value: KeyValueEntry[]) => void;\n  maxEntries?: number;\n  minEntries?: number;\n  keyPlaceholder?: string;\n  valuePlaceholder?: string;\n  name?: string;\n  allowDuplicateKeys?: boolean;\n  enablePaste?: boolean;\n  trim?: boolean;\n  disabled?: boolean;\n  readOnly?: boolean;\n  required?: boolean;\n  onPaste?: (event: ClipboardEvent, entries: KeyValueEntry[]) => void;\n  onAdd?: (entry: KeyValueEntry) => void;\n  onRemove?: (entry: KeyValueEntry) => void;\n  onKeyValidate?: (key: string, value: KeyValueEntry[]) => string | undefined;\n  onValueValidate?: (\n    value: string,\n    key: string,\n    entries: KeyValueEntry[],\n  ) => string | undefined;\n}\n\nfunction KeyValueRoot(props: KeyValueRootProps) {\n  const { value, defaultValue, onValueChange, ...rootProps } = props;\n\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const stateRef = useLazyRef<KeyValueState>(() => ({\n    value: value ??\n      defaultValue ?? [{ id: crypto.randomUUID(), key: \"\", value: \"\" }],\n    focusedId: null,\n    errors: {},\n  }));\n  const propsRef = useAsRef({ onValueChange });\n\n  const store = React.useMemo<Store>(() => {\n    return {\n      subscribe: (cb) => {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current.delete(cb);\n      },\n      getState: () => stateRef.current,\n      setState: (key, val) => {\n        if (Object.is(stateRef.current[key], val)) return;\n\n        if (key === \"value\" && Array.isArray(val)) {\n          stateRef.current.value = val as KeyValueEntry[];\n          propsRef.current.onValueChange?.(val as KeyValueEntry[]);\n        } else {\n          stateRef.current[key] = val;\n        }\n\n        store.notify();\n      },\n      notify: () => {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      },\n    };\n  }, [listenersRef, stateRef, propsRef]);\n\n  return (\n    <StoreContext.Provider value={store}>\n      <KeyValueRootImpl {...rootProps} value={value} />\n    </StoreContext.Provider>\n  );\n}\n\ninterface KeyValueRootImplProps\n  extends Omit<\n    KeyValueRootProps,\n    | \"defaultValue\"\n    | \"onValueChange\"\n    | \"onPaste\"\n    | \"onAdd\"\n    | \"onRemove\"\n    | \"onKeyValidate\"\n    | \"onValueValidate\"\n  > {}\n\nfunction KeyValueRootImpl(props: KeyValueRootImplProps) {\n  const {\n    id,\n    value: valueProp,\n    maxEntries,\n    minEntries = 0,\n    keyPlaceholder = \"Key\",\n    valuePlaceholder = \"Value\",\n    name,\n    allowDuplicateKeys = true,\n    enablePaste = true,\n    trim = true,\n    disabled = false,\n    readOnly = false,\n    required = false,\n    asChild,\n    className,\n    ref,\n    ...rootProps\n  } = props;\n\n  const store = useStoreContext(\"KeyValueRootImpl\");\n\n  const value = useStore((state) => state.value);\n  const errors = useStore((state) => state.errors);\n  const isInvalid = Object.keys(errors).length > 0;\n\n  useIsomorphicLayoutEffect(() => {\n    if (valueProp !== undefined) {\n      store.setState(\"value\", valueProp);\n    }\n  }, [valueProp, store]);\n\n  const instanceId = React.useId();\n  const rootId = id ?? instanceId;\n\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\n    null,\n  );\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\n\n  const contextValue = React.useMemo<KeyValueContextValue>(\n    () => ({\n      rootId,\n      maxEntries,\n      minEntries,\n      keyPlaceholder,\n      valuePlaceholder,\n      allowDuplicateKeys,\n      enablePaste,\n      trim,\n      disabled,\n      readOnly,\n      required,\n    }),\n    [\n      rootId,\n      disabled,\n      readOnly,\n      required,\n      maxEntries,\n      minEntries,\n      keyPlaceholder,\n      valuePlaceholder,\n      allowDuplicateKeys,\n      enablePaste,\n      trim,\n    ],\n  );\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <>\n      <KeyValueContext.Provider value={contextValue}>\n        <RootPrimitive\n          id={id}\n          data-slot=\"key-value\"\n          data-disabled={disabled ? \"\" : undefined}\n          data-invalid={isInvalid ? \"\" : undefined}\n          data-readonly={readOnly ? \"\" : undefined}\n          {...rootProps}\n          ref={composedRef}\n          className={cn(\"flex flex-col gap-2\", className)}\n        />\n      </KeyValueContext.Provider>\n      {isFormControl && (\n        <VisuallyHiddenInput\n          type=\"hidden\"\n          control={formTrigger}\n          name={name}\n          value={value}\n          disabled={disabled}\n          readOnly={readOnly}\n          required={required}\n        />\n      )}\n    </>\n  );\n}\n\ninterface KeyValueListProps extends DivProps {\n  orientation?: Orientation;\n}\n\nfunction KeyValueList(props: KeyValueListProps) {\n  const { orientation = \"vertical\", asChild, className, ...listProps } = props;\n\n  const value = useStore((state) => state.value);\n\n  const ListPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ListPrimitive\n      role=\"list\"\n      aria-orientation={orientation}\n      data-slot=\"key-value-list\"\n      data-orientation={orientation}\n      {...listProps}\n      className={cn(\n        \"flex\",\n        orientation === \"vertical\" ? \"flex-col gap-2\" : \"flex-row gap-2\",\n        className,\n      )}\n    >\n      {value.map((entry) => {\n        const children = React.Children.toArray(props.children);\n        return (\n          <KeyValueItemContext.Provider key={entry.id} value={entry}>\n            {children}\n          </KeyValueItemContext.Provider>\n        );\n      })}\n    </ListPrimitive>\n  );\n}\n\nconst KeyValueItemContext = React.createContext<KeyValueEntry | null>(null);\n\nfunction useKeyValueItemContext(consumerName: string) {\n  const context = React.useContext(KeyValueItemContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${LIST_NAME}\\``);\n  }\n  return context;\n}\n\ninterface KeyValueItemProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\nfunction KeyValueItem(props: KeyValueItemProps) {\n  const { asChild, className, ...itemProps } = props;\n  const entry = useKeyValueItemContext(ITEM_NAME);\n\n  const focusedId = useStore((state) => state.focusedId);\n\n  const ItemPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemPrimitive\n      role=\"listitem\"\n      data-slot=\"key-value-item\"\n      data-highlighted={focusedId === entry.id ? \"\" : undefined}\n      {...itemProps}\n      className={cn(\"flex items-start gap-2\", className)}\n    />\n  );\n}\n\ninterface KeyValueKeyInputProps\n  extends Omit<React.ComponentProps<\"input\">, \"onPaste\">,\n    Pick<KeyValueRootProps, \"onKeyValidate\" | \"onValueValidate\" | \"onPaste\"> {\n  asChild?: boolean;\n}\n\nfunction KeyValueKeyInput(props: KeyValueKeyInputProps) {\n  const {\n    onKeyValidate,\n    onValueValidate,\n    onChange,\n    onPaste,\n    asChild,\n    disabled,\n    readOnly,\n    required,\n    className,\n    ...inputProps\n  } = props;\n\n  const context = useKeyValueContext(KEY_INPUT_NAME);\n  const entry = useKeyValueItemContext(KEY_INPUT_NAME);\n  const store = useStoreContext(KEY_INPUT_NAME);\n\n  const errors = useStore((state) => state.errors);\n\n  const isDisabled = disabled || context.disabled;\n  const isReadOnly = readOnly || context.readOnly;\n  const isRequired = required || context.required;\n  const isInvalid = errors[entry.id]?.key !== undefined;\n\n  const propsRef = useAsRef({\n    onKeyValidate,\n    onValueValidate,\n    onChange,\n    onPaste,\n  });\n\n  const onKeyInputChange = React.useCallback(\n    (event: React.ChangeEvent<KeyInputElement>) => {\n      const state = store.getState();\n      const newValue = state.value.map((item) => {\n        if (item.id !== entry.id) return item;\n        const updated = { ...item, key: event.target.value };\n        if (context.trim) updated.key = updated.key.trim();\n        return updated;\n      });\n\n      store.setState(\"value\", newValue);\n\n      const updatedEntry = newValue.find((item) => item.id === entry.id);\n      if (updatedEntry) {\n        const errors: { key?: string; value?: string } = {};\n\n        if (propsRef.current.onKeyValidate) {\n          const keyError = propsRef.current.onKeyValidate(\n            updatedEntry.key,\n            newValue,\n          );\n          if (keyError) errors.key = keyError;\n        }\n\n        if (!context.allowDuplicateKeys) {\n          const duplicateKey = newValue.find(\n            (item) =>\n              item.id !== updatedEntry.id &&\n              item.key === updatedEntry.key &&\n              updatedEntry.key !== \"\",\n          );\n          if (duplicateKey) {\n            errors.key = \"Duplicate key\";\n          }\n        }\n\n        if (propsRef.current.onValueValidate) {\n          const valueError = propsRef.current.onValueValidate(\n            updatedEntry.value,\n            updatedEntry.key,\n            newValue,\n          );\n          if (valueError) errors.value = valueError;\n        }\n\n        const newErrorsState = { ...state.errors };\n        if (Object.keys(errors).length > 0) {\n          newErrorsState[entry.id] = errors;\n        } else {\n          delete newErrorsState[entry.id];\n        }\n        store.setState(\"errors\", newErrorsState);\n      }\n\n      propsRef.current.onChange?.(event);\n    },\n    [store, entry.id, context.trim, context.allowDuplicateKeys, propsRef],\n  );\n\n  const onKeyInputPaste = React.useCallback(\n    (event: React.ClipboardEvent<KeyInputElement>) => {\n      if (!context.enablePaste) return;\n\n      const content = event.clipboardData.getData(\"text\");\n      const lines = content.split(/\\r?\\n/).filter((line) => line.trim());\n\n      // Only handle paste if multiple lines\n      if (lines.length > 1) {\n        event.preventDefault();\n\n        const parsed: KeyValueEntry[] = [];\n\n        for (const line of lines) {\n          let key = \"\";\n          let value = \"\";\n\n          // Try KEY=VALUE format\n          if (line.includes(\"=\")) {\n            const parts = line.split(\"=\");\n            key = parts[0]?.trim() ?? \"\";\n            value = parts.slice(1).join(\"=\").trim();\n          }\n          // Try KEY: VALUE format\n          else if (line.includes(\":\")) {\n            const parts = line.split(\":\");\n            key = parts[0]?.trim() ?? \"\";\n            value = parts.slice(1).join(\":\").trim();\n          }\n          // Try KEY VALUE (tab or multiple spaces)\n          else if (/\\s{2,}|\\t/.test(line)) {\n            const parts = line.split(/\\s{2,}|\\t/);\n            key = parts[0]?.trim() ?? \"\";\n            value = parts.slice(1).join(\" \").trim();\n          }\n\n          if (key) {\n            parsed.push({ id: crypto.randomUUID(), key, value });\n          }\n        }\n\n        if (parsed.length > 0) {\n          const state = store.getState();\n          const currentIndex = state.value.findIndex(\n            (item) => item.id === entry.id,\n          );\n\n          // Replace current empty entry or add after current entry\n          let newValue: KeyValueEntry[];\n          if (entry.key === \"\" && entry.value === \"\") {\n            newValue = [\n              ...state.value.slice(0, currentIndex),\n              ...parsed,\n              ...state.value.slice(currentIndex + 1),\n            ];\n          } else {\n            newValue = [\n              ...state.value.slice(0, currentIndex + 1),\n              ...parsed,\n              ...state.value.slice(currentIndex + 1),\n            ];\n          }\n\n          // Respect maxEntries\n          if (context.maxEntries !== undefined) {\n            newValue = newValue.slice(0, context.maxEntries);\n          }\n\n          store.setState(\"value\", newValue);\n\n          // Notify paste callback\n          if (propsRef.current.onPaste) {\n            propsRef.current.onPaste(\n              event.nativeEvent as unknown as ClipboardEvent,\n              parsed,\n            );\n          }\n        }\n      }\n    },\n    [\n      context.enablePaste,\n      context.maxEntries,\n      store,\n      entry.id,\n      entry.key,\n      entry.value,\n      propsRef,\n    ],\n  );\n\n  const KeyInputPrimitive = asChild ? Slot : \"input\";\n\n  return (\n    <KeyInputPrimitive\n      type=\"text\"\n      aria-invalid={isInvalid}\n      aria-describedby={\n        isInvalid ? getErrorId(context.rootId, entry.id, \"key\") : undefined\n      }\n      data-slot=\"key-value-key-input\"\n      disabled={isDisabled}\n      readOnly={isReadOnly}\n      required={isRequired}\n      {...inputProps}\n      placeholder={context.keyPlaceholder}\n      className={cn(\n        \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        isInvalid && \"border-destructive focus-visible:ring-destructive\",\n        className,\n      )}\n      value={entry.key}\n      onChange={onKeyInputChange}\n      onPaste={onKeyInputPaste}\n    />\n  );\n}\n\ninterface KeyValueValueInputProps\n  extends React.ComponentProps<\"input\">,\n    Pick<KeyValueRootProps, \"onKeyValidate\" | \"onValueValidate\"> {\n  asChild?: boolean;\n}\n\nfunction KeyValueValueInput(props: KeyValueValueInputProps) {\n  const {\n    onKeyValidate,\n    onValueValidate,\n    onChange,\n    asChild,\n    disabled,\n    readOnly,\n    required,\n    className,\n    ...inputProps\n  } = props;\n\n  const context = useKeyValueContext(VALUE_INPUT_NAME);\n  const entry = useKeyValueItemContext(VALUE_INPUT_NAME);\n  const store = useStoreContext(VALUE_INPUT_NAME);\n\n  const propsRef = useAsRef({\n    onKeyValidate,\n    onValueValidate,\n    onChange,\n  });\n  const errors = useStore((state) => state.errors);\n\n  const isDisabled = disabled || context.disabled;\n  const isReadOnly = readOnly || context.readOnly;\n  const isRequired = required || context.required;\n  const isInvalid = errors[entry.id]?.value !== undefined;\n\n  const onValueInputChange = React.useCallback(\n    (event: React.ChangeEvent<ValueInputElement>) => {\n      propsRef.current.onChange?.(event);\n\n      const state = store.getState();\n      const newValue = state.value.map((item: KeyValueEntry) => {\n        if (item.id !== entry.id) return item;\n        const updated = { ...item, value: event.target.value };\n        if (context.trim) updated.value = updated.value.trim();\n        return updated;\n      });\n\n      store.setState(\"value\", newValue);\n\n      const updatedEntry = newValue.find(\n        (item: KeyValueEntry) => item.id === entry.id,\n      );\n      if (updatedEntry) {\n        const errors: { key?: string; value?: string } = {};\n\n        if (propsRef.current.onKeyValidate) {\n          const keyError = propsRef.current.onKeyValidate(\n            updatedEntry.key,\n            newValue,\n          );\n          if (keyError) errors.key = keyError;\n        }\n\n        if (!context.allowDuplicateKeys) {\n          const duplicateKey = newValue.find(\n            (item: KeyValueEntry) =>\n              item.id !== updatedEntry.id &&\n              item.key === updatedEntry.key &&\n              updatedEntry.key !== \"\",\n          );\n          if (duplicateKey) {\n            errors.key = \"Duplicate key\";\n          }\n        }\n\n        if (propsRef.current.onValueValidate) {\n          const valueError = propsRef.current.onValueValidate(\n            updatedEntry.value,\n            updatedEntry.key,\n            newValue,\n          );\n          if (valueError) errors.value = valueError;\n        }\n\n        const newErrorsState = { ...state.errors };\n        if (Object.keys(errors).length > 0) {\n          newErrorsState[entry.id] = errors;\n        } else {\n          delete newErrorsState[entry.id];\n        }\n        store.setState(\"errors\", newErrorsState);\n      }\n    },\n    [store, entry.id, context.trim, context.allowDuplicateKeys, propsRef],\n  );\n\n  const ValueInputPrimitive = asChild ? Slot : \"input\";\n\n  return (\n    <ValueInputPrimitive\n      type=\"text\"\n      aria-invalid={isInvalid}\n      aria-describedby={\n        isInvalid ? getErrorId(context.rootId, entry.id, \"value\") : undefined\n      }\n      data-slot=\"key-value-value-input\"\n      disabled={isDisabled}\n      readOnly={isReadOnly}\n      required={isRequired}\n      {...inputProps}\n      placeholder={context.valuePlaceholder}\n      className={cn(\n        \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        isInvalid && \"border-destructive focus-visible:ring-destructive\",\n        className,\n      )}\n      value={entry.value}\n      onChange={onValueInputChange}\n    />\n  );\n}\n\ninterface KeyValueRemoveProps\n  extends React.ComponentProps<\"button\">,\n    Pick<KeyValueRootProps, \"onRemove\"> {\n  asChild?: boolean;\n}\n\nfunction KeyValueRemove(props: KeyValueRemoveProps) {\n  const { onClick, onRemove, asChild, className, children, ...buttonProps } =\n    props;\n\n  const context = useKeyValueContext(REMOVE_NAME);\n  const entry = useKeyValueItemContext(REMOVE_NAME);\n  const store = useStoreContext(REMOVE_NAME);\n\n  const propsRef = useAsRef({ onClick, onRemove });\n  const value = useStore((state) => state.value);\n  const isDisabled = context.disabled || value.length <= context.minEntries;\n\n  const onRemoveClick = React.useCallback(\n    (event: React.MouseEvent<RemoveElement>) => {\n      propsRef.current.onClick?.(event);\n\n      const state = store.getState();\n      if (state.value.length <= context.minEntries) return;\n\n      const entryToRemove = state.value.find(\n        (item: KeyValueEntry) => item.id === entry.id,\n      );\n      if (!entryToRemove) return;\n\n      const newValue = state.value.filter(\n        (item: KeyValueEntry) => item.id !== entry.id,\n      );\n      const newErrors = { ...state.errors };\n      delete newErrors[entry.id];\n\n      store.setState(\"value\", newValue);\n      store.setState(\"errors\", newErrors);\n\n      propsRef.current.onRemove?.(entryToRemove);\n    },\n    [store, context.minEntries, entry.id, propsRef],\n  );\n\n  const RemovePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <RemovePrimitive\n      type=\"button\"\n      data-slot=\"key-value-remove\"\n      disabled={isDisabled}\n      {...buttonProps}\n      className={cn(\n        \"inline-flex h-9 w-9 items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium text-sm transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n        \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        className,\n      )}\n      onClick={onRemoveClick}\n    >\n      {children ?? <XIcon />}\n    </RemovePrimitive>\n  );\n}\n\ninterface KeyValueAddProps\n  extends React.ComponentProps<\"button\">,\n    Pick<KeyValueRootProps, \"onAdd\"> {\n  asChild?: boolean;\n}\n\nfunction KeyValueAdd(props: KeyValueAddProps) {\n  const { onClick, onAdd, asChild, className, children, ...buttonProps } =\n    props;\n\n  const context = useKeyValueContext(ADD_NAME);\n  const store = useStoreContext(ADD_NAME);\n\n  const propsRef = useAsRef({ onClick, onAdd });\n  const value = useStore((state) => state.value);\n  const isDisabled =\n    context.disabled ||\n    (context.maxEntries !== undefined && value.length >= context.maxEntries);\n\n  const onAddClick = React.useCallback(\n    (event: React.MouseEvent<AddElement>) => {\n      propsRef.current.onClick?.(event);\n\n      const state = store.getState();\n      if (\n        context.maxEntries !== undefined &&\n        state.value.length >= context.maxEntries\n      ) {\n        return;\n      }\n\n      const newEntry: KeyValueEntry = {\n        id: crypto.randomUUID(),\n        key: \"\",\n        value: \"\",\n      };\n\n      const newValue = [...state.value, newEntry];\n      store.setState(\"value\", newValue);\n      store.setState(\"focusedId\", newEntry.id);\n\n      propsRef.current.onAdd?.(newEntry);\n    },\n    [store, context.maxEntries, propsRef],\n  );\n\n  const AddPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <AddPrimitive\n      type=\"button\"\n      data-slot=\"key-value-add\"\n      disabled={isDisabled}\n      {...buttonProps}\n      className={cn(\n        \"inline-flex h-9 items-center justify-center gap-2 whitespace-nowrap rounded-md px-4 font-medium text-sm transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n        \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        className,\n      )}\n      onClick={onAddClick}\n    >\n      {children ?? (\n        <>\n          <PlusIcon />\n          Add\n        </>\n      )}\n    </AddPrimitive>\n  );\n}\n\ninterface KeyValueErrorProps extends React.ComponentProps<\"span\"> {\n  field: Field;\n  asChild?: boolean;\n}\n\nfunction KeyValueError(props: KeyValueErrorProps) {\n  const { field, asChild, className, ...errorProps } = props;\n\n  const context = useKeyValueContext(ERROR_NAME);\n  const entry = useKeyValueItemContext(ERROR_NAME);\n\n  const errors = useStore((state) => state.errors);\n  const error = errors[entry.id]?.[field];\n\n  if (!error) return null;\n\n  const ErrorPrimitive = asChild ? Slot : \"span\";\n\n  return (\n    <ErrorPrimitive\n      id={getErrorId(context.rootId, entry.id, field)}\n      role=\"alert\"\n      {...errorProps}\n      className={cn(\"font-medium text-destructive text-sm\", className)}\n    >\n      {error}\n    </ErrorPrimitive>\n  );\n}\n\nexport {\n  KeyValueRoot as Root,\n  KeyValueList as List,\n  KeyValueItem as Item,\n  KeyValueKeyInput as KeyInput,\n  KeyValueValueInput as ValueInput,\n  KeyValueRemove as Remove,\n  KeyValueAdd as Add,\n  KeyValueError as Error,\n  //\n  KeyValueRoot as KeyValue,\n  KeyValueList,\n  KeyValueItem,\n  KeyValueKeyInput,\n  KeyValueValueInput,\n  KeyValueRemove,\n  KeyValueAdd,\n  KeyValueError,\n  //\n  type KeyValueEntry,\n  type KeyValueRootProps as KeyValueProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}