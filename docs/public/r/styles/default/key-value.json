{
  "name": "key-value",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/key-value.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { PlusIcon, XIcon } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"KeyValue\";\r\nconst LIST_NAME = \"KeyValueList\";\r\nconst ITEM_NAME = \"KeyValueItem\";\r\nconst KEY_INPUT_NAME = \"KeyValueKeyInput\";\r\nconst VALUE_INPUT_NAME = \"KeyValueValueInput\";\r\nconst REMOVE_BUTTON_NAME = \"KeyValueRemoveButton\";\r\nconst ADD_BUTTON_NAME = \"KeyValueAddButton\";\r\nconst ERROR_NAME = \"KeyValueError\";\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\ninterface Store<T> {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => T;\r\n  setState: <K extends keyof T>(key: K, value: T[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nfunction createStore<T>(\r\n  listenersRef: React.RefObject<Set<() => void>>,\r\n  stateRef: React.RefObject<T>,\r\n  onValueChange?: Partial<{\r\n    [K in keyof T]: (value: T[K], store: Store<T>) => void;\r\n  }>\r\n): Store<T> {\r\n  const store: Store<T> = {\r\n    subscribe: (cb) => {\r\n      listenersRef.current.add(cb);\r\n      return () => listenersRef.current.delete(cb);\r\n    },\r\n    getState: () => stateRef.current,\r\n    setState: (key, value) => {\r\n      if (Object.is(stateRef.current[key], value)) return;\r\n      stateRef.current[key] = value;\r\n      onValueChange?.[key]?.(value, store);\r\n      store.notify();\r\n    },\r\n    notify: () => {\r\n      for (const cb of listenersRef.current) {\r\n        cb();\r\n      }\r\n    },\r\n  };\r\n\r\n  return store;\r\n}\r\n\r\nfunction useStoreSelector<T, U>(\r\n  store: Store<T>,\r\n  selector: (state: T) => U\r\n): U {\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector]\r\n  );\r\n\r\n  return React.useSyncExternalStore(\r\n    store.subscribe,\r\n    getSnapshot,\r\n    getSnapshot\r\n  );\r\n}\r\n\r\n/**\r\n * Generates a unique ID (simplified nanoid-like implementation)\r\n */\r\nfunction generateId(): string {\r\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Represents a single key-value pair entry.\r\n */\r\nexport interface KeyValueEntry {\r\n  id: string;\r\n  key: string;\r\n  value: string;\r\n}\r\n\r\ninterface KeyValueState {\r\n  entries: KeyValueEntry[];\r\n  focusedId: string | null;\r\n  errors: Record<string, { key?: string; value?: string }>;\r\n}\r\n\r\ninterface KeyValueRootContextValue {\r\n  store: Store<KeyValueState>;\r\n  id: string;\r\n  disabled: boolean;\r\n  readOnly: boolean;\r\n  required: boolean;\r\n  name?: string;\r\n  maxEntries?: number;\r\n  minEntries: number;\r\n  keyPlaceholder: string;\r\n  valuePlaceholder: string;\r\n  addButtonText: string;\r\n  showAddButton: boolean;\r\n  showRemoveButton: boolean;\r\n  allowDuplicateKeys: boolean;\r\n  enablePaste: boolean;\r\n  trim: boolean;\r\n  validateKey?: (key: string, entries: KeyValueEntry[]) => string | undefined;\r\n  validateValue?: (\r\n    value: string,\r\n    key: string,\r\n    entries: KeyValueEntry[]\r\n  ) => string | undefined;\r\n  onEntriesChange?: (entries: KeyValueEntry[]) => void;\r\n  onPaste?: (event: ClipboardEvent, entries: KeyValueEntry[]) => void;\r\n  onAdd?: (entry: KeyValueEntry) => void;\r\n  onRemove?: (entry: KeyValueEntry) => void;\r\n  addEntry: () => void;\r\n  removeEntry: (id: string) => void;\r\n  updateEntry: (id: string, updates: Partial<KeyValueEntry>) => void;\r\n}\r\n\r\nconst KeyValueRootContext =\r\n  React.createContext<KeyValueRootContextValue | null>(null);\r\n\r\nfunction useKeyValueRoot(componentName: string) {\r\n  const context = React.useContext(KeyValueRootContext);\r\n  if (!context) {\r\n    throw new Error(`${componentName} must be used within ${ROOT_NAME}`);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueRootProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  id?: string;\r\n  defaultEntries?: KeyValueEntry[];\r\n  entries?: KeyValueEntry[];\r\n  onEntriesChange?: (entries: KeyValueEntry[]) => void;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  name?: string;\r\n  maxEntries?: number;\r\n  minEntries?: number;\r\n  keyPlaceholder?: string;\r\n  valuePlaceholder?: string;\r\n  addButtonText?: string;\r\n  showAddButton?: boolean;\r\n  showRemoveButton?: boolean;\r\n  allowDuplicateKeys?: boolean;\r\n  enablePaste?: boolean;\r\n  onPaste?: (event: ClipboardEvent, entries: KeyValueEntry[]) => void;\r\n  onAdd?: (entry: KeyValueEntry) => void;\r\n  onRemove?: (entry: KeyValueEntry) => void;\r\n  validateKey?: (key: string, entries: KeyValueEntry[]) => string | undefined;\r\n  validateValue?: (\r\n    value: string,\r\n    key: string,\r\n    entries: KeyValueEntry[]\r\n  ) => string | undefined;\r\n  trim?: boolean;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueRoot(props: KeyValueRootProps) {\r\n  const {\r\n    id: idProp,\r\n    defaultEntries,\r\n    entries: entriesProp,\r\n    onEntriesChange,\r\n    disabled = false,\r\n    readOnly = false,\r\n    required = false,\r\n    name,\r\n    maxEntries,\r\n    minEntries = 0,\r\n    keyPlaceholder = \"Key\",\r\n    valuePlaceholder = \"Value\",\r\n    addButtonText = \"Add\",\r\n    showAddButton = true,\r\n    showRemoveButton = true,\r\n    allowDuplicateKeys = true,\r\n    enablePaste = true,\r\n    onPaste,\r\n    onAdd,\r\n    onRemove,\r\n    validateKey,\r\n    validateValue,\r\n    trim = true,\r\n    asChild,\r\n    className,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const generatedId = React.useId();\r\n  const id = idProp ?? generatedId;\r\n\r\n  const isControlled = entriesProp !== undefined;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = React.useRef<KeyValueState>({\r\n    entries:\r\n      entriesProp ??\r\n      defaultEntries ?? [{ id: generateId(), key: \"\", value: \"\" }],\r\n    focusedId: null,\r\n    errors: {},\r\n  });\r\n\r\n  const store = useLazyRef(() =>\r\n    createStore(listenersRef, stateRef, {\r\n      entries: (value) => {\r\n        onEntriesChange?.(value);\r\n      },\r\n    })\r\n  );\r\n\r\n  // Sync controlled entries\r\n  React.useEffect(() => {\r\n    if (isControlled && entriesProp) {\r\n      store.current.setState(\"entries\", entriesProp);\r\n    }\r\n  }, [entriesProp, isControlled, store]);\r\n\r\n  const validateEntry = React.useCallback(\r\n    (entry: KeyValueEntry, entries: KeyValueEntry[]) => {\r\n      const errors: { key?: string; value?: string } = {};\r\n\r\n      if (validateKey) {\r\n        const keyError = validateKey(entry.key, entries);\r\n        if (keyError) errors.key = keyError;\r\n      }\r\n\r\n      if (!allowDuplicateKeys) {\r\n        const duplicateKey = entries.find(\r\n          (e) => e.id !== entry.id && e.key === entry.key && entry.key !== \"\"\r\n        );\r\n        if (duplicateKey) {\r\n          errors.key = \"Duplicate key\";\r\n        }\r\n      }\r\n\r\n      if (validateValue) {\r\n        const valueError = validateValue(entry.value, entry.key, entries);\r\n        if (valueError) errors.value = valueError;\r\n      }\r\n\r\n      return Object.keys(errors).length > 0 ? errors : undefined;\r\n    },\r\n    [validateKey, validateValue, allowDuplicateKeys]\r\n  );\r\n\r\n  const addEntry = React.useCallback(() => {\r\n    const state = store.current.getState();\r\n    if (maxEntries !== undefined && state.entries.length >= maxEntries) {\r\n      return;\r\n    }\r\n\r\n    const newEntry: KeyValueEntry = {\r\n      id: generateId(),\r\n      key: \"\",\r\n      value: \"\",\r\n    };\r\n\r\n    const newEntries = [...state.entries, newEntry];\r\n    store.current.setState(\"entries\", newEntries);\r\n    store.current.setState(\"focusedId\", newEntry.id);\r\n    onAdd?.(newEntry);\r\n  }, [store, maxEntries, onAdd]);\r\n\r\n  const removeEntry = React.useCallback(\r\n    (id: string) => {\r\n      const state = store.current.getState();\r\n      if (state.entries.length <= minEntries) {\r\n        return;\r\n      }\r\n\r\n      const entryToRemove = state.entries.find((e) => e.id === id);\r\n      if (!entryToRemove) return;\r\n\r\n      const newEntries = state.entries.filter((entry) => entry.id !== id);\r\n      const newErrors = { ...state.errors };\r\n      delete newErrors[id];\r\n\r\n      store.current.setState(\"entries\", newEntries);\r\n      store.current.setState(\"errors\", newErrors);\r\n      onRemove?.(entryToRemove);\r\n    },\r\n    [store, minEntries, onRemove]\r\n  );\r\n\r\n  const updateEntry = React.useCallback(\r\n    (id: string, updates: Partial<KeyValueEntry>) => {\r\n      const state = store.current.getState();\r\n      const newEntries = state.entries.map((entry) => {\r\n        if (entry.id !== id) return entry;\r\n\r\n        const updated = { ...entry, ...updates };\r\n        if (trim) {\r\n          if (updates.key !== undefined) updated.key = updated.key.trim();\r\n          if (updates.value !== undefined)\r\n            updated.value = updated.value.trim();\r\n        }\r\n        return updated;\r\n      });\r\n\r\n      store.current.setState(\"entries\", newEntries);\r\n\r\n      // Validate the updated entry\r\n      const updatedEntry = newEntries.find((e) => e.id === id);\r\n      if (updatedEntry) {\r\n        const errors = validateEntry(updatedEntry, newEntries);\r\n        const newErrorsState = { ...state.errors };\r\n        if (errors) {\r\n          newErrorsState[id] = errors;\r\n        } else {\r\n          delete newErrorsState[id];\r\n        }\r\n        store.current.setState(\"errors\", newErrorsState);\r\n      }\r\n    },\r\n    [store, validateEntry, trim]\r\n  );\r\n\r\n  const Comp = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <KeyValueRootContext.Provider\r\n      value={{\r\n        store: store.current,\r\n        id,\r\n        disabled,\r\n        readOnly,\r\n        required,\r\n        name,\r\n        maxEntries,\r\n        minEntries,\r\n        keyPlaceholder,\r\n        valuePlaceholder,\r\n        addButtonText,\r\n        showAddButton,\r\n        showRemoveButton,\r\n        allowDuplicateKeys,\r\n        enablePaste,\r\n        trim,\r\n        validateKey,\r\n        validateValue,\r\n        onEntriesChange,\r\n        onPaste,\r\n        onAdd,\r\n        onRemove,\r\n        addEntry,\r\n        removeEntry,\r\n        updateEntry,\r\n      }}\r\n    >\r\n      <Comp\r\n        {...rootProps}\r\n        className={cn(\"space-y-2\", className)}\r\n        data-disabled={disabled ? \"\" : undefined}\r\n        data-readonly={readOnly ? \"\" : undefined}\r\n      >\r\n        {props.children}\r\n      </Comp>\r\n      {name && (\r\n        <input\r\n          type=\"hidden\"\r\n          name={name}\r\n          value={JSON.stringify(stateRef.current.entries)}\r\n        />\r\n      )}\r\n    </KeyValueRootContext.Provider>\r\n  );\r\n}\r\n\r\nKeyValueRoot.displayName = ROOT_NAME;\r\n\r\ninterface KeyValueListProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  orientation?: \"vertical\" | \"horizontal\";\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueList(props: KeyValueListProps) {\r\n  const { orientation = \"vertical\", asChild, className, ...listProps } = props;\r\n  const context = useKeyValueRoot(LIST_NAME);\r\n\r\n  const entries = useStoreSelector(context.store, (state) => state.entries);\r\n\r\n  const Comp = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <Comp\r\n      {...listProps}\r\n      role=\"list\"\r\n      aria-label=\"Key-value pairs\"\r\n      className={cn(\r\n        \"flex\",\r\n        orientation === \"vertical\" ? \"flex-col gap-2\" : \"flex-row gap-2\",\r\n        className\r\n      )}\r\n      data-orientation={orientation}\r\n    >\r\n      {entries.map((entry) => {\r\n        const children = React.Children.toArray(props.children);\r\n        return (\r\n          <KeyValueItemContext.Provider key={entry.id} value={{ entry }}>\r\n            {children}\r\n          </KeyValueItemContext.Provider>\r\n        );\r\n      })}\r\n    </Comp>\r\n  );\r\n}\r\n\r\nKeyValueList.displayName = LIST_NAME;\r\n\r\ninterface KeyValueItemContextValue {\r\n  entry: KeyValueEntry;\r\n}\r\n\r\nconst KeyValueItemContext =\r\n  React.createContext<KeyValueItemContextValue | null>(null);\r\n\r\nfunction useKeyValueItem(componentName: string) {\r\n  const context = React.useContext(KeyValueItemContext);\r\n  if (!context) {\r\n    throw new Error(`${componentName} must be used within ${LIST_NAME}`);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueItemProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueItem(props: KeyValueItemProps) {\r\n  const { asChild, className, ...itemProps } = props;\r\n  const { entry } = useKeyValueItem(ITEM_NAME);\r\n  const context = useKeyValueRoot(ITEM_NAME);\r\n\r\n  const focusedId = useStoreSelector(context.store, (state) => state.focusedId);\r\n\r\n  const Comp = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <Comp\r\n      {...itemProps}\r\n      role=\"listitem\"\r\n      className={cn(\"flex items-start gap-2\", className)}\r\n      data-focused={focusedId === entry.id ? \"\" : undefined}\r\n    >\r\n      {props.children}\r\n    </Comp>\r\n  );\r\n}\r\n\r\nKeyValueItem.displayName = ITEM_NAME;\r\n\r\ninterface KeyValueKeyInputProps\r\n  extends React.ComponentPropsWithoutRef<\"input\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueKeyInput(props: KeyValueKeyInputProps) {\r\n  const { asChild, className, onPaste: onPasteProp, ...inputProps } = props;\r\n  const { entry } = useKeyValueItem(KEY_INPUT_NAME);\r\n  const context = useKeyValueRoot(KEY_INPUT_NAME);\r\n\r\n  const errors = useStoreSelector(context.store, (state) => state.errors);\r\n  const hasError = errors[entry.id]?.key !== undefined;\r\n\r\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    context.updateEntry(entry.id, { key: e.target.value });\r\n    inputProps.onChange?.(e);\r\n  };\r\n\r\n  const parsePastedContent = React.useCallback(\r\n    (content: string): KeyValueEntry[] => {\r\n      const lines = content.split(/\\r?\\n/).filter((line) => line.trim());\r\n      const parsed: KeyValueEntry[] = [];\r\n\r\n      for (const line of lines) {\r\n        let key = \"\";\r\n        let value = \"\";\r\n\r\n        // Try KEY=VALUE format\r\n        if (line.includes(\"=\")) {\r\n          const parts = line.split(\"=\");\r\n          key = parts[0].trim();\r\n          value = parts.slice(1).join(\"=\").trim();\r\n        }\r\n        // Try KEY: VALUE format\r\n        else if (line.includes(\":\")) {\r\n          const parts = line.split(\":\");\r\n          key = parts[0].trim();\r\n          value = parts.slice(1).join(\":\").trim();\r\n        }\r\n        // Try KEY VALUE (tab or multiple spaces)\r\n        else if (/\\s{2,}|\\t/.test(line)) {\r\n          const parts = line.split(/\\s{2,}|\\t/);\r\n          key = parts[0].trim();\r\n          value = parts.slice(1).join(\" \").trim();\r\n        }\r\n\r\n        if (key) {\r\n          parsed.push({ id: generateId(), key, value });\r\n        }\r\n      }\r\n\r\n      return parsed;\r\n    },\r\n    []\r\n  );\r\n\r\n  const onPaste = (e: React.ClipboardEvent<HTMLInputElement>) => {\r\n    if (!context.enablePaste) {\r\n      onPasteProp?.(e);\r\n      return;\r\n    }\r\n\r\n    const content = e.clipboardData.getData(\"text\");\r\n    const lines = content.split(/\\r?\\n/).filter((line) => line.trim());\r\n\r\n    // Only handle paste if multiple lines\r\n    if (lines.length > 1) {\r\n      e.preventDefault();\r\n\r\n      const parsedEntries = parsePastedContent(content);\r\n\r\n      if (parsedEntries.length > 0) {\r\n        const state = context.store.getState();\r\n        const currentIndex = state.entries.findIndex((e) => e.id === entry.id);\r\n\r\n        // Replace current empty entry or add after current entry\r\n        let newEntries: KeyValueEntry[];\r\n        if (entry.key === \"\" && entry.value === \"\") {\r\n          // Replace current empty entry with first parsed entry\r\n          newEntries = [\r\n            ...state.entries.slice(0, currentIndex),\r\n            ...parsedEntries,\r\n            ...state.entries.slice(currentIndex + 1),\r\n          ];\r\n        } else {\r\n          // Add after current entry\r\n          newEntries = [\r\n            ...state.entries.slice(0, currentIndex + 1),\r\n            ...parsedEntries,\r\n            ...state.entries.slice(currentIndex + 1),\r\n          ];\r\n        }\r\n\r\n        // Respect maxEntries\r\n        if (context.maxEntries !== undefined) {\r\n          newEntries = newEntries.slice(0, context.maxEntries);\r\n        }\r\n\r\n        context.store.setState(\"entries\", newEntries);\r\n\r\n        // Notify paste callback\r\n        if (context.onPaste) {\r\n          context.onPaste(\r\n            e.nativeEvent as unknown as ClipboardEvent,\r\n            parsedEntries\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    onPasteProp?.(e);\r\n  };\r\n\r\n  const Comp = asChild ? Slot : \"input\";\r\n\r\n  return (\r\n    <Comp\r\n      type=\"text\"\r\n      {...inputProps}\r\n      value={entry.key}\r\n      onChange={onChange}\r\n      onPaste={onPaste}\r\n      placeholder={context.keyPlaceholder}\r\n      disabled={context.disabled}\r\n      readOnly={context.readOnly}\r\n      required={context.required}\r\n      aria-label={`Key for entry ${entry.id}`}\r\n      aria-invalid={hasError}\r\n      aria-describedby={hasError ? `${context.id}-${entry.id}-key-error` : undefined}\r\n      className={cn(\r\n        \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n        hasError && \"border-destructive focus-visible:ring-destructive\",\r\n        className\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nKeyValueKeyInput.displayName = KEY_INPUT_NAME;\r\n\r\ninterface KeyValueValueInputProps\r\n  extends React.ComponentPropsWithoutRef<\"input\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueValueInput(props: KeyValueValueInputProps) {\r\n  const { asChild, className, ...inputProps } = props;\r\n  const { entry } = useKeyValueItem(VALUE_INPUT_NAME);\r\n  const context = useKeyValueRoot(VALUE_INPUT_NAME);\r\n\r\n  const errors = useStoreSelector(context.store, (state) => state.errors);\r\n  const hasError = errors[entry.id]?.value !== undefined;\r\n\r\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    context.updateEntry(entry.id, { value: e.target.value });\r\n    inputProps.onChange?.(e);\r\n  };\r\n\r\n  const Comp = asChild ? Slot : \"input\";\r\n\r\n  return (\r\n    <Comp\r\n      type=\"text\"\r\n      {...inputProps}\r\n      value={entry.value}\r\n      onChange={onChange}\r\n      placeholder={context.valuePlaceholder}\r\n      disabled={context.disabled}\r\n      readOnly={context.readOnly}\r\n      aria-label={`Value for ${entry.key || \"entry \" + entry.id}`}\r\n      aria-invalid={hasError}\r\n      aria-describedby={\r\n        hasError ? `${context.id}-${entry.id}-value-error` : undefined\r\n      }\r\n      className={cn(\r\n        \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n        hasError && \"border-destructive focus-visible:ring-destructive\",\r\n        className\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nKeyValueValueInput.displayName = VALUE_INPUT_NAME;\r\n\r\ninterface KeyValueRemoveButtonProps\r\n  extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueRemoveButton(props: KeyValueRemoveButtonProps) {\r\n  const { asChild, className, children, ...buttonProps } = props;\r\n  const { entry } = useKeyValueItem(REMOVE_BUTTON_NAME);\r\n  const context = useKeyValueRoot(REMOVE_BUTTON_NAME);\r\n\r\n  const entries = useStoreSelector(context.store, (state) => state.entries);\r\n  const isDisabled =\r\n    context.disabled || entries.length <= context.minEntries;\r\n\r\n  const onClick = (e: React.MouseEvent<HTMLButtonElement>) => {\r\n    context.removeEntry(entry.id);\r\n    buttonProps.onClick?.(e);\r\n  };\r\n\r\n  const Comp = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <Comp\r\n      type=\"button\"\r\n      {...buttonProps}\r\n      onClick={onClick}\r\n      disabled={isDisabled}\r\n      aria-label={`Remove ${entry.key || \"entry\"}`}\r\n      className={cn(\r\n        \"inline-flex h-9 w-9 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n        \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\r\n        className\r\n      )}\r\n    >\r\n      {children ?? <XIcon />}\r\n    </Comp>\r\n  );\r\n}\r\n\r\nKeyValueRemoveButton.displayName = REMOVE_BUTTON_NAME;\r\n\r\ninterface KeyValueAddButtonProps\r\n  extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueAddButton(props: KeyValueAddButtonProps) {\r\n  const { asChild, className, children, ...buttonProps } = props;\r\n  const context = useKeyValueRoot(ADD_BUTTON_NAME);\r\n\r\n  const entries = useStoreSelector(context.store, (state) => state.entries);\r\n  const isDisabled =\r\n    context.disabled ||\r\n    (context.maxEntries !== undefined &&\r\n      entries.length >= context.maxEntries);\r\n\r\n  const onClick = (e: React.MouseEvent<HTMLButtonElement>) => {\r\n    context.addEntry();\r\n    buttonProps.onClick?.(e);\r\n  };\r\n\r\n  const Comp = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <Comp\r\n      type=\"button\"\r\n      {...buttonProps}\r\n      onClick={onClick}\r\n      disabled={isDisabled}\r\n      aria-label=\"Add new entry\"\r\n      className={cn(\r\n        \"inline-flex h-9 items-center justify-center gap-2 whitespace-nowrap rounded-md px-4 text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n        \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\r\n        className\r\n      )}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <PlusIcon />\r\n          {context.addButtonText}\r\n        </>\r\n      )}\r\n    </Comp>\r\n  );\r\n}\r\n\r\nKeyValueAddButton.displayName = ADD_BUTTON_NAME;\r\n\r\ninterface KeyValueErrorProps extends React.ComponentPropsWithoutRef<\"span\"> {\r\n  field: \"key\" | \"value\";\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueError(props: KeyValueErrorProps) {\r\n  const { field, asChild, className, ...errorProps } = props;\r\n  const { entry } = useKeyValueItem(ERROR_NAME);\r\n  const context = useKeyValueRoot(ERROR_NAME);\r\n\r\n  const errors = useStoreSelector(context.store, (state) => state.errors);\r\n  const error = errors[entry.id]?.[field];\r\n\r\n  if (!error) return null;\r\n\r\n  const Comp = asChild ? Slot : \"span\";\r\n\r\n  return (\r\n    <Comp\r\n      {...errorProps}\r\n      id={`${context.id}-${entry.id}-${field}-error`}\r\n      role=\"alert\"\r\n      className={cn(\"text-sm font-medium text-destructive\", className)}\r\n    >\r\n      {error}\r\n    </Comp>\r\n  );\r\n}\r\n\r\nKeyValueError.displayName = ERROR_NAME;\r\n\r\nexport {\r\n  KeyValueRoot as KeyValue,\r\n  KeyValueList,\r\n  KeyValueItem,\r\n  KeyValueKeyInput,\r\n  KeyValueValueInput,\r\n  KeyValueRemoveButton,\r\n  KeyValueAddButton,\r\n  KeyValueError,\r\n  //\r\n  KeyValueRoot as Root,\r\n  KeyValueList as List,\r\n  KeyValueItem as Item,\r\n  KeyValueKeyInput as KeyInput,\r\n  KeyValueValueInput as ValueInput,\r\n  KeyValueRemoveButton as RemoveButton,\r\n  KeyValueAddButton as AddButton,\r\n  KeyValueError as Error,\r\n};\r\n\r\nexport type {\r\n  KeyValueEntry,\r\n  KeyValueRootProps as KeyValueProps,\r\n  KeyValueListProps,\r\n  KeyValueItemProps,\r\n  KeyValueKeyInputProps,\r\n  KeyValueValueInputProps,\r\n  KeyValueRemoveButtonProps,\r\n  KeyValueAddButtonProps,\r\n  KeyValueErrorProps,\r\n};\r\n\r\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}