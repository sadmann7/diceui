{
  "name": "key-value",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/key-value.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { PlusIcon, XIcon } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"KeyValue\";\r\nconst LIST_NAME = \"KeyValueList\";\r\nconst ITEM_NAME = \"KeyValueItem\";\r\nconst KEY_INPUT_NAME = \"KeyValueKeyInput\";\r\nconst VALUE_INPUT_NAME = \"KeyValueValueInput\";\r\nconst REMOVE_BUTTON_NAME = \"KeyValueRemoveButton\";\r\nconst ADD_BUTTON_NAME = \"KeyValueAddButton\";\r\nconst ERROR_NAME = \"KeyValueError\";\r\n\r\ntype KeyInputElement = React.ComponentRef<\"input\">;\r\ntype ValueInputElement = React.ComponentRef<\"input\">;\r\ntype RemoveButtonElement = React.ComponentRef<\"button\">;\r\ntype AddButtonElement = React.ComponentRef<\"button\">;\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\r\n\r\nfunction useAsRef<T>(props: T) {\r\n  const ref = React.useRef<T>(props);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = props;\r\n  });\r\n\r\n  return ref;\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\ninterface Store<T> {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => T;\r\n  setState: <K extends keyof T>(key: K, value: T[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: KeyValueState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface KeyValueEntry {\r\n  id: string;\r\n  key: string;\r\n  value: string;\r\n}\r\n\r\ninterface KeyValueState {\r\n  value: KeyValueEntry[];\r\n  focusedId: string | null;\r\n  errors: Record<string, { key?: string; value?: string }>;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store<KeyValueState> | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueContextValue {\r\n  id: string;\r\n  disabled: boolean;\r\n  readOnly: boolean;\r\n  required: boolean;\r\n  name?: string;\r\n  maxEntries?: number;\r\n  minEntries: number;\r\n  keyPlaceholder: string;\r\n  valuePlaceholder: string;\r\n  addButtonText: string;\r\n  showAddButton: boolean;\r\n  showRemoveButton: boolean;\r\n  allowDuplicateKeys: boolean;\r\n  enablePaste: boolean;\r\n  trim: boolean;\r\n}\r\n\r\nconst KeyValueContext = React.createContext<KeyValueContextValue | null>(null);\r\n\r\nfunction useKeyValueContext(consumerName: string) {\r\n  const context = React.useContext(KeyValueContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueRootProps\r\n  extends Omit<React.ComponentProps<\"div\">, \"onPaste\" | \"defaultValue\"> {\r\n  id?: string;\r\n  defaultValue?: KeyValueEntry[];\r\n  value?: KeyValueEntry[];\r\n  onValueChange?: (value: KeyValueEntry[]) => void;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  name?: string;\r\n  maxEntries?: number;\r\n  minEntries?: number;\r\n  keyPlaceholder?: string;\r\n  valuePlaceholder?: string;\r\n  addButtonText?: string;\r\n  showAddButton?: boolean;\r\n  showRemoveButton?: boolean;\r\n  allowDuplicateKeys?: boolean;\r\n  enablePaste?: boolean;\r\n  onPaste?: (event: ClipboardEvent, entries: KeyValueEntry[]) => void;\r\n  onAdd?: (entry: KeyValueEntry) => void;\r\n  onRemove?: (entry: KeyValueEntry) => void;\r\n  validateKey?: (key: string, value: KeyValueEntry[]) => string | undefined;\r\n  validateValue?: (\r\n    value: string,\r\n    key: string,\r\n    entries: KeyValueEntry[],\r\n  ) => string | undefined;\r\n  trim?: boolean;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueRoot(props: KeyValueRootProps) {\r\n  const {\r\n    id: idProp,\r\n    defaultValue,\r\n    value: valueProp,\r\n    onValueChange,\r\n    disabled = false,\r\n    readOnly = false,\r\n    required = false,\r\n    name,\r\n    maxEntries,\r\n    minEntries = 0,\r\n    keyPlaceholder = \"Key\",\r\n    valuePlaceholder = \"Value\",\r\n    addButtonText = \"Add\",\r\n    showAddButton = true,\r\n    showRemoveButton = true,\r\n    allowDuplicateKeys = true,\r\n    enablePaste = true,\r\n    onPaste,\r\n    onAdd,\r\n    onRemove,\r\n    validateKey,\r\n    validateValue,\r\n    trim = true,\r\n    asChild,\r\n    className,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const generatedId = React.useId();\r\n  const id = idProp ?? generatedId;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<KeyValueState>(() => ({\r\n    value: valueProp ??\r\n      defaultValue ?? [{ id: crypto.randomUUID(), key: \"\", value: \"\" }],\r\n    focusedId: null,\r\n    errors: {},\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onValueChange,\r\n    onPaste,\r\n    onAdd,\r\n    onRemove,\r\n    validateKey,\r\n    validateValue,\r\n    allowDuplicateKeys,\r\n    trim,\r\n    maxEntries,\r\n    minEntries,\r\n  });\r\n\r\n  const store = React.useMemo<Store<KeyValueState>>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, val) => {\r\n        if (Object.is(stateRef.current[key], val)) return;\r\n\r\n        stateRef.current[key] = val;\r\n\r\n        if (key === \"value\") {\r\n          propsRef.current.onValueChange?.(val as KeyValueEntry[]);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp]);\r\n\r\n  const contextValue = React.useMemo<KeyValueContextValue>(\r\n    () => ({\r\n      id,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      name,\r\n      maxEntries,\r\n      minEntries,\r\n      keyPlaceholder,\r\n      valuePlaceholder,\r\n      addButtonText,\r\n      showAddButton,\r\n      showRemoveButton,\r\n      allowDuplicateKeys,\r\n      enablePaste,\r\n      trim,\r\n    }),\r\n    [\r\n      id,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      name,\r\n      maxEntries,\r\n      minEntries,\r\n      keyPlaceholder,\r\n      valuePlaceholder,\r\n      addButtonText,\r\n      showAddButton,\r\n      showRemoveButton,\r\n      allowDuplicateKeys,\r\n      enablePaste,\r\n      trim,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <KeyValueContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          {...rootProps}\r\n          className={cn(\"flex flex-col gap-2\", className)}\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-readonly={readOnly ? \"\" : undefined}\r\n        >\r\n          {rootProps.children}\r\n        </RootPrimitive>\r\n        {name && (\r\n          <input\r\n            type=\"hidden\"\r\n            name={name}\r\n            value={JSON.stringify(stateRef.current.value)}\r\n          />\r\n        )}\r\n      </KeyValueContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface KeyValueListProps extends React.ComponentProps<\"div\"> {\r\n  orientation?: \"vertical\" | \"horizontal\";\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueList(props: KeyValueListProps) {\r\n  const { orientation = \"vertical\", asChild, className, ...listProps } = props;\r\n\r\n  const value = useStore((state) => state.value);\r\n\r\n  const ListPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ListPrimitive\r\n      {...listProps}\r\n      role=\"list\"\r\n      aria-label=\"Key-value pairs\"\r\n      className={cn(\r\n        \"flex\",\r\n        orientation === \"vertical\" ? \"flex-col gap-2\" : \"flex-row gap-2\",\r\n        className,\r\n      )}\r\n      data-orientation={orientation}\r\n    >\r\n      {value.map((entry) => {\r\n        const children = React.Children.toArray(props.children);\r\n        return (\r\n          <KeyValueItemContext.Provider key={entry.id} value={{ entry }}>\r\n            {children}\r\n          </KeyValueItemContext.Provider>\r\n        );\r\n      })}\r\n    </ListPrimitive>\r\n  );\r\n}\r\n\r\ninterface KeyValueItemContextValue {\r\n  entry: KeyValueEntry;\r\n}\r\n\r\nconst KeyValueItemContext =\r\n  React.createContext<KeyValueItemContextValue | null>(null);\r\n\r\nfunction useKeyValueItemContext(consumerName: string) {\r\n  const context = React.useContext(KeyValueItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${LIST_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueItemProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueItem(props: KeyValueItemProps) {\r\n  const { asChild, className, ...itemProps } = props;\r\n  const { entry } = useKeyValueItemContext(ITEM_NAME);\r\n\r\n  const focusedId = useStore((state) => state.focusedId);\r\n\r\n  const ItemPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ItemPrimitive\r\n      {...itemProps}\r\n      role=\"listitem\"\r\n      className={cn(\"flex items-start gap-2\", className)}\r\n      data-focused={focusedId === entry.id ? \"\" : undefined}\r\n    >\r\n      {props.children}\r\n    </ItemPrimitive>\r\n  );\r\n}\r\n\r\ninterface KeyValueKeyInputProps extends React.ComponentProps<\"input\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueKeyInput(props: KeyValueKeyInputProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    validateKey,\r\n    validateValue,\r\n    onChange: onChangeProp,\r\n    onPaste: onPasteProp,\r\n    ...inputProps\r\n  } = props as KeyValueKeyInputProps &\r\n    Pick<KeyValueRootProps, \"validateKey\" | \"validateValue\" | \"onPaste\">;\r\n  const { entry } = useKeyValueItemContext(KEY_INPUT_NAME);\r\n  const context = useKeyValueContext(KEY_INPUT_NAME);\r\n  const store = useStoreContext(KEY_INPUT_NAME);\r\n\r\n  const errors = useStore((state) => state.errors);\r\n  const hasError = errors[entry.id]?.key !== undefined;\r\n\r\n  const propsRef = useAsRef({\r\n    validateKey,\r\n    validateValue,\r\n    onChange: onChangeProp,\r\n    onPaste: onPasteProp,\r\n  });\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<KeyInputElement>) => {\r\n      const state = store.getState();\r\n      const newValue = state.value.map((item) => {\r\n        if (item.id !== entry.id) return item;\r\n        const updated = { ...item, key: event.target.value };\r\n        if (context.trim) updated.key = updated.key.trim();\r\n        return updated;\r\n      });\r\n\r\n      store.setState(\"value\", newValue);\r\n\r\n      const updatedEntry = newValue.find((item) => item.id === entry.id);\r\n      if (updatedEntry) {\r\n        const errors: { key?: string; value?: string } = {};\r\n\r\n        if (propsRef.current.validateKey) {\r\n          const keyError = propsRef.current.validateKey(\r\n            updatedEntry.key,\r\n            newValue,\r\n          );\r\n          if (keyError) errors.key = keyError;\r\n        }\r\n\r\n        if (!context.allowDuplicateKeys) {\r\n          const duplicateKey = newValue.find(\r\n            (item) =>\r\n              item.id !== updatedEntry.id &&\r\n              item.key === updatedEntry.key &&\r\n              updatedEntry.key !== \"\",\r\n          );\r\n          if (duplicateKey) {\r\n            errors.key = \"Duplicate key\";\r\n          }\r\n        }\r\n\r\n        if (propsRef.current.validateValue) {\r\n          const valueError = propsRef.current.validateValue(\r\n            updatedEntry.value,\r\n            updatedEntry.key,\r\n            newValue,\r\n          );\r\n          if (valueError) errors.value = valueError;\r\n        }\r\n\r\n        const newErrorsState = { ...state.errors };\r\n        if (Object.keys(errors).length > 0) {\r\n          newErrorsState[entry.id] = errors;\r\n        } else {\r\n          delete newErrorsState[entry.id];\r\n        }\r\n        store.setState(\"errors\", newErrorsState);\r\n      }\r\n\r\n      propsRef.current.onChange?.(event);\r\n    },\r\n    [store, entry.id, context.trim, context.allowDuplicateKeys, propsRef],\r\n  );\r\n\r\n  const onPaste = React.useCallback(\r\n    (event: React.ClipboardEvent<KeyInputElement>) => {\r\n      if (!context.enablePaste) return;\r\n\r\n      const content = event.clipboardData.getData(\"text\");\r\n      const lines = content.split(/\\r?\\n/).filter((line) => line.trim());\r\n\r\n      // Only handle paste if multiple lines\r\n      if (lines.length > 1) {\r\n        event.preventDefault();\r\n\r\n        const parsed: KeyValueEntry[] = [];\r\n\r\n        for (const line of lines) {\r\n          let key = \"\";\r\n          let value = \"\";\r\n\r\n          // Try KEY=VALUE format\r\n          if (line.includes(\"=\")) {\r\n            const parts = line.split(\"=\");\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = parts.slice(1).join(\"=\").trim();\r\n          }\r\n          // Try KEY: VALUE format\r\n          else if (line.includes(\":\")) {\r\n            const parts = line.split(\":\");\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = parts.slice(1).join(\":\").trim();\r\n          }\r\n          // Try KEY VALUE (tab or multiple spaces)\r\n          else if (/\\s{2,}|\\t/.test(line)) {\r\n            const parts = line.split(/\\s{2,}|\\t/);\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = parts.slice(1).join(\" \").trim();\r\n          }\r\n\r\n          if (key) {\r\n            parsed.push({ id: crypto.randomUUID(), key, value });\r\n          }\r\n        }\r\n\r\n        if (parsed.length > 0) {\r\n          const state = store.getState();\r\n          const currentIndex = state.value.findIndex(\r\n            (item) => item.id === entry.id,\r\n          );\r\n\r\n          // Replace current empty entry or add after current entry\r\n          let newValue: KeyValueEntry[];\r\n          if (entry.key === \"\" && entry.value === \"\") {\r\n            newValue = [\r\n              ...state.value.slice(0, currentIndex),\r\n              ...parsed,\r\n              ...state.value.slice(currentIndex + 1),\r\n            ];\r\n          } else {\r\n            newValue = [\r\n              ...state.value.slice(0, currentIndex + 1),\r\n              ...parsed,\r\n              ...state.value.slice(currentIndex + 1),\r\n            ];\r\n          }\r\n\r\n          // Respect maxEntries\r\n          if (context.maxEntries !== undefined) {\r\n            newValue = newValue.slice(0, context.maxEntries);\r\n          }\r\n\r\n          store.setState(\"value\", newValue);\r\n\r\n          // Notify paste callback\r\n          if (propsRef.current.onPaste) {\r\n            propsRef.current.onPaste(\r\n              event.nativeEvent as unknown as ClipboardEvent,\r\n              parsed,\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [\r\n      context.enablePaste,\r\n      context.maxEntries,\r\n      store,\r\n      entry.id,\r\n      entry.key,\r\n      entry.value,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const KeyInputPrimitive = asChild ? Slot : \"input\";\r\n\r\n  return (\r\n    <KeyInputPrimitive\r\n      type=\"text\"\r\n      {...inputProps}\r\n      value={entry.key}\r\n      onChange={onChange}\r\n      onPaste={onPaste}\r\n      placeholder={context.keyPlaceholder}\r\n      disabled={context.disabled}\r\n      readOnly={context.readOnly}\r\n      required={context.required}\r\n      aria-label={`Key for entry ${entry.id}`}\r\n      aria-invalid={hasError}\r\n      aria-describedby={\r\n        hasError ? `${context.id}-${entry.id}-key-error` : undefined\r\n      }\r\n      className={cn(\r\n        \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n        hasError && \"border-destructive focus-visible:ring-destructive\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueValueInputProps\r\n  extends React.ComponentProps<\"input\">,\r\n    Pick<KeyValueRootProps, \"validateKey\" | \"validateValue\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueValueInput(props: KeyValueValueInputProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    validateKey,\r\n    validateValue,\r\n    onChange: onChangeProp,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const { entry } = useKeyValueItemContext(VALUE_INPUT_NAME);\r\n  const context = useKeyValueContext(VALUE_INPUT_NAME);\r\n  const store = useStoreContext(VALUE_INPUT_NAME);\r\n\r\n  const propsRef = useAsRef({\r\n    validateKey,\r\n    validateValue,\r\n    onChange: onChangeProp,\r\n  });\r\n  const errors = useStore((state) => state.errors);\r\n  const hasError = errors[entry.id]?.value !== undefined;\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<ValueInputElement>) => {\r\n      propsRef.current.onChange?.(event);\r\n\r\n      const state = store.getState();\r\n      const newValue = state.value.map((item: KeyValueEntry) => {\r\n        if (item.id !== entry.id) return item;\r\n        const updated = { ...item, value: event.target.value };\r\n        if (context.trim) updated.value = updated.value.trim();\r\n        return updated;\r\n      });\r\n\r\n      store.setState(\"value\", newValue);\r\n\r\n      const updatedEntry = newValue.find(\r\n        (item: KeyValueEntry) => item.id === entry.id,\r\n      );\r\n      if (updatedEntry) {\r\n        const errors: { key?: string; value?: string } = {};\r\n\r\n        if (propsRef.current.validateKey) {\r\n          const keyError = propsRef.current.validateKey(\r\n            updatedEntry.key,\r\n            newValue,\r\n          );\r\n          if (keyError) errors.key = keyError;\r\n        }\r\n\r\n        if (!context.allowDuplicateKeys) {\r\n          const duplicateKey = newValue.find(\r\n            (item: KeyValueEntry) =>\r\n              item.id !== updatedEntry.id &&\r\n              item.key === updatedEntry.key &&\r\n              updatedEntry.key !== \"\",\r\n          );\r\n          if (duplicateKey) {\r\n            errors.key = \"Duplicate key\";\r\n          }\r\n        }\r\n\r\n        if (propsRef.current.validateValue) {\r\n          const valueError = propsRef.current.validateValue(\r\n            updatedEntry.value,\r\n            updatedEntry.key,\r\n            newValue,\r\n          );\r\n          if (valueError) errors.value = valueError;\r\n        }\r\n\r\n        const newErrorsState = { ...state.errors };\r\n        if (Object.keys(errors).length > 0) {\r\n          newErrorsState[entry.id] = errors;\r\n        } else {\r\n          delete newErrorsState[entry.id];\r\n        }\r\n        store.setState(\"errors\", newErrorsState);\r\n      }\r\n    },\r\n    [store, entry.id, context.trim, context.allowDuplicateKeys, propsRef],\r\n  );\r\n\r\n  const ValueInputPrimitive = asChild ? Slot : \"input\";\r\n\r\n  return (\r\n    <ValueInputPrimitive\r\n      type=\"text\"\r\n      {...inputProps}\r\n      value={entry.value}\r\n      onChange={onChange}\r\n      placeholder={context.valuePlaceholder}\r\n      disabled={context.disabled}\r\n      readOnly={context.readOnly}\r\n      aria-label={`Value for ${entry.key || `entry ${entry.id}`}`}\r\n      aria-invalid={hasError}\r\n      aria-describedby={\r\n        hasError ? `${context.id}-${entry.id}-value-error` : undefined\r\n      }\r\n      className={cn(\r\n        \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n        hasError && \"border-destructive focus-visible:ring-destructive\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueRemoveButtonProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueRemoveButton(props: KeyValueRemoveButtonProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    children,\r\n    onClick: onClickProp,\r\n    onRemove,\r\n    ...buttonProps\r\n  } = props as KeyValueRemoveButtonProps & Pick<KeyValueRootProps, \"onRemove\">;\r\n  const { entry } = useKeyValueItemContext(REMOVE_BUTTON_NAME);\r\n  const context = useKeyValueContext(REMOVE_BUTTON_NAME);\r\n  const store = useStoreContext(REMOVE_BUTTON_NAME);\r\n\r\n  const propsRef = useAsRef({ onClick: onClickProp, onRemove });\r\n  const value = useStore((state) => state.value);\r\n  const isDisabled = context.disabled || value.length <= context.minEntries;\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<RemoveButtonElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n\r\n      const state = store.getState();\r\n      if (state.value.length <= context.minEntries) return;\r\n\r\n      const entryToRemove = state.value.find(\r\n        (item: KeyValueEntry) => item.id === entry.id,\r\n      );\r\n      if (!entryToRemove) return;\r\n\r\n      const newValue = state.value.filter(\r\n        (item: KeyValueEntry) => item.id !== entry.id,\r\n      );\r\n      const newErrors = { ...state.errors };\r\n      delete newErrors[entry.id];\r\n\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"errors\", newErrors);\r\n\r\n      propsRef.current.onRemove?.(entryToRemove);\r\n    },\r\n    [store, context.minEntries, entry.id, propsRef],\r\n  );\r\n\r\n  const RemoveButtonPrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <RemoveButtonPrimitive\r\n      type=\"button\"\r\n      {...buttonProps}\r\n      onClick={onClick}\r\n      disabled={isDisabled}\r\n      aria-label={`Remove ${entry.key || \"entry\"}`}\r\n      className={cn(\r\n        \"inline-flex h-9 w-9 items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium text-sm transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n        \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\r\n        className,\r\n      )}\r\n    >\r\n      {children ?? <XIcon />}\r\n    </RemoveButtonPrimitive>\r\n  );\r\n}\r\n\r\ninterface KeyValueAddButtonProps\r\n  extends React.ComponentProps<\"button\">,\r\n    Pick<KeyValueRootProps, \"onAdd\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueAddButton(props: KeyValueAddButtonProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    children,\r\n    onClick: onClickProp,\r\n    onAdd,\r\n    ...buttonProps\r\n  } = props;\r\n\r\n  const context = useKeyValueContext(ADD_BUTTON_NAME);\r\n  const store = useStoreContext(ADD_BUTTON_NAME);\r\n\r\n  const propsRef = useAsRef({ onClick: onClickProp, onAdd });\r\n  const value = useStore((state) => state.value);\r\n  const isDisabled =\r\n    context.disabled ||\r\n    (context.maxEntries !== undefined && value.length >= context.maxEntries);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<AddButtonElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n\r\n      const state = store.getState();\r\n      if (\r\n        context.maxEntries !== undefined &&\r\n        state.value.length >= context.maxEntries\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const newEntry: KeyValueEntry = {\r\n        id: crypto.randomUUID(),\r\n        key: \"\",\r\n        value: \"\",\r\n      };\r\n\r\n      const newValue = [...state.value, newEntry];\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"focusedId\", newEntry.id);\r\n\r\n      propsRef.current.onAdd?.(newEntry);\r\n    },\r\n    [store, context.maxEntries, propsRef],\r\n  );\r\n\r\n  const AddButtonPrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <AddButtonPrimitive\r\n      type=\"button\"\r\n      {...buttonProps}\r\n      onClick={onClick}\r\n      disabled={isDisabled}\r\n      aria-label=\"Add new entry\"\r\n      className={cn(\r\n        \"inline-flex h-9 items-center justify-center gap-2 whitespace-nowrap rounded-md px-4 font-medium text-sm transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\r\n        \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\r\n        className,\r\n      )}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <PlusIcon />\r\n          {context.addButtonText}\r\n        </>\r\n      )}\r\n    </AddButtonPrimitive>\r\n  );\r\n}\r\n\r\ninterface KeyValueErrorProps extends React.ComponentProps<\"span\"> {\r\n  field: \"key\" | \"value\";\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueError(props: KeyValueErrorProps) {\r\n  const { field, asChild, className, ...errorProps } = props;\r\n  const { entry } = useKeyValueItemContext(ERROR_NAME);\r\n  const context = useKeyValueContext(ERROR_NAME);\r\n\r\n  const errors = useStore((state) => state.errors);\r\n  const error = errors[entry.id]?.[field];\r\n\r\n  if (!error) return null;\r\n\r\n  const ErrorPrimitive = asChild ? Slot : \"span\";\r\n\r\n  return (\r\n    <ErrorPrimitive\r\n      {...errorProps}\r\n      id={`${context.id}-${entry.id}-${field}-error`}\r\n      role=\"alert\"\r\n      className={cn(\"font-medium text-destructive text-sm\", className)}\r\n    >\r\n      {error}\r\n    </ErrorPrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  KeyValueRoot as Root,\r\n  KeyValueList as List,\r\n  KeyValueItem as Item,\r\n  KeyValueKeyInput as KeyInput,\r\n  KeyValueValueInput as ValueInput,\r\n  KeyValueRemoveButton as RemoveButton,\r\n  KeyValueAddButton as AddButton,\r\n  KeyValueError as Error,\r\n  //\r\n  KeyValueRoot as KeyValue,\r\n  KeyValueList,\r\n  KeyValueItem,\r\n  KeyValueKeyInput,\r\n  KeyValueValueInput,\r\n  KeyValueRemoveButton,\r\n  KeyValueAddButton,\r\n  KeyValueError,\r\n  //\r\n  type KeyValueEntry,\r\n  type KeyValueRootProps as KeyValueProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}