{
  "name": "time-picker",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "registryDependencies": [
    "popover"
  ],
  "files": [
    {
      "path": "ui/time-picker.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { Clock } from \"lucide-react\";\nimport * as React from \"react\";\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\n\nconst ROOT_NAME = \"TimePicker\";\nconst LABEL_NAME = \"TimePickerLabel\";\nconst INPUT_GROUP_NAME = \"TimePickerInputGroup\";\nconst TRIGGER_NAME = \"TimePickerTrigger\";\nconst COLUMN_ITEM_NAME = \"TimePickerColumnItem\";\nconst HOUR_NAME = \"TimePickerHour\";\nconst MINUTE_NAME = \"TimePickerMinute\";\nconst SECOND_NAME = \"TimePickerSecond\";\nconst PERIOD_NAME = \"TimePickerPeriod\";\nconst CLEAR_NAME = \"TimePickerClear\";\nconst INPUT_NAME = \"TimePickerInput\";\n\ntype Segment = \"hour\" | \"minute\" | \"second\" | \"period\";\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\ntype RootElement = React.ComponentRef<typeof TimePickerRoot>;\ntype ColumnItemElement = React.ComponentRef<typeof TimePickerColumnItem>;\ntype InputElement = React.ComponentRef<typeof TimePickerInput>;\n\nconst PERIODS = [\"AM\", \"PM\"] as const;\ntype Period = (typeof PERIODS)[number];\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\ninterface TimeValue {\n  hour: number;\n  minute: number;\n  second: number;\n  period?: Period;\n}\n\nfunction parseTimeString(\n  timeString: string | undefined,\n  use12Hours: boolean,\n): TimeValue | null {\n  if (!timeString) return null;\n\n  const parts = timeString.split(\":\");\n  if (parts.length < 2) return null;\n\n  let hour = Number.parseInt(parts[0] ?? \"0\", 10);\n  const minute = Number.parseInt(parts[1] ?? \"0\", 10);\n  const second = parts[2] ? Number.parseInt(parts[2], 10) : 0;\n\n  if (Number.isNaN(hour) || Number.isNaN(minute) || Number.isNaN(second)) {\n    return null;\n  }\n\n  let period: Period | undefined;\n  if (use12Hours) {\n    period = hour >= 12 ? \"PM\" : \"AM\";\n    hour = hour % 12 || 12;\n  }\n\n  return { hour, minute, second, period };\n}\n\nfunction formatTimeValue(\n  value: TimeValue,\n  showSeconds: boolean,\n  use12Hours: boolean,\n): string {\n  let hour = value.hour;\n\n  if (use12Hours) {\n    const isPM = value.period === \"PM\";\n    hour = hour === 12 ? (isPM ? 12 : 0) : isPM ? hour + 12 : hour;\n  }\n\n  const hourStr = hour.toString().padStart(2, \"0\");\n  const minuteStr = value.minute.toString().padStart(2, \"0\");\n  const secondStr = value.second.toString().padStart(2, \"0\");\n\n  if (showSeconds) {\n    return `${hourStr}:${minuteStr}:${secondStr}`;\n  }\n  return `${hourStr}:${minuteStr}`;\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n\ninterface StoreState {\n  value: string;\n  open: boolean;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nfunction createStore(\n  listenersRef: React.RefObject<Set<() => void>>,\n  stateRef: React.RefObject<StoreState>,\n  propsRef: React.RefObject<{\n    onValueChange?: (value: string) => void;\n    onOpenChange?: (open: boolean) => void;\n  }>,\n): Store {\n  const store: Store = {\n    subscribe: (cb) => {\n      listenersRef.current?.add(cb);\n      return () => listenersRef.current?.delete(cb);\n    },\n    getState: () => stateRef.current,\n    setState: (key, value) => {\n      if (!stateRef.current || Object.is(stateRef.current[key], value)) return;\n\n      if (key === \"value\" && typeof value === \"string\") {\n        stateRef.current.value = value;\n        propsRef.current.onValueChange?.(value);\n      } else if (key === \"open\" && typeof value === \"boolean\") {\n        stateRef.current.open = value;\n        propsRef.current.onOpenChange?.(value);\n      } else {\n        stateRef.current[key] = value;\n      }\n\n      store.notify();\n    },\n    notify: () => {\n      for (const cb of listenersRef.current ?? []) {\n        cb();\n      }\n    },\n  };\n\n  return store;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface TimePickerContextValue {\n  id: string;\n  inputGroupId: string;\n  labelId: string;\n  triggerId: string;\n  disabled: boolean;\n  readOnly: boolean;\n  required: boolean;\n  invalid: boolean;\n  showSeconds: boolean;\n  use12Hours: boolean;\n  minuteStep: number;\n  secondStep: number;\n  hourStep: number;\n  placeholder: string;\n  min?: string;\n  max?: string;\n}\n\nconst TimePickerContext = React.createContext<TimePickerContextValue | null>(\n  null,\n);\n\nfunction useTimePickerContext(consumerName: string) {\n  const context = React.useContext(TimePickerContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nexport interface TimePickerRootProps extends DivProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  onOpenChange?: (open: boolean) => void;\n  name?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  required?: boolean;\n  invalid?: boolean;\n  min?: string;\n  max?: string;\n  showSeconds?: boolean;\n  use12Hours?: boolean;\n  minuteStep?: number;\n  secondStep?: number;\n  hourStep?: number;\n  placeholder?: string;\n}\n\nfunction TimePickerRoot(props: TimePickerRootProps) {\n  const {\n    value,\n    defaultValue = \"\",\n    onValueChange,\n    onOpenChange,\n    ...rootProps\n  } = props;\n\n  const stateRef = useLazyRef<StoreState>(() => ({\n    value: value ?? defaultValue,\n    open: false,\n  }));\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const propsRef = useAsRef({ onValueChange, onOpenChange });\n\n  const store = React.useMemo(\n    () => createStore(listenersRef, stateRef, propsRef),\n    [listenersRef, stateRef, propsRef],\n  );\n\n  return (\n    <StoreContext.Provider value={store}>\n      <TimePickerRootImpl {...rootProps} value={value} />\n    </StoreContext.Provider>\n  );\n}\n\ninterface TimePickerRootImplProps\n  extends Omit<\n    TimePickerRootProps,\n    \"defaultValue\" | \"onValueChange\" | \"onOpenChange\"\n  > {}\n\nfunction TimePickerRootImpl(props: TimePickerRootImplProps) {\n  const {\n    id: idProp,\n    value,\n    name,\n    disabled = false,\n    readOnly = false,\n    required = false,\n    invalid = false,\n    min,\n    max,\n    showSeconds = false,\n    use12Hours = false,\n    minuteStep = 1,\n    secondStep = 1,\n    hourStep = 1,\n    placeholder = \"Select time\",\n    asChild,\n    className,\n    ref,\n    children,\n    ...rootProps\n  } = props;\n\n  const store = useStoreContext(\"TimePickerRootImpl\");\n\n  useIsomorphicLayoutEffect(() => {\n    if (value !== undefined) {\n      store.setState(\"value\", value);\n    }\n  }, [value]);\n\n  const instanceId = React.useId();\n  const rootId = idProp ?? instanceId;\n  const inputGroupId = React.useId();\n  const labelId = React.useId();\n  const triggerId = React.useId();\n\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\n    null,\n  );\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\n\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\n\n  const rootContext: TimePickerContextValue = React.useMemo(\n    () => ({\n      id: rootId,\n      inputGroupId,\n      labelId,\n      triggerId,\n      disabled,\n      readOnly,\n      required,\n      invalid,\n      showSeconds,\n      use12Hours,\n      minuteStep,\n      secondStep,\n      hourStep,\n      placeholder,\n      min,\n      max,\n    }),\n    [\n      rootId,\n      inputGroupId,\n      labelId,\n      triggerId,\n      disabled,\n      readOnly,\n      required,\n      invalid,\n      showSeconds,\n      use12Hours,\n      minuteStep,\n      secondStep,\n      hourStep,\n      placeholder,\n      min,\n      max,\n    ],\n  );\n\n  const open = useStore((state) => state.open);\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <>\n      <TimePickerContext.Provider value={rootContext}>\n        <Popover\n          open={open}\n          onOpenChange={(newOpen: boolean) => store.setState(\"open\", newOpen)}\n        >\n          <RootPrimitive\n            data-slot=\"time-picker\"\n            data-disabled={disabled ? \"\" : undefined}\n            data-invalid={invalid ? \"\" : undefined}\n            ref={composedRef}\n            {...rootProps}\n            className={cn(\"relative\", className)}\n          >\n            {children}\n          </RootPrimitive>\n        </Popover>\n      </TimePickerContext.Provider>\n      {isFormControl && (\n        <VisuallyHiddenInput\n          type=\"hidden\"\n          control={formTrigger}\n          name={name}\n          value={value}\n          disabled={disabled}\n          readOnly={readOnly}\n          required={required}\n        />\n      )}\n    </>\n  );\n}\n\ninterface TimePickerLabelProps extends React.ComponentProps<\"label\"> {\n  asChild?: boolean;\n}\n\nfunction TimePickerLabel(props: TimePickerLabelProps) {\n  const { asChild, className, ...labelProps } = props;\n\n  const { labelId } = useTimePickerContext(LABEL_NAME);\n\n  const LabelPrimitive = asChild ? Slot : \"label\";\n\n  return (\n    <LabelPrimitive\n      data-slot=\"time-picker-label\"\n      {...labelProps}\n      htmlFor={labelId}\n      className={cn(\n        \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\n        className,\n      )}\n    />\n  );\n}\n\ninterface TimePickerInputGroupProps extends DivProps {}\n\nfunction TimePickerInputGroup(props: TimePickerInputGroupProps) {\n  const { asChild, className, ...groupProps } = props;\n\n  const { inputGroupId, labelId, disabled, invalid } =\n    useTimePickerContext(INPUT_GROUP_NAME);\n\n  const InputGroupPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <PopoverAnchor asChild>\n      <InputGroupPrimitive\n        role=\"group\"\n        id={inputGroupId}\n        aria-labelledby={labelId}\n        data-slot=\"time-picker-input-group\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-invalid={invalid ? \"\" : undefined}\n        {...groupProps}\n        className={cn(\n          \"flex h-10 w-full items-center gap-1 rounded-md border border-input bg-background px-3 py-2 shadow-xs outline-none transition-shadow\",\n          \"has-[input:focus-visible]:border-ring has-[input:focus-visible]:ring-[3px] has-[input:focus-visible]:ring-ring/50\",\n          invalid && \"border-destructive ring-destructive/20\",\n          disabled && \"cursor-not-allowed opacity-50\",\n          className,\n        )}\n      />\n    </PopoverAnchor>\n  );\n}\n\ninterface TimePickerTriggerProps extends ButtonProps {}\n\nfunction TimePickerTrigger(props: TimePickerTriggerProps) {\n  const {\n    className,\n    children,\n    disabled: disabledProp,\n    ...triggerProps\n  } = props;\n\n  const { triggerId, disabled } = useTimePickerContext(TRIGGER_NAME);\n\n  const isDisabled = disabledProp || disabled;\n\n  return (\n    <PopoverTrigger\n      type=\"button\"\n      id={triggerId}\n      data-slot=\"time-picker-trigger\"\n      disabled={isDisabled}\n      {...triggerProps}\n      className={cn(\n        \"ml-auto flex items-center text-muted-foreground transition-colors hover:text-foreground disabled:pointer-events-none [&>svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n    >\n      {children ?? <Clock />}\n    </PopoverTrigger>\n  );\n}\n\ninterface TimePickerContentProps\n  extends DivProps,\n    React.ComponentProps<typeof PopoverContent> {}\n\nfunction TimePickerContent(props: TimePickerContentProps) {\n  const {\n    side = \"bottom\",\n    align = \"start\",\n    sideOffset = 4,\n    className,\n    ...contentProps\n  } = props;\n\n  return (\n    <PopoverContent\n      data-slot=\"time-picker-content\"\n      side={side}\n      align={align}\n      sideOffset={sideOffset}\n      {...contentProps}\n      className={cn(\"w-auto max-w-(--radix-popover-trigger-width)\", className)}\n    />\n  );\n}\n\ninterface TimePickerColumnContextValue {\n  activeIndex: number | null;\n  setActiveIndex: (index: number | null) => void;\n  items: Array<{\n    value: number;\n    ref: React.RefObject<ColumnItemElement | null>;\n  }>;\n  onItemRegister: (\n    value: number,\n    ref: React.RefObject<ColumnItemElement | null>,\n  ) => void;\n  onItemUnregister: (value: number) => void;\n}\n\nconst TimePickerColumnContext =\n  React.createContext<TimePickerColumnContextValue | null>(null);\n\nfunction useTimePickerColumnContext(consumerName: string) {\n  const context = React.useContext(TimePickerColumnContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within a column`);\n  }\n  return context;\n}\n\ninterface TimePickerColumnProps extends DivProps {}\n\nfunction TimePickerColumn(props: TimePickerColumnProps) {\n  const { children, className, ...columnProps } = props;\n\n  const [activeIndex, setActiveIndex] = React.useState<number | null>(null);\n  const itemsRef = React.useRef<\n    Map<number, React.RefObject<HTMLButtonElement | null>>\n  >(new Map());\n\n  const onItemRegister = React.useCallback(\n    (value: number, ref: React.RefObject<HTMLButtonElement | null>) => {\n      itemsRef.current.set(value, ref);\n    },\n    [],\n  );\n\n  const onItemUnregister = React.useCallback((value: number) => {\n    itemsRef.current.delete(value);\n  }, []);\n\n  const contextValue = React.useMemo<TimePickerColumnContextValue>(\n    () => ({\n      activeIndex,\n      setActiveIndex,\n      items: Array.from(itemsRef.current.entries()).map(([value, ref]) => ({\n        value,\n        ref,\n      })),\n      onItemRegister,\n      onItemUnregister,\n    }),\n    [activeIndex, onItemRegister, onItemUnregister],\n  );\n\n  return (\n    <TimePickerColumnContext.Provider value={contextValue}>\n      <div\n        data-slot=\"time-picker-column\"\n        className={cn(\"flex flex-col gap-1\", className)}\n        {...columnProps}\n      >\n        {children}\n      </div>\n    </TimePickerColumnContext.Provider>\n  );\n}\n\ninterface TimePickerColumnItemProps extends ButtonProps {\n  value: number;\n  selected?: boolean;\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction TimePickerColumnItem(props: TimePickerColumnItemProps) {\n  const {\n    value,\n    selected = false,\n    format = \"numeric\",\n    className,\n    ref,\n    ...itemProps\n  } = props;\n\n  const itemRef = React.useRef<ColumnItemElement | null>(null);\n  const composedRef = useComposedRefs(ref, itemRef);\n  const columnContext = useTimePickerColumnContext(COLUMN_ITEM_NAME);\n\n  useIsomorphicLayoutEffect(() => {\n    columnContext.onItemRegister(value, itemRef);\n    return () => columnContext.onItemUnregister(value);\n  }, [value, columnContext]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (selected && itemRef.current) {\n      itemRef.current.scrollIntoView({ block: \"nearest\" });\n    }\n  }, [selected]);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<ColumnItemElement>) => {\n      itemProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      itemRef.current?.focus();\n    },\n    [itemProps.onClick],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<ColumnItemElement>) => {\n      itemProps.onKeyDown?.(event);\n      if (event.defaultPrevented) return;\n\n      if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n        event.preventDefault();\n        const items = Array.from(columnContext.items).sort(\n          (a, b) => a.value - b.value,\n        );\n        const currentIndex = items.findIndex((item) => item.value === value);\n\n        let nextIndex: number;\n        if (event.key === \"ArrowUp\") {\n          nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;\n        } else {\n          nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;\n        }\n\n        const nextItem = items[nextIndex];\n        nextItem?.ref.current?.focus();\n        nextItem?.ref.current?.click();\n      }\n    },\n    [itemProps.onKeyDown, columnContext.items, value],\n  );\n\n  const formattedValue =\n    format === \"2-digit\" ? value.toString().padStart(2, \"0\") : value.toString();\n\n  return (\n    <button\n      type=\"button\"\n      {...itemProps}\n      ref={composedRef}\n      className={cn(\n        \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n        selected &&\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n        className,\n      )}\n      onClick={onClick}\n      onKeyDown={onKeyDown}\n    >\n      {formattedValue}\n    </button>\n  );\n}\n\ninterface TimePickerHourProps extends DivProps {\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction TimePickerHour(props: TimePickerHourProps) {\n  const { asChild, format = \"numeric\", ...hourProps } = props;\n\n  const { use12Hours, hourStep, showSeconds } = useTimePickerContext(HOUR_NAME);\n  const store = useStoreContext(HOUR_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const maxHour = use12Hours ? 12 : 23;\n  const hours = Array.from(\n    { length: Math.ceil((maxHour + 1) / hourStep) },\n    (_, i) => {\n      const hour = i * hourStep;\n      return use12Hours ? (hour === 0 ? 12 : hour) : hour;\n    },\n  );\n\n  const onHourSelect = React.useCallback(\n    (hour: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, hour };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, showSeconds, use12Hours, store],\n  );\n\n  const HourPrimitive = asChild ? Slot : TimePickerColumn;\n\n  return (\n    <HourPrimitive data-slot=\"time-picker-hour\" {...hourProps}>\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">Hour</div>\n      <div className=\"flex max-h-[200px] flex-col gap-1 overflow-y-auto\">\n        {hours.map((hour) => (\n          <TimePickerColumnItem\n            key={hour}\n            value={hour}\n            selected={timeValue?.hour === hour}\n            format={format}\n            onClick={() => onHourSelect(hour)}\n          />\n        ))}\n      </div>\n    </HourPrimitive>\n  );\n}\n\ninterface TimePickerMinuteProps extends DivProps {\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction TimePickerMinute(props: TimePickerMinuteProps) {\n  const { asChild, format = \"2-digit\", ...minuteProps } = props;\n\n  const { use12Hours, minuteStep, showSeconds } =\n    useTimePickerContext(MINUTE_NAME);\n  const store = useStoreContext(MINUTE_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const minutes = Array.from(\n    { length: Math.ceil(60 / minuteStep) },\n    (_, i) => i * minuteStep,\n  );\n\n  const onMinuteSelect = React.useCallback(\n    (minute: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, minute };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, showSeconds, use12Hours, store],\n  );\n\n  const MinutePrimitive = asChild ? Slot : TimePickerColumn;\n\n  return (\n    <MinutePrimitive data-slot=\"time-picker-minute\" {...minuteProps}>\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n        Minute\n      </div>\n      <div className=\"flex max-h-[200px] flex-col gap-1 overflow-y-auto\">\n        {minutes.map((minute) => (\n          <TimePickerColumnItem\n            key={minute}\n            value={minute}\n            selected={timeValue?.minute === minute}\n            format={format}\n            onClick={() => onMinuteSelect(minute)}\n          />\n        ))}\n      </div>\n    </MinutePrimitive>\n  );\n}\n\ninterface TimePickerSecondProps extends DivProps {\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction TimePickerSecond(props: TimePickerSecondProps) {\n  const { asChild, format = \"2-digit\", ...secondProps } = props;\n  const { use12Hours, secondStep } = useTimePickerContext(SECOND_NAME);\n  const store = useStoreContext(SECOND_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const seconds = Array.from(\n    { length: Math.ceil(60 / secondStep) },\n    (_, i) => i * secondStep,\n  );\n\n  const onSecondSelect = React.useCallback(\n    (second: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, second };\n      const newValue = formatTimeValue(newTime, true, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, use12Hours, store],\n  );\n\n  const SecondPrimitive = asChild ? Slot : TimePickerColumn;\n\n  return (\n    <SecondPrimitive data-slot=\"time-picker-second\" {...secondProps}>\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n        Second\n      </div>\n      <div className=\"flex max-h-[200px] flex-col gap-1 overflow-y-auto\">\n        {seconds.map((second) => (\n          <TimePickerColumnItem\n            key={second}\n            value={second}\n            selected={timeValue?.second === second}\n            format={format}\n            onClick={() => onSecondSelect(second)}\n          />\n        ))}\n      </div>\n    </SecondPrimitive>\n  );\n}\n\ninterface TimePickerPeriodProps extends DivProps {}\n\nfunction TimePickerPeriod(props: TimePickerPeriodProps) {\n  const { asChild, className, ...periodProps } = props;\n  const { use12Hours, showSeconds } = useTimePickerContext(PERIOD_NAME);\n  const store = useStoreContext(PERIOD_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const onPeriodToggle = React.useCallback(\n    (period: Period) => {\n      const currentTime = timeValue ?? {\n        hour: 12,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, period };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, showSeconds, use12Hours, store],\n  );\n\n  if (!use12Hours) return null;\n\n  const PeriodPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <PeriodPrimitive\n      data-slot=\"time-picker-period\"\n      {...periodProps}\n      className={cn(\"flex flex-col gap-1\", className)}\n    >\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n        Period\n      </div>\n      <div className=\"flex flex-col gap-1\">\n        {PERIODS.map((period) => {\n          const isSelected = timeValue?.period === period;\n          return (\n            <button\n              key={period}\n              type=\"button\"\n              onClick={() => onPeriodToggle(period)}\n              className={cn(\n                \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n                isSelected &&\n                  \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n              )}\n            >\n              {period}\n            </button>\n          );\n        })}\n      </div>\n    </PeriodPrimitive>\n  );\n}\n\ninterface TimePickerSeparatorProps extends React.ComponentProps<\"span\"> {\n  asChild?: boolean;\n}\n\nfunction TimePickerSeparator(props: TimePickerSeparatorProps) {\n  const { asChild, className, children, ...separatorProps } = props;\n\n  const SeparatorPrimitive = asChild ? Slot : \"span\";\n\n  return (\n    <SeparatorPrimitive\n      aria-hidden=\"true\"\n      data-slot=\"time-picker-separator\"\n      {...separatorProps}\n      className={cn(\"text-muted-foreground\", className)}\n    >\n      {children ?? \":\"}\n    </SeparatorPrimitive>\n  );\n}\n\ninterface TimePickerClearProps extends ButtonProps {}\n\nfunction TimePickerClear(props: TimePickerClearProps) {\n  const {\n    asChild,\n    className,\n    children,\n    disabled: disabledProp,\n    ...clearProps\n  } = props;\n\n  const { disabled, readOnly } = useTimePickerContext(CLEAR_NAME);\n  const store = useStoreContext(CLEAR_NAME);\n\n  const isDisabled = disabledProp || disabled;\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      clearProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      event.preventDefault();\n      if (disabled || readOnly) return;\n      store.setState(\"value\", \"\");\n    },\n    [clearProps.onClick, disabled, readOnly, store],\n  );\n\n  const ClearPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ClearPrimitive\n      type=\"button\"\n      data-slot=\"time-picker-clear\"\n      disabled={isDisabled}\n      {...clearProps}\n      className={cn(\n        \"inline-flex items-center justify-center rounded-sm font-medium text-sm transition-colors hover:bg-accent hover:text-accent-foreground disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      onClick={onClick}\n    >\n      {children ?? \"Clear\"}\n    </ClearPrimitive>\n  );\n}\n\ninterface TimePickerInputProps\n  extends Omit<React.ComponentProps<\"input\">, \"type\" | \"value\"> {\n  segment?: Segment;\n}\n\nfunction TimePickerInput(props: TimePickerInputProps) {\n  const {\n    segment,\n    disabled: disabledProp,\n    readOnly: readOnlyProp,\n    className,\n    ref,\n    onBlur: onBlurProp,\n    onChange: onChangeProp,\n    onClick: onClickProp,\n    onFocus: onFocusProp,\n    onKeyDown: onKeyDownProp,\n    ...inputProps\n  } = props;\n\n  const { use12Hours, showSeconds, disabled, readOnly } =\n    useTimePickerContext(INPUT_NAME);\n  const store = useStoreContext(INPUT_NAME);\n\n  const isDisabled = disabledProp || disabled;\n  const isReadOnly = readOnlyProp || readOnly;\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const composedRef = useComposedRefs(ref, inputRef);\n\n  const getSegmentValue = React.useCallback(() => {\n    if (!timeValue) return \"\";\n    switch (segment) {\n      case \"hour\":\n        return timeValue.hour.toString().padStart(2, \"0\");\n      case \"minute\":\n        return timeValue.minute.toString().padStart(2, \"0\");\n      case \"second\":\n        return timeValue.second.toString().padStart(2, \"0\");\n      case \"period\":\n        return timeValue.period ?? \"AM\";\n      default:\n        return \"\";\n    }\n  }, [timeValue, segment]);\n\n  const [editValue, setEditValue] = React.useState(getSegmentValue());\n  const [isEditing, setIsEditing] = React.useState(false);\n\n  React.useEffect(() => {\n    if (!isEditing) {\n      setEditValue(getSegmentValue());\n    }\n  }, [getSegmentValue, isEditing]);\n\n  const updateTimeValue = React.useCallback(\n    (newSegmentValue: string) => {\n      const currentTime = timeValue ?? {\n        hour: use12Hours ? 12 : 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\" as const,\n      };\n\n      const newTime = { ...currentTime };\n\n      switch (segment) {\n        case \"hour\": {\n          const hour = Number.parseInt(newSegmentValue, 10);\n          if (!Number.isNaN(hour)) {\n            const maxHour = use12Hours ? 12 : 23;\n            const minHour = use12Hours ? 1 : 0;\n            const clampedHour = clamp(hour, minHour, maxHour);\n            newTime.hour = clampedHour;\n          }\n          break;\n        }\n        case \"minute\": {\n          const minute = Number.parseInt(newSegmentValue, 10);\n          if (!Number.isNaN(minute)) {\n            newTime.minute = clamp(minute, 0, 59);\n          }\n          break;\n        }\n        case \"second\": {\n          const second = Number.parseInt(newSegmentValue, 10);\n          if (!Number.isNaN(second)) {\n            newTime.second = clamp(second, 0, 59);\n          }\n          break;\n        }\n        case \"period\": {\n          if (newSegmentValue === \"AM\" || newSegmentValue === \"PM\") {\n            newTime.period = newSegmentValue;\n          }\n          break;\n        }\n      }\n\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, segment, use12Hours, showSeconds, store],\n  );\n\n  const onBlur = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onBlurProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsEditing(false);\n      if (editValue) {\n        updateTimeValue(editValue);\n      }\n      setEditValue(getSegmentValue());\n    },\n    [onBlurProp, editValue, updateTimeValue, getSegmentValue],\n  );\n\n  const onChange = React.useCallback(\n    (event: React.ChangeEvent<InputElement>) => {\n      onChangeProp?.(event);\n      if (event.defaultPrevented) return;\n\n      const newValue = event.target.value;\n\n      // For period, just accept 'a', 'A', 'p', 'P' and convert immediately\n      if (segment === \"period\") {\n        const firstChar = newValue.charAt(0).toUpperCase();\n        if (firstChar === \"A\") {\n          setEditValue(\"AM\");\n          updateTimeValue(\"AM\");\n        } else if (firstChar === \"P\") {\n          setEditValue(\"PM\");\n          updateTimeValue(\"PM\");\n        }\n        return;\n      }\n\n      setEditValue(newValue);\n    },\n    [segment, updateTimeValue, onChangeProp],\n  );\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<InputElement>) => {\n      onClickProp?.(event);\n      if (event.defaultPrevented) return;\n\n      // Select all on click, like native time picker\n      event.currentTarget.select();\n    },\n    [onClickProp],\n  );\n\n  const onFocus = React.useCallback(\n    (event: React.FocusEvent<InputElement>) => {\n      onFocusProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsEditing(true);\n      // Always select the entire content like native time picker\n      queueMicrotask(() => event.target.select());\n    },\n    [onFocusProp],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<InputElement>) => {\n      onKeyDownProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (event.key === \"Enter\") {\n        event.preventDefault();\n        inputRef.current?.blur();\n      } else if (event.key === \"Escape\") {\n        event.preventDefault();\n        setEditValue(getSegmentValue());\n        inputRef.current?.blur();\n      } else if (event.key === \"ArrowUp\") {\n        event.preventDefault();\n        const currentValue = Number.parseInt(editValue, 10);\n        if (!Number.isNaN(currentValue)) {\n          let newValue: number;\n          switch (segment) {\n            case \"hour\":\n              newValue = use12Hours\n                ? currentValue === 12\n                  ? 1\n                  : currentValue + 1\n                : currentValue === 23\n                  ? 0\n                  : currentValue + 1;\n              break;\n            case \"minute\":\n            case \"second\":\n              newValue = currentValue === 59 ? 0 : currentValue + 1;\n              break;\n            default:\n              return;\n          }\n          const formattedValue = newValue.toString().padStart(2, \"0\");\n          setEditValue(formattedValue);\n          updateTimeValue(formattedValue);\n        }\n      } else if (event.key === \"ArrowDown\") {\n        event.preventDefault();\n        const currentValue = Number.parseInt(editValue, 10);\n        if (!Number.isNaN(currentValue)) {\n          let newValue: number;\n          switch (segment) {\n            case \"hour\":\n              newValue = use12Hours\n                ? currentValue === 1\n                  ? 12\n                  : currentValue - 1\n                : currentValue === 0\n                  ? 23\n                  : currentValue - 1;\n              break;\n            case \"minute\":\n            case \"second\":\n              newValue = currentValue === 0 ? 59 : currentValue - 1;\n              break;\n            default:\n              return;\n          }\n          const formattedValue = newValue.toString().padStart(2, \"0\");\n          setEditValue(formattedValue);\n          updateTimeValue(formattedValue);\n        }\n      } else if (segment === \"period\") {\n        const key = event.key.toLowerCase();\n        if (key === \"a\" || key === \"p\") {\n          event.preventDefault();\n          const newPeriod = key === \"a\" ? \"AM\" : \"PM\";\n          setEditValue(newPeriod);\n          updateTimeValue(newPeriod);\n        } else if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n          event.preventDefault();\n          const currentPeriod = editValue || \"AM\";\n          const newPeriod = currentPeriod === \"AM\" ? \"PM\" : \"AM\";\n          setEditValue(newPeriod);\n          updateTimeValue(newPeriod);\n        }\n      }\n    },\n    [\n      onKeyDownProp,\n      editValue,\n      segment,\n      use12Hours,\n      getSegmentValue,\n      updateTimeValue,\n    ],\n  );\n\n  const displayValue = isEditing ? editValue : getSegmentValue();\n\n  return (\n    <input\n      type=\"text\"\n      {...inputProps}\n      disabled={isDisabled}\n      readOnly={isReadOnly}\n      className={cn(\n        \"inline-flex h-full min-w-[2.5ch] items-center justify-center rounded border-0 bg-transparent px-0.5 text-center text-sm tabular-nums focus:bg-accent focus:outline-none disabled:cursor-not-allowed disabled:opacity-50\",\n        segment === \"period\" && \"min-w-[3ch]\",\n        className,\n      )}\n      ref={composedRef}\n      value={displayValue}\n      onBlur={onBlur}\n      onChange={onChange}\n      onClick={onClick}\n      onFocus={onFocus}\n      onKeyDown={onKeyDown}\n    />\n  );\n}\n\nexport {\n  TimePickerRoot as Root,\n  TimePickerLabel as Label,\n  TimePickerInputGroup as InputGroup,\n  TimePickerTrigger as Trigger,\n  TimePickerContent as Content,\n  TimePickerHour as Hour,\n  TimePickerMinute as Minute,\n  TimePickerSecond as Second,\n  TimePickerPeriod as Period,\n  TimePickerSeparator as Separator,\n  TimePickerClear as Clear,\n  TimePickerInput as Input,\n  //\n  TimePickerRoot as TimePicker,\n  TimePickerRoot,\n  TimePickerLabel,\n  TimePickerInputGroup,\n  TimePickerTrigger,\n  TimePickerContent,\n  TimePickerHour,\n  TimePickerMinute,\n  TimePickerSecond,\n  TimePickerPeriod,\n  TimePickerSeparator,\n  TimePickerClear,\n  TimePickerInput,\n  //\n  type TimePickerRootProps as TimePickerProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}