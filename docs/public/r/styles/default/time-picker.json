{
  "name": "time-picker",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "registryDependencies": [
    "popover"
  ],
  "files": [
    {
      "path": "ui/time-picker.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\n\nconst ROOT_NAME = \"TimePicker\";\nconst LABEL_NAME = \"TimePickerLabel\";\nconst INPUT_GROUP_NAME = \"TimePickerInputGroup\";\nconst TRIGGER_NAME = \"TimePickerTrigger\";\nconst CONTENT_NAME = \"TimePickerContent\";\nconst HOUR_NAME = \"TimePickerHour\";\nconst MINUTE_NAME = \"TimePickerMinute\";\nconst SECOND_NAME = \"TimePickerSecond\";\nconst PERIOD_NAME = \"TimePickerPeriod\";\nconst CLEAR_NAME = \"TimePickerClear\";\nconst INPUT_NAME = \"TimePickerInput\";\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\ninterface TimeValue {\n  hour: number;\n  minute: number;\n  second: number;\n  period?: \"AM\" | \"PM\";\n}\n\nfunction parseTimeString(\n  timeString: string | undefined,\n  use12Hours: boolean,\n): TimeValue | null {\n  if (!timeString) return null;\n\n  const parts = timeString.split(\":\");\n  if (parts.length < 2) return null;\n\n  let hour = Number.parseInt(parts[0] ?? \"0\", 10);\n  const minute = Number.parseInt(parts[1] ?? \"0\", 10);\n  const second = parts[2] ? Number.parseInt(parts[2], 10) : 0;\n\n  if (Number.isNaN(hour) || Number.isNaN(minute) || Number.isNaN(second)) {\n    return null;\n  }\n\n  let period: \"AM\" | \"PM\" | undefined;\n  if (use12Hours) {\n    period = hour >= 12 ? \"PM\" : \"AM\";\n    hour = hour % 12 || 12;\n  }\n\n  return { hour, minute, second, period };\n}\n\nfunction formatTimeValue(\n  value: TimeValue,\n  showSeconds: boolean,\n  use12Hours: boolean,\n): string {\n  let hour = value.hour;\n\n  if (use12Hours) {\n    const isPM = value.period === \"PM\";\n    hour = hour === 12 ? (isPM ? 12 : 0) : isPM ? hour + 12 : hour;\n  }\n\n  const hourStr = hour.toString().padStart(2, \"0\");\n  const minuteStr = value.minute.toString().padStart(2, \"0\");\n  const secondStr = value.second.toString().padStart(2, \"0\");\n\n  if (showSeconds) {\n    return `${hourStr}:${minuteStr}:${secondStr}`;\n  }\n  return `${hourStr}:${minuteStr}`;\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n\ninterface StoreState {\n  value: string;\n  open: boolean;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nfunction createStore(\n  listenersRef: React.RefObject<Set<() => void>>,\n  stateRef: React.RefObject<StoreState>,\n  propsRef: React.RefObject<{\n    onValueChange?: (value: string) => void;\n    onOpenChange?: (open: boolean) => void;\n  }>,\n): Store {\n  const store: Store = {\n    subscribe: (cb) => {\n      listenersRef.current?.add(cb);\n      return () => listenersRef.current?.delete(cb);\n    },\n    getState: () => stateRef.current,\n    setState: (key, value) => {\n      if (!stateRef.current || Object.is(stateRef.current[key], value)) return;\n\n      if (key === \"value\" && typeof value === \"string\") {\n        stateRef.current.value = value;\n        propsRef.current.onValueChange?.(value);\n      } else if (key === \"open\" && typeof value === \"boolean\") {\n        stateRef.current.open = value;\n        propsRef.current.onOpenChange?.(value);\n      } else {\n        stateRef.current[key] = value;\n      }\n\n      store.notify();\n    },\n    notify: () => {\n      for (const cb of listenersRef.current ?? []) {\n        cb();\n      }\n    },\n  };\n\n  return store;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(\"useStore\");\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface RootContextValue {\n  id: string;\n  name?: string;\n  disabled: boolean;\n  readOnly: boolean;\n  required: boolean;\n  invalid: boolean;\n  showSeconds: boolean;\n  use12Hours: boolean;\n  minuteStep: number;\n  secondStep: number;\n  hourStep: number;\n  placeholder: string;\n  min?: string;\n  max?: string;\n  triggerRef: React.RefObject<HTMLButtonElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n}\n\nconst RootContext = React.createContext<RootContextValue | null>(null);\n\nfunction useRootContext(consumerName: string) {\n  const context = React.useContext(RootContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean;\n}\n\ninterface SpanProps extends React.ComponentProps<\"span\"> {\n  asChild?: boolean;\n}\n\ninterface LabelProps extends React.ComponentProps<\"label\"> {\n  asChild?: boolean;\n}\n\ninterface InputProps extends React.ComponentProps<\"input\"> {\n  asChild?: boolean;\n}\n\nexport interface RootProps extends DivProps {\n  id?: string;\n  defaultValue?: string;\n  value?: string;\n  onValueChange?: (value: string) => void;\n  onOpenChange?: (open: boolean) => void;\n  name?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  required?: boolean;\n  invalid?: boolean;\n  min?: string;\n  max?: string;\n  showSeconds?: boolean;\n  use12Hours?: boolean;\n  minuteStep?: number;\n  secondStep?: number;\n  hourStep?: number;\n  placeholder?: string;\n}\n\nfunction Root(props: RootProps) {\n  const {\n    value,\n    defaultValue = \"\",\n    onValueChange,\n    onOpenChange,\n    ...rootProps\n  } = props;\n\n  const stateRef = useLazyRef<StoreState>(() => ({\n    value: value ?? defaultValue,\n    open: false,\n  }));\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const propsRef = useAsRef({ onValueChange, onOpenChange });\n\n  const store = React.useMemo(\n    () => createStore(listenersRef, stateRef, propsRef),\n    [listenersRef, stateRef, propsRef],\n  );\n\n  return (\n    <StoreContext.Provider value={store}>\n      <RootImpl {...rootProps} value={value} />\n    </StoreContext.Provider>\n  );\n}\n\ninterface RootImplProps\n  extends Omit<RootProps, \"defaultValue\" | \"onValueChange\" | \"onOpenChange\"> {}\n\nfunction RootImpl(props: RootImplProps) {\n  const {\n    id: idProp,\n    value,\n    name,\n    disabled = false,\n    readOnly = false,\n    required = false,\n    invalid = false,\n    min,\n    max,\n    showSeconds = false,\n    use12Hours = false,\n    minuteStep = 1,\n    secondStep = 1,\n    hourStep = 1,\n    placeholder = \"Select time\",\n    asChild,\n    className,\n    ref,\n    children,\n    ...rootProps\n  } = props;\n\n  const store = useStoreContext(\"RootImpl\");\n\n  useIsomorphicLayoutEffect(() => {\n    if (value !== undefined) {\n      store.setState(\"value\", value);\n    }\n  }, [value, store]);\n\n  const id = React.useId();\n  const generatedId = idProp ?? id;\n\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentRef = React.useRef<HTMLDivElement>(null);\n\n  const rootContext: RootContextValue = React.useMemo(\n    () => ({\n      id: generatedId,\n      name,\n      disabled,\n      readOnly,\n      required,\n      invalid,\n      showSeconds,\n      use12Hours,\n      minuteStep,\n      secondStep,\n      hourStep,\n      placeholder,\n      min,\n      max,\n      triggerRef,\n      contentRef,\n    }),\n    [\n      generatedId,\n      name,\n      disabled,\n      readOnly,\n      required,\n      invalid,\n      showSeconds,\n      use12Hours,\n      minuteStep,\n      secondStep,\n      hourStep,\n      placeholder,\n      min,\n      max,\n    ],\n  );\n\n  const open = useStore((state) => state.open);\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <RootContext.Provider value={rootContext}>\n      <Popover\n        open={open}\n        onOpenChange={(newOpen: boolean) => store.setState(\"open\", newOpen)}\n      >\n        <Comp ref={ref} className={cn(\"relative\", className)} {...rootProps}>\n          {children}\n        </Comp>\n      </Popover>\n    </RootContext.Provider>\n  );\n}\n\nfunction Label(props: LabelProps) {\n  const { asChild, className, ref, ...labelProps } = props;\n  const { id } = useRootContext(LABEL_NAME);\n\n  const Comp = asChild ? Slot : \"label\";\n\n  return (\n    <Comp\n      ref={ref}\n      htmlFor={`${id}-input-group`}\n      className={cn(\n        \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\n        className,\n      )}\n      {...labelProps}\n    />\n  );\n}\n\nfunction InputGroup(props: DivProps) {\n  const { asChild, className, ref, children, ...groupProps } = props;\n  const { id, disabled, invalid } = useRootContext(INPUT_GROUP_NAME);\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <PopoverAnchor asChild>\n      <Comp\n        ref={ref}\n        id={`${id}-input-group`}\n        data-slot=\"input-group\"\n        role=\"group\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-invalid={invalid ? \"\" : undefined}\n        className={cn(\n          \"flex h-10 w-full items-center gap-1 rounded-md border border-input bg-background px-3 py-2 shadow-xs outline-none transition-shadow\",\n          \"has-[input:focus-visible]:border-ring has-[input:focus-visible]:ring-[3px] has-[input:focus-visible]:ring-ring/50\",\n          invalid && \"border-destructive ring-destructive/20\",\n          disabled && \"cursor-not-allowed opacity-50\",\n          className,\n        )}\n        {...groupProps}\n      >\n        {children}\n      </Comp>\n    </PopoverAnchor>\n  );\n}\n\nfunction Trigger(props: ButtonProps) {\n  const { asChild, className, children, ref, ...triggerProps } = props;\n  const {\n    id,\n    disabled,\n    readOnly,\n    triggerRef: contextTriggerRef,\n    name,\n    required,\n  } = useRootContext(TRIGGER_NAME);\n\n  const value = useStore((state) => state.value);\n\n  const composedRef = useComposedRefs(ref, contextTriggerRef);\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <>\n      <PopoverTrigger asChild disabled={disabled || readOnly}>\n        <Comp\n          ref={composedRef}\n          id={`${id}-trigger`}\n          type=\"button\"\n          className={cn(\n            \"ml-auto flex items-center text-muted-foreground transition-colors hover:text-foreground disabled:pointer-events-none [&>svg:not([class*='size-'])]:size-4\",\n            className,\n          )}\n          {...triggerProps}\n        >\n          {children ?? (\n            <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              width=\"24\"\n              height=\"24\"\n              viewBox=\"0 0 24 24\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              strokeWidth=\"2\"\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n            >\n              <circle cx=\"12\" cy=\"12\" r=\"10\" />\n              <polyline points=\"12 6 12 12 16 14\" />\n            </svg>\n          )}\n        </Comp>\n      </PopoverTrigger>\n      {name && (\n        <VisuallyHiddenInput\n          name={name}\n          value={value}\n          required={required}\n          disabled={disabled}\n          readOnly={readOnly}\n          control={null}\n        />\n      )}\n    </>\n  );\n}\n\nfunction Content(\n  props: DivProps & {\n    side?: \"top\" | \"right\" | \"bottom\" | \"left\";\n    align?: \"start\" | \"center\" | \"end\";\n    sideOffset?: number;\n  },\n) {\n  const {\n    side = \"bottom\",\n    align = \"start\",\n    sideOffset = 4,\n    className,\n    ref,\n    ...contentProps\n  } = props;\n  const { contentRef: contextContentRef } = useRootContext(CONTENT_NAME);\n\n  const composedRef = useComposedRefs(ref, contextContentRef);\n\n  return (\n    <PopoverContent\n      ref={composedRef}\n      side={side}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\"w-auto max-w-(--radix-popover-trigger-width)\", className)}\n      {...contentProps}\n    />\n  );\n}\n\ninterface ColumnContextValue {\n  activeIndex: number | null;\n  setActiveIndex: (index: number | null) => void;\n  items: Array<{\n    value: number;\n    ref: React.RefObject<HTMLButtonElement | null>;\n  }>;\n  registerItem: (\n    value: number,\n    ref: React.RefObject<HTMLButtonElement | null>,\n  ) => void;\n  unregisterItem: (value: number) => void;\n}\n\nconst ColumnContext = React.createContext<ColumnContextValue | null>(null);\n\nfunction useColumnContext(consumerName: string) {\n  const context = React.useContext(ColumnContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within a column`);\n  }\n  return context;\n}\n\ninterface ColumnProps extends DivProps {}\n\nfunction Column(props: ColumnProps) {\n  const { children, className, ref, ...columnProps } = props;\n\n  const [activeIndex, setActiveIndex] = React.useState<number | null>(null);\n  const itemsRef = React.useRef<\n    Map<number, React.RefObject<HTMLButtonElement | null>>\n  >(new Map());\n\n  const registerItem = React.useCallback(\n    (value: number, ref: React.RefObject<HTMLButtonElement | null>) => {\n      itemsRef.current.set(value, ref);\n    },\n    [],\n  );\n\n  const unregisterItem = React.useCallback((value: number) => {\n    itemsRef.current.delete(value);\n  }, []);\n\n  const contextValue = React.useMemo<ColumnContextValue>(\n    () => ({\n      activeIndex,\n      setActiveIndex,\n      items: Array.from(itemsRef.current.entries()).map(([value, ref]) => ({\n        value,\n        ref,\n      })),\n      registerItem,\n      unregisterItem,\n    }),\n    [activeIndex, registerItem, unregisterItem],\n  );\n\n  return (\n    <ColumnContext.Provider value={contextValue}>\n      <div\n        ref={ref}\n        className={cn(\"flex flex-col gap-1\", className)}\n        {...columnProps}\n      >\n        {children}\n      </div>\n    </ColumnContext.Provider>\n  );\n}\n\ninterface ColumnItemProps extends ButtonProps {\n  value: number;\n  selected?: boolean;\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction ColumnItem(props: ColumnItemProps) {\n  const {\n    value,\n    selected = false,\n    format = \"numeric\",\n    className,\n    ref,\n    ...itemProps\n  } = props;\n\n  const itemRef = React.useRef<HTMLButtonElement>(null);\n  const composedRef = useComposedRefs(ref, itemRef);\n  const columnContext = useColumnContext(\"ColumnItem\");\n\n  React.useEffect(() => {\n    columnContext.registerItem(value, itemRef);\n    return () => columnContext.unregisterItem(value);\n  }, [value, columnContext]);\n\n  React.useEffect(() => {\n    if (selected && itemRef.current) {\n      itemRef.current.scrollIntoView({ block: \"nearest\" });\n    }\n  }, [selected]);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      itemProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      itemRef.current?.focus();\n    },\n    [itemProps.onClick],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLButtonElement>) => {\n      itemProps.onKeyDown?.(event);\n      if (event.defaultPrevented) return;\n\n      if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n        event.preventDefault();\n        const items = Array.from(columnContext.items).sort(\n          (a, b) => a.value - b.value,\n        );\n        const currentIndex = items.findIndex((item) => item.value === value);\n\n        let nextIndex: number;\n        if (event.key === \"ArrowUp\") {\n          nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;\n        } else {\n          nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;\n        }\n\n        const nextItem = items[nextIndex];\n        nextItem?.ref.current?.focus();\n        nextItem?.ref.current?.click();\n      }\n    },\n    [itemProps.onKeyDown, columnContext.items, value],\n  );\n\n  const formattedValue =\n    format === \"2-digit\" ? value.toString().padStart(2, \"0\") : value.toString();\n\n  return (\n    <button\n      ref={composedRef}\n      type=\"button\"\n      onClick={onClick}\n      onKeyDown={onKeyDown}\n      className={cn(\n        \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n        selected &&\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n        className,\n      )}\n      {...itemProps}\n    >\n      {formattedValue}\n    </button>\n  );\n}\n\ninterface HourProps extends DivProps {\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction Hour(props: HourProps) {\n  const { asChild, format = \"numeric\", className, ref, ...hourProps } = props;\n  const { use12Hours, hourStep, showSeconds } = useRootContext(HOUR_NAME);\n  const store = useStoreContext(HOUR_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const maxHour = use12Hours ? 12 : 23;\n  const hours = Array.from(\n    { length: Math.ceil((maxHour + 1) / hourStep) },\n    (_, i) => {\n      const hour = i * hourStep;\n      return use12Hours ? (hour === 0 ? 12 : hour) : hour;\n    },\n  );\n\n  const onHourSelect = React.useCallback(\n    (hour: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\" as const,\n      };\n      const newTime = { ...currentTime, hour };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, showSeconds, use12Hours, store],\n  );\n\n  const Comp = asChild ? Slot : Column;\n\n  return (\n    <Comp ref={ref} className={cn(className)} {...hourProps}>\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">Hour</div>\n      <div className=\"max-h-[200px] space-y-1 overflow-y-auto\">\n        {hours.map((hour) => (\n          <ColumnItem\n            key={hour}\n            value={hour}\n            selected={timeValue?.hour === hour}\n            format={format}\n            onClick={() => onHourSelect(hour)}\n          />\n        ))}\n      </div>\n    </Comp>\n  );\n}\n\ninterface MinuteProps extends DivProps {\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction Minute(props: MinuteProps) {\n  const { asChild, format = \"2-digit\", className, ref, ...minuteProps } = props;\n  const { use12Hours, minuteStep, showSeconds } = useRootContext(MINUTE_NAME);\n  const store = useStoreContext(MINUTE_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const minutes = Array.from(\n    { length: Math.ceil(60 / minuteStep) },\n    (_, i) => i * minuteStep,\n  );\n\n  const onMinuteSelect = React.useCallback(\n    (minute: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\" as const,\n      };\n      const newTime = { ...currentTime, minute };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, showSeconds, use12Hours, store],\n  );\n\n  const Comp = asChild ? Slot : Column;\n\n  return (\n    <Comp ref={ref} className={cn(className)} {...minuteProps}>\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n        Minute\n      </div>\n      <div className=\"max-h-[200px] space-y-1 overflow-y-auto\">\n        {minutes.map((minute) => (\n          <ColumnItem\n            key={minute}\n            value={minute}\n            selected={timeValue?.minute === minute}\n            format={format}\n            onClick={() => onMinuteSelect(minute)}\n          />\n        ))}\n      </div>\n    </Comp>\n  );\n}\n\ninterface SecondProps extends DivProps {\n  format?: \"numeric\" | \"2-digit\";\n}\n\nfunction Second(props: SecondProps) {\n  const { asChild, format = \"2-digit\", className, ref, ...secondProps } = props;\n  const { use12Hours, secondStep } = useRootContext(SECOND_NAME);\n  const store = useStoreContext(SECOND_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const seconds = Array.from(\n    { length: Math.ceil(60 / secondStep) },\n    (_, i) => i * secondStep,\n  );\n\n  const onSecondSelect = React.useCallback(\n    (second: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\" as const,\n      };\n      const newTime = { ...currentTime, second };\n      const newValue = formatTimeValue(newTime, true, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, use12Hours, store],\n  );\n\n  const Comp = asChild ? Slot : Column;\n\n  return (\n    <Comp ref={ref} className={cn(className)} {...secondProps}>\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n        Second\n      </div>\n      <div className=\"max-h-[200px] space-y-1 overflow-y-auto\">\n        {seconds.map((second) => (\n          <ColumnItem\n            key={second}\n            value={second}\n            selected={timeValue?.second === second}\n            format={format}\n            onClick={() => onSecondSelect(second)}\n          />\n        ))}\n      </div>\n    </Comp>\n  );\n}\n\nfunction Period(props: DivProps) {\n  const { asChild, className, ref, ...periodProps } = props;\n  const { use12Hours, showSeconds } = useRootContext(PERIOD_NAME);\n  const store = useStoreContext(PERIOD_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const onPeriodToggle = React.useCallback(\n    (period: \"AM\" | \"PM\") => {\n      const currentTime = timeValue ?? {\n        hour: 12,\n        minute: 0,\n        second: 0,\n        period: \"AM\" as const,\n      };\n      const newTime = { ...currentTime, period };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, showSeconds, use12Hours, store],\n  );\n\n  if (!use12Hours) return null;\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"flex flex-col gap-1\", className)}\n      {...periodProps}\n    >\n      <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n        Period\n      </div>\n      <div className=\"space-y-1\">\n        {([\"AM\", \"PM\"] as const).map((period) => {\n          const isSelected = timeValue?.period === period;\n          return (\n            <button\n              key={period}\n              type=\"button\"\n              onClick={() => onPeriodToggle(period)}\n              className={cn(\n                \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n                isSelected &&\n                  \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n              )}\n            >\n              {period}\n            </button>\n          );\n        })}\n      </div>\n    </Comp>\n  );\n}\n\nfunction Separator(props: SpanProps) {\n  const { asChild, className, children, ref, ...separatorProps } = props;\n\n  const Comp = asChild ? Slot : \"span\";\n\n  return (\n    <Comp\n      ref={ref}\n      aria-hidden=\"true\"\n      className={cn(\"text-muted-foreground\", className)}\n      {...separatorProps}\n    >\n      {children ?? \":\"}\n    </Comp>\n  );\n}\n\nfunction Clear(props: ButtonProps) {\n  const { asChild, className, children, ref, ...clearProps } = props;\n  const { disabled, readOnly } = useRootContext(CLEAR_NAME);\n  const store = useStoreContext(CLEAR_NAME);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      clearProps.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      event.preventDefault();\n      if (disabled || readOnly) return;\n      store.setState(\"value\", \"\");\n    },\n    [clearProps.onClick, disabled, readOnly, store],\n  );\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      onClick={onClick}\n      disabled={disabled || readOnly}\n      className={cn(\n        \"inline-flex items-center justify-center rounded-sm font-medium text-sm transition-colors hover:bg-accent hover:text-accent-foreground disabled:pointer-events-none disabled:opacity-50\",\n        className,\n      )}\n      {...clearProps}\n    >\n      {children ?? \"Clear\"}\n    </Comp>\n  );\n}\n\ntype SegmentType = \"hour\" | \"minute\" | \"second\" | \"period\";\n\ninterface InputProps2 extends Omit<InputProps, \"type\" | \"value\"> {\n  segment?: SegmentType;\n}\n\nfunction Input(props: InputProps2) {\n  const {\n    segment,\n    className,\n    ref,\n    onFocus: onFocusProp,\n    onBlur: onBlurProp,\n    onKeyDown: onKeyDownProp,\n    ...inputProps\n  } = props;\n  const { use12Hours, showSeconds, disabled, readOnly } =\n    useRootContext(INPUT_NAME);\n  const store = useStoreContext(INPUT_NAME);\n\n  const value = useStore((state) => state.value);\n  const timeValue = parseTimeString(value, use12Hours);\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const composedRef = useComposedRefs(ref, inputRef);\n\n  const getSegmentValue = React.useCallback(() => {\n    if (!timeValue) return \"\";\n    switch (segment) {\n      case \"hour\":\n        return timeValue.hour.toString().padStart(2, \"0\");\n      case \"minute\":\n        return timeValue.minute.toString().padStart(2, \"0\");\n      case \"second\":\n        return timeValue.second.toString().padStart(2, \"0\");\n      case \"period\":\n        return timeValue.period ?? \"AM\";\n      default:\n        return \"\";\n    }\n  }, [timeValue, segment]);\n\n  const [editValue, setEditValue] = React.useState(getSegmentValue());\n  const [isEditing, setIsEditing] = React.useState(false);\n\n  React.useEffect(() => {\n    if (!isEditing) {\n      setEditValue(getSegmentValue());\n    }\n  }, [getSegmentValue, isEditing]);\n\n  const updateTimeValue = React.useCallback(\n    (newSegmentValue: string) => {\n      const currentTime = timeValue ?? {\n        hour: use12Hours ? 12 : 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\" as const,\n      };\n\n      const newTime = { ...currentTime };\n\n      switch (segment) {\n        case \"hour\": {\n          const hour = Number.parseInt(newSegmentValue, 10);\n          if (!Number.isNaN(hour)) {\n            const maxHour = use12Hours ? 12 : 23;\n            const minHour = use12Hours ? 1 : 0;\n            const clampedHour = clamp(hour, minHour, maxHour);\n            newTime.hour = clampedHour;\n          }\n          break;\n        }\n        case \"minute\": {\n          const minute = Number.parseInt(newSegmentValue, 10);\n          if (!Number.isNaN(minute)) {\n            newTime.minute = clamp(minute, 0, 59);\n          }\n          break;\n        }\n        case \"second\": {\n          const second = Number.parseInt(newSegmentValue, 10);\n          if (!Number.isNaN(second)) {\n            newTime.second = clamp(second, 0, 59);\n          }\n          break;\n        }\n        case \"period\": {\n          if (newSegmentValue === \"AM\" || newSegmentValue === \"PM\") {\n            newTime.period = newSegmentValue;\n          }\n          break;\n        }\n      }\n\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    },\n    [timeValue, segment, use12Hours, showSeconds, store],\n  );\n\n  const onFocus = React.useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      onFocusProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsEditing(true);\n      // Always select the entire content like native time picker\n      queueMicrotask(() => event.target.select());\n    },\n    [onFocusProp],\n  );\n\n  const onBlur = React.useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      onBlurProp?.(event);\n      if (event.defaultPrevented) return;\n\n      setIsEditing(false);\n      if (editValue) {\n        updateTimeValue(editValue);\n      }\n      setEditValue(getSegmentValue());\n    },\n    [onBlurProp, editValue, updateTimeValue, getSegmentValue],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\n      onKeyDownProp?.(event);\n      if (event.defaultPrevented) return;\n\n      if (event.key === \"Enter\") {\n        event.preventDefault();\n        inputRef.current?.blur();\n      } else if (event.key === \"Escape\") {\n        event.preventDefault();\n        setEditValue(getSegmentValue());\n        inputRef.current?.blur();\n      } else if (event.key === \"ArrowUp\") {\n        event.preventDefault();\n        const currentValue = Number.parseInt(editValue, 10);\n        if (!Number.isNaN(currentValue)) {\n          let newValue: number;\n          switch (segment) {\n            case \"hour\":\n              newValue = use12Hours\n                ? currentValue === 12\n                  ? 1\n                  : currentValue + 1\n                : currentValue === 23\n                  ? 0\n                  : currentValue + 1;\n              break;\n            case \"minute\":\n            case \"second\":\n              newValue = currentValue === 59 ? 0 : currentValue + 1;\n              break;\n            default:\n              return;\n          }\n          const formattedValue = newValue.toString().padStart(2, \"0\");\n          setEditValue(formattedValue);\n          updateTimeValue(formattedValue);\n        }\n      } else if (event.key === \"ArrowDown\") {\n        event.preventDefault();\n        const currentValue = Number.parseInt(editValue, 10);\n        if (!Number.isNaN(currentValue)) {\n          let newValue: number;\n          switch (segment) {\n            case \"hour\":\n              newValue = use12Hours\n                ? currentValue === 1\n                  ? 12\n                  : currentValue - 1\n                : currentValue === 0\n                  ? 23\n                  : currentValue - 1;\n              break;\n            case \"minute\":\n            case \"second\":\n              newValue = currentValue === 0 ? 59 : currentValue - 1;\n              break;\n            default:\n              return;\n          }\n          const formattedValue = newValue.toString().padStart(2, \"0\");\n          setEditValue(formattedValue);\n          updateTimeValue(formattedValue);\n        }\n      } else if (segment === \"period\") {\n        const key = event.key.toLowerCase();\n        if (key === \"a\" || key === \"p\") {\n          event.preventDefault();\n          const newPeriod = key === \"a\" ? \"AM\" : \"PM\";\n          setEditValue(newPeriod);\n          updateTimeValue(newPeriod);\n        } else if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n          event.preventDefault();\n          const currentPeriod = editValue || \"AM\";\n          const newPeriod = currentPeriod === \"AM\" ? \"PM\" : \"AM\";\n          setEditValue(newPeriod);\n          updateTimeValue(newPeriod);\n        }\n      }\n    },\n    [\n      onKeyDownProp,\n      editValue,\n      segment,\n      use12Hours,\n      getSegmentValue,\n      updateTimeValue,\n    ],\n  );\n\n  const onChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = event.target.value;\n\n      // For period, just accept 'a', 'A', 'p', 'P' and convert immediately\n      if (segment === \"period\") {\n        const firstChar = newValue.charAt(0).toUpperCase();\n        if (firstChar === \"A\") {\n          setEditValue(\"AM\");\n          updateTimeValue(\"AM\");\n        } else if (firstChar === \"P\") {\n          setEditValue(\"PM\");\n          updateTimeValue(\"PM\");\n        }\n        return;\n      }\n\n      setEditValue(newValue);\n    },\n    [segment, updateTimeValue],\n  );\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLInputElement>) => {\n      // Select all on click, like native time picker\n      event.currentTarget.select();\n    },\n    [],\n  );\n\n  const displayValue = isEditing ? editValue : getSegmentValue();\n\n  return (\n    <input\n      ref={composedRef}\n      type=\"text\"\n      value={displayValue}\n      onChange={onChange}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onKeyDown={onKeyDown}\n      onClick={onClick}\n      disabled={disabled}\n      readOnly={readOnly}\n      className={cn(\n        \"inline-flex h-full min-w-[2.5ch] items-center justify-center rounded border-0 bg-transparent px-0.5 text-center text-sm tabular-nums focus:bg-accent focus:outline-none disabled:cursor-not-allowed disabled:opacity-50\",\n        segment === \"period\" && \"min-w-[3ch]\",\n        className,\n      )}\n      {...inputProps}\n    />\n  );\n}\n\nexport {\n  Root,\n  Label,\n  InputGroup,\n  Trigger,\n  Content,\n  Hour,\n  Minute,\n  Second,\n  Period,\n  Separator,\n  Clear,\n  Input,\n  //\n  Root as TimePicker,\n  //\n  type RootProps as TimePickerProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}