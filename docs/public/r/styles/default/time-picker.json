{
  "name": "time-picker",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "ui/time-picker.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\n\nconst ROOT_NAME = \"TimePicker\";\nconst LABEL_NAME = \"TimePickerLabel\";\nconst TRIGGER_NAME = \"TimePickerTrigger\";\nconst CONTENT_NAME = \"TimePickerContent\";\nconst HOUR_NAME = \"TimePickerHour\";\nconst MINUTE_NAME = \"TimePickerMinute\";\nconst SECOND_NAME = \"TimePickerSecond\";\nconst PERIOD_NAME = \"TimePickerPeriod\";\nconst SEPARATOR_NAME = \"TimePickerSeparator\";\nconst CLEAR_NAME = \"TimePickerClear\";\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\ninterface TimeValue {\n  hour: number;\n  minute: number;\n  second: number;\n  period?: \"AM\" | \"PM\";\n}\n\nfunction parseTimeString(\n  timeString: string | undefined,\n  use12Hours: boolean,\n): TimeValue | null {\n  if (!timeString) return null;\n\n  const parts = timeString.split(\":\");\n  if (parts.length < 2) return null;\n\n  let hour = Number.parseInt(parts[0] ?? \"0\", 10);\n  const minute = Number.parseInt(parts[1] ?? \"0\", 10);\n  const second = parts[2] ? Number.parseInt(parts[2], 10) : 0;\n\n  if (Number.isNaN(hour) || Number.isNaN(minute) || Number.isNaN(second)) {\n    return null;\n  }\n\n  let period: \"AM\" | \"PM\" | undefined;\n  if (use12Hours) {\n    period = hour >= 12 ? \"PM\" : \"AM\";\n    hour = hour % 12 || 12;\n  }\n\n  return { hour, minute, second, period };\n}\n\nfunction formatTimeValue(\n  value: TimeValue,\n  showSeconds: boolean,\n  use12Hours: boolean,\n): string {\n  let hour = value.hour;\n\n  if (use12Hours) {\n    const isPM = value.period === \"PM\";\n    hour = hour === 12 ? (isPM ? 12 : 0) : isPM ? hour + 12 : hour;\n  }\n\n  const hourStr = hour.toString().padStart(2, \"0\");\n  const minuteStr = value.minute.toString().padStart(2, \"0\");\n  const secondStr = value.second.toString().padStart(2, \"0\");\n\n  if (showSeconds) {\n    return `${hourStr}:${minuteStr}:${secondStr}`;\n  }\n  return `${hourStr}:${minuteStr}`;\n}\n\ninterface StoreState {\n  value: string;\n  open: boolean;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nfunction createStore(\n  listenersRef: React.RefObject<Set<() => void>>,\n  stateRef: React.RefObject<StoreState>,\n  onValueChange?: (value: string) => void,\n  onOpenChange?: (open: boolean) => void,\n): Store {\n  const store: Store = {\n    subscribe: (cb) => {\n      if (listenersRef.current) {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current?.delete(cb);\n      }\n      return () => {};\n    },\n    getState: () =>\n      stateRef.current ?? {\n        value: \"\",\n        open: false,\n      },\n    setState: (key, value) => {\n      const state = stateRef.current;\n      if (!state || Object.is(state[key], value)) return;\n\n      if (key === \"value\" && typeof value === \"string\") {\n        state.value = value;\n        onValueChange?.(value);\n      } else if (key === \"open\" && typeof value === \"boolean\") {\n        state.open = value;\n        onOpenChange?.(value);\n      } else {\n        state[key] = value;\n      }\n\n      store.notify();\n    },\n    notify: () => {\n      if (listenersRef.current) {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      }\n    },\n  };\n\n  return store;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`${consumerName} must be rendered inside TimePicker`);\n  }\n  return context;\n}\n\nfunction useStoreSelector<T>(\n  store: Store,\n  selector: (state: StoreState) => T,\n): T {\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface RootContextValue {\n  id: string;\n  name?: string;\n  disabled: boolean;\n  readOnly: boolean;\n  required: boolean;\n  invalid: boolean;\n  showSeconds: boolean;\n  use12Hours: boolean;\n  minuteStep: number;\n  secondStep: number;\n  hourStep: number;\n  placeholder: string;\n  min?: string;\n  max?: string;\n  triggerRef: React.RefObject<HTMLButtonElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n}\n\nconst RootContext = React.createContext<RootContextValue | null>(null);\n\nfunction useRootContext(consumerName: string) {\n  const context = React.useContext(RootContext);\n  if (!context) {\n    throw new Error(`${consumerName} must be rendered inside TimePicker`);\n  }\n  return context;\n}\n\nexport interface RootProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  id?: string;\n  defaultValue?: string;\n  value?: string;\n  onValueChange?: (value: string) => void;\n  name?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  required?: boolean;\n  invalid?: boolean;\n  min?: string;\n  max?: string;\n  showSeconds?: boolean;\n  use12Hours?: boolean;\n  minuteStep?: number;\n  secondStep?: number;\n  hourStep?: number;\n  placeholder?: string;\n  asChild?: boolean;\n}\n\nconst Root = React.forwardRef<HTMLDivElement, RootProps>(\n  function Root(props, forwardedRef) {\n    const {\n      id: idProp,\n      defaultValue = \"\",\n      value: valueProp,\n      onValueChange,\n      name,\n      disabled = false,\n      readOnly = false,\n      required = false,\n      invalid = false,\n      min,\n      max,\n      showSeconds = false,\n      use12Hours = false,\n      minuteStep = 1,\n      secondStep = 1,\n      hourStep = 1,\n      placeholder = \"Select time\",\n      asChild,\n      className,\n      ...rootProps\n    } = props;\n\n    const id = React.useId();\n    const generatedId = idProp ?? id;\n\n    const listenersRef = useLazyRef(() => new Set<() => void>());\n    const stateRef = useLazyRef(() => ({\n      value: valueProp ?? defaultValue,\n      open: false,\n    }));\n\n    const isControlled = valueProp !== undefined;\n\n    React.useEffect(() => {\n      if (isControlled && stateRef.current) {\n        stateRef.current.value = valueProp;\n      }\n    }, [isControlled, valueProp, stateRef]);\n\n    const store = React.useMemo(\n      () => createStore(listenersRef, stateRef, onValueChange),\n      [listenersRef, stateRef, onValueChange],\n    );\n\n    const triggerRef = React.useRef<HTMLButtonElement>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n\n    const rootContext: RootContextValue = React.useMemo(\n      () => ({\n        id: generatedId,\n        name,\n        disabled,\n        readOnly,\n        required,\n        invalid,\n        showSeconds,\n        use12Hours,\n        minuteStep,\n        secondStep,\n        hourStep,\n        placeholder,\n        min,\n        max,\n        triggerRef,\n        contentRef,\n      }),\n      [\n        generatedId,\n        name,\n        disabled,\n        readOnly,\n        required,\n        invalid,\n        showSeconds,\n        use12Hours,\n        minuteStep,\n        secondStep,\n        hourStep,\n        placeholder,\n        min,\n        max,\n      ],\n    );\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <StoreContext.Provider value={store}>\n        <RootContext.Provider value={rootContext}>\n          <Comp\n            ref={forwardedRef}\n            className={cn(\"relative\", className)}\n            {...rootProps}\n          />\n        </RootContext.Provider>\n      </StoreContext.Provider>\n    );\n  },\n);\n\nRoot.displayName = ROOT_NAME;\n\nexport interface LabelProps extends React.ComponentPropsWithoutRef<\"label\"> {\n  asChild?: boolean;\n}\n\nconst Label = React.forwardRef<HTMLLabelElement, LabelProps>(\n  function Label(props, forwardedRef) {\n    const { asChild, className, ...labelProps } = props;\n    const { id } = useRootContext(LABEL_NAME);\n\n    const Comp = asChild ? Slot : \"label\";\n\n    return (\n      <Comp\n        ref={forwardedRef}\n        htmlFor={`${id}-trigger`}\n        className={cn(\n          \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\n          className,\n        )}\n        {...labelProps}\n      />\n    );\n  },\n);\n\nLabel.displayName = LABEL_NAME;\n\nexport interface TriggerProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst Trigger = React.forwardRef<HTMLButtonElement, TriggerProps>(\n  function Trigger(props, forwardedRef) {\n    const { asChild, className, children, ...triggerProps } = props;\n    const {\n      id,\n      disabled,\n      readOnly,\n      invalid,\n      placeholder,\n      triggerRef,\n      name,\n      required,\n    } = useRootContext(TRIGGER_NAME);\n    const store = useStoreContext(TRIGGER_NAME);\n\n    const value = useStoreSelector(store, (state) => state.value);\n    const open = useStoreSelector(store, (state) => state.open);\n\n    const ref = useComposedRefs(forwardedRef, triggerRef);\n\n    const onPointerDown = (event: React.PointerEvent<HTMLButtonElement>) => {\n      if (disabled || readOnly) return;\n      event.preventDefault();\n      store.setState(\"open\", !open);\n    };\n\n    const onKeyDown = (event: React.KeyboardEvent<HTMLButtonElement>) => {\n      if (disabled || readOnly) return;\n\n      if (event.key === \"Enter\" || event.key === \" \") {\n        event.preventDefault();\n        store.setState(\"open\", !open);\n      } else if (event.key === \"Escape\" && open) {\n        event.preventDefault();\n        store.setState(\"open\", false);\n      }\n    };\n\n    const Comp = asChild ? Slot : \"button\";\n\n    return (\n      <>\n        <Comp\n          ref={ref}\n          id={`${id}-trigger`}\n          type=\"button\"\n          role=\"combobox\"\n          aria-expanded={open}\n          aria-haspopup=\"dialog\"\n          aria-invalid={invalid}\n          disabled={disabled}\n          data-state={open ? \"open\" : \"closed\"}\n          data-disabled={disabled ? \"\" : undefined}\n          data-readonly={readOnly ? \"\" : undefined}\n          data-invalid={invalid ? \"\" : undefined}\n          onPointerDown={onPointerDown}\n          onKeyDown={onKeyDown}\n          className={cn(\n            \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n            className,\n          )}\n          {...triggerProps}\n        >\n          {children ?? (\n            <span className={cn(!value && \"text-muted-foreground\")}>\n              {value || placeholder}\n            </span>\n          )}\n        </Comp>\n        {name && (\n          <VisuallyHiddenInput\n            name={name}\n            value={value}\n            required={required}\n            disabled={disabled}\n            readOnly={readOnly}\n            control={null}\n          />\n        )}\n      </>\n    );\n  },\n);\n\nTrigger.displayName = TRIGGER_NAME;\n\nexport interface ContentProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  side?: \"top\" | \"right\" | \"bottom\" | \"left\";\n  align?: \"start\" | \"center\" | \"end\";\n  asChild?: boolean;\n}\n\nconst Content = React.forwardRef<HTMLDivElement, ContentProps>(\n  function Content(props, forwardedRef) {\n    const {\n      asChild,\n      side = \"bottom\",\n      align = \"start\",\n      className,\n      ...contentProps\n    } = props;\n    const { contentRef, triggerRef, disabled } = useRootContext(CONTENT_NAME);\n    const store = useStoreContext(CONTENT_NAME);\n\n    const open = useStoreSelector(store, (state) => state.open);\n\n    const ref = useComposedRefs(forwardedRef, contentRef);\n\n    React.useEffect(() => {\n      if (!open) return;\n\n      function onPointerDown(event: PointerEvent) {\n        const target = event.target as Node;\n        if (\n          contentRef.current?.contains(target) ||\n          triggerRef.current?.contains(target)\n        ) {\n          return;\n        }\n        store.setState(\"open\", false);\n      }\n\n      function onKeyDown(event: KeyboardEvent) {\n        if (event.key === \"Escape\") {\n          store.setState(\"open\", false);\n        }\n      }\n\n      document.addEventListener(\"pointerdown\", onPointerDown);\n      document.addEventListener(\"keydown\", onKeyDown);\n\n      return () => {\n        document.removeEventListener(\"pointerdown\", onPointerDown);\n        document.removeEventListener(\"keydown\", onKeyDown);\n      };\n    }, [open, store, contentRef, triggerRef]);\n\n    if (!open || disabled) return null;\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <Comp\n        ref={ref}\n        data-state={open ? \"open\" : \"closed\"}\n        data-side={side}\n        data-align={align}\n        className={cn(\n          \"absolute z-50 mt-1 min-w-[200px] rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none\",\n          className,\n        )}\n        {...contentProps}\n      />\n    );\n  },\n);\n\nContent.displayName = CONTENT_NAME;\n\nexport interface HourProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  format?: \"numeric\" | \"2-digit\";\n  asChild?: boolean;\n}\n\nconst Hour = React.forwardRef<HTMLDivElement, HourProps>(\n  function Hour(props, forwardedRef) {\n    const { asChild, format = \"numeric\", className, ...hourProps } = props;\n    const { use12Hours, hourStep } = useRootContext(HOUR_NAME);\n    const store = useStoreContext(HOUR_NAME);\n\n    const value = useStoreSelector(store, (state) => state.value);\n    const timeValue = parseTimeString(value, use12Hours);\n\n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const ref = useComposedRefs(forwardedRef, containerRef);\n\n    const maxHour = use12Hours ? 12 : 23;\n    const hours = Array.from(\n      { length: Math.ceil((maxHour + 1) / hourStep) },\n      (_, i) => {\n        const hour = i * hourStep;\n        return use12Hours ? (hour === 0 ? 12 : hour) : hour;\n      },\n    );\n\n    const onHourSelect = (hour: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, hour };\n      const newValue = formatTimeValue(newTime, false, use12Hours);\n      store.setState(\"value\", newValue);\n    };\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <Comp\n        ref={ref}\n        className={cn(\"flex flex-col gap-1\", className)}\n        {...hourProps}\n      >\n        <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n          Hour\n        </div>\n        <div className=\"max-h-[200px] space-y-1 overflow-y-auto\">\n          {hours.map((hour) => {\n            const isSelected = timeValue?.hour === hour;\n            return (\n              <button\n                key={hour}\n                type=\"button\"\n                onClick={() => onHourSelect(hour)}\n                className={cn(\n                  \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground\",\n                  isSelected &&\n                    \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n                )}\n              >\n                {format === \"2-digit\" ? hour.toString().padStart(2, \"0\") : hour}\n              </button>\n            );\n          })}\n        </div>\n      </Comp>\n    );\n  },\n);\n\nHour.displayName = HOUR_NAME;\n\nexport interface MinuteProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  format?: \"numeric\" | \"2-digit\";\n  asChild?: boolean;\n}\n\nconst Minute = React.forwardRef<HTMLDivElement, MinuteProps>(\n  function Minute(props, forwardedRef) {\n    const { asChild, format = \"2-digit\", className, ...minuteProps } = props;\n    const { use12Hours, minuteStep, showSeconds } = useRootContext(MINUTE_NAME);\n    const store = useStoreContext(MINUTE_NAME);\n\n    const value = useStoreSelector(store, (state) => state.value);\n    const timeValue = parseTimeString(value, use12Hours);\n\n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const ref = useComposedRefs(forwardedRef, containerRef);\n\n    const minutes = Array.from(\n      { length: Math.ceil(60 / minuteStep) },\n      (_, i) => i * minuteStep,\n    );\n\n    const onMinuteSelect = (minute: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, minute };\n      const newValue = formatTimeValue(newTime, showSeconds, use12Hours);\n      store.setState(\"value\", newValue);\n    };\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <Comp\n        ref={ref}\n        className={cn(\"flex flex-col gap-1\", className)}\n        {...minuteProps}\n      >\n        <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n          Minute\n        </div>\n        <div className=\"max-h-[200px] space-y-1 overflow-y-auto\">\n          {minutes.map((minute) => {\n            const isSelected = timeValue?.minute === minute;\n            return (\n              <button\n                key={minute}\n                type=\"button\"\n                onClick={() => onMinuteSelect(minute)}\n                className={cn(\n                  \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground\",\n                  isSelected &&\n                    \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n                )}\n              >\n                {format === \"2-digit\"\n                  ? minute.toString().padStart(2, \"0\")\n                  : minute}\n              </button>\n            );\n          })}\n        </div>\n      </Comp>\n    );\n  },\n);\n\nMinute.displayName = MINUTE_NAME;\n\nexport interface SecondProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  format?: \"numeric\" | \"2-digit\";\n  asChild?: boolean;\n}\n\nconst Second = React.forwardRef<HTMLDivElement, SecondProps>(\n  function Second(props, forwardedRef) {\n    const { asChild, format = \"2-digit\", className, ...secondProps } = props;\n    const { use12Hours, secondStep } = useRootContext(SECOND_NAME);\n    const store = useStoreContext(SECOND_NAME);\n\n    const value = useStoreSelector(store, (state) => state.value);\n    const timeValue = parseTimeString(value, use12Hours);\n\n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const ref = useComposedRefs(forwardedRef, containerRef);\n\n    const seconds = Array.from(\n      { length: Math.ceil(60 / secondStep) },\n      (_, i) => i * secondStep,\n    );\n\n    const onSecondSelect = (second: number) => {\n      const currentTime = timeValue ?? {\n        hour: 0,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, second };\n      const newValue = formatTimeValue(newTime, true, use12Hours);\n      store.setState(\"value\", newValue);\n    };\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <Comp\n        ref={ref}\n        className={cn(\"flex flex-col gap-1\", className)}\n        {...secondProps}\n      >\n        <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n          Second\n        </div>\n        <div className=\"max-h-[200px] space-y-1 overflow-y-auto\">\n          {seconds.map((second) => {\n            const isSelected = timeValue?.second === second;\n            return (\n              <button\n                key={second}\n                type=\"button\"\n                onClick={() => onSecondSelect(second)}\n                className={cn(\n                  \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground\",\n                  isSelected &&\n                    \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n                )}\n              >\n                {format === \"2-digit\"\n                  ? second.toString().padStart(2, \"0\")\n                  : second}\n              </button>\n            );\n          })}\n        </div>\n      </Comp>\n    );\n  },\n);\n\nSecond.displayName = SECOND_NAME;\n\nexport interface PeriodProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst Period = React.forwardRef<HTMLDivElement, PeriodProps>(\n  function Period(props, forwardedRef) {\n    const { asChild, className, ...periodProps } = props;\n    const { use12Hours } = useRootContext(PERIOD_NAME);\n    const store = useStoreContext(PERIOD_NAME);\n\n    const value = useStoreSelector(store, (state) => state.value);\n    const timeValue = parseTimeString(value, use12Hours);\n\n    if (!use12Hours) return null;\n\n    const onPeriodToggle = (period: \"AM\" | \"PM\") => {\n      const currentTime = timeValue ?? {\n        hour: 12,\n        minute: 0,\n        second: 0,\n        period: \"AM\",\n      };\n      const newTime = { ...currentTime, period };\n      const newValue = formatTimeValue(newTime, false, use12Hours);\n      store.setState(\"value\", newValue);\n    };\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <Comp\n        ref={forwardedRef}\n        className={cn(\"flex flex-col gap-1\", className)}\n        {...periodProps}\n      >\n        <div className=\"mb-1 font-medium text-muted-foreground text-xs\">\n          Period\n        </div>\n        <div className=\"space-y-1\">\n          {([\"AM\", \"PM\"] as const).map((period) => {\n            const isSelected = timeValue?.period === period;\n            return (\n              <button\n                key={period}\n                type=\"button\"\n                onClick={() => onPeriodToggle(period)}\n                className={cn(\n                  \"w-full rounded px-3 py-1.5 text-left text-sm transition-colors hover:bg-accent hover:text-accent-foreground\",\n                  isSelected &&\n                    \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground\",\n                )}\n              >\n                {period}\n              </button>\n            );\n          })}\n        </div>\n      </Comp>\n    );\n  },\n);\n\nPeriod.displayName = PERIOD_NAME;\n\nexport interface SeparatorProps extends React.ComponentPropsWithoutRef<\"span\"> {\n  asChild?: boolean;\n}\n\nconst Separator = React.forwardRef<HTMLSpanElement, SeparatorProps>(\n  function Separator(props, forwardedRef) {\n    const { asChild, className, children, ...separatorProps } = props;\n\n    const Comp = asChild ? Slot : \"span\";\n\n    return (\n      <Comp\n        ref={forwardedRef}\n        aria-hidden=\"true\"\n        className={cn(\"text-muted-foreground\", className)}\n        {...separatorProps}\n      >\n        {children ?? \":\"}\n      </Comp>\n    );\n  },\n);\n\nSeparator.displayName = SEPARATOR_NAME;\n\nexport interface ClearProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst Clear = React.forwardRef<HTMLButtonElement, ClearProps>(\n  function Clear(props, forwardedRef) {\n    const { asChild, className, children, ...clearProps } = props;\n    const { disabled, readOnly } = useRootContext(CLEAR_NAME);\n    const store = useStoreContext(CLEAR_NAME);\n\n    const onClick = (event: React.MouseEvent<HTMLButtonElement>) => {\n      event.preventDefault();\n      if (disabled || readOnly) return;\n      store.setState(\"value\", \"\");\n    };\n\n    const Comp = asChild ? Slot : \"button\";\n\n    return (\n      <Comp\n        ref={forwardedRef}\n        type=\"button\"\n        onClick={onClick}\n        disabled={disabled || readOnly}\n        className={cn(\n          \"inline-flex items-center justify-center rounded-sm font-medium text-sm transition-colors hover:bg-accent hover:text-accent-foreground disabled:pointer-events-none disabled:opacity-50\",\n          className,\n        )}\n        {...clearProps}\n      >\n        {children ?? \"Clear\"}\n      </Comp>\n    );\n  },\n);\n\nClear.displayName = CLEAR_NAME;\n\nexport {\n  Root,\n  Label,\n  Trigger,\n  Content,\n  Hour,\n  Minute,\n  Second,\n  Period,\n  Separator,\n  Clear,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}