{
  "name": "file-upload",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/file-upload.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport {\n  FileArchiveIcon,\n  FileAudioIcon,\n  FileCodeIcon,\n  FileCogIcon,\n  FileIcon,\n  FileTextIcon,\n  FileVideoIcon,\n} from \"lucide-react\";\nimport * as React from \"react\";\n\nconst ROOT_NAME = \"FileUpload\";\nconst DROPZONE_NAME = \"FileUploadDropzone\";\nconst TRIGGER_NAME = \"FileUploadTrigger\";\nconst LIST_NAME = \"FileUploadList\";\nconst ITEM_NAME = \"FileUploadItem\";\nconst ITEM_PREVIEW_NAME = \"FileUploadItemPreview\";\nconst ITEM_METADATA_NAME = \"FileUploadItemMetadata\";\nconst ITEM_PROGRESS_NAME = \"FileUploadItemProgress\";\nconst ITEM_DELETE_NAME = \"FileUploadItemDelete\";\n\nconst FILE_UPLOAD_ERRORS = {\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` must be used as root component`,\n  [DROPZONE_NAME]: `\\`${DROPZONE_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [TRIGGER_NAME]: `\\`${TRIGGER_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [LIST_NAME]: `\\`${LIST_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [ITEM_NAME]: `\\`${ITEM_NAME}\\` must be within \\`${ROOT_NAME}\\``,\n  [ITEM_PREVIEW_NAME]: `\\`${ITEM_PREVIEW_NAME}\\` must be within \\`${ITEM_NAME}\\``,\n  [ITEM_METADATA_NAME]: `\\`${ITEM_METADATA_NAME}\\` must be within \\`${ITEM_NAME}\\``,\n  [ITEM_PROGRESS_NAME]: `\\`${ITEM_PROGRESS_NAME}\\` must be within \\`${ITEM_NAME}\\``,\n  [ITEM_DELETE_NAME]: `\\`${ITEM_DELETE_NAME}\\` must be within \\`${ITEM_NAME}\\``,\n} as const;\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nfunction useAsRef<T>(data: T) {\n  const ref = React.useRef<T>(data);\n  useIsomorphicLayoutEffect(() => {\n    ref.current = data;\n  });\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n  return ref as React.RefObject<T>;\n}\n\ntype Direction = \"ltr\" | \"rtl\";\n\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\nfunction useDirection(dirProp?: Direction): Direction {\n  const contextDir = React.useContext(DirectionContext);\n  return dirProp ?? contextDir ?? \"ltr\";\n}\n\ninterface FileState {\n  file: File;\n  progress: number;\n  error?: string;\n  status: \"idle\" | \"uploading\" | \"error\" | \"success\";\n}\n\ninterface StoreState {\n  files: Map<File, FileState>;\n  dragOver: boolean;\n  invalid: boolean;\n}\n\ntype StoreAction =\n  | { variant: \"ADD_FILES\"; files: File[] }\n  | { variant: \"SET_FILES\"; files: File[] }\n  | { variant: \"SET_PROGRESS\"; file: File; progress: number }\n  | { variant: \"SET_SUCCESS\"; file: File }\n  | { variant: \"SET_ERROR\"; file: File; error: string }\n  | { variant: \"REMOVE_FILE\"; file: File }\n  | { variant: \"SET_DRAG_OVER\"; dragOver: boolean }\n  | { variant: \"SET_INVALID\"; invalid: boolean }\n  | { variant: \"CLEAR\" };\n\nfunction createStore(\n  listeners: Set<() => void>,\n  files: Map<File, FileState>,\n  onFilesChange?: (files: File[]) => void,\n  invalid?: boolean,\n) {\n  const initialState: StoreState = {\n    files,\n    dragOver: false,\n    invalid: invalid ?? false,\n  };\n\n  let state = initialState;\n\n  function reducer(state: StoreState, action: StoreAction): StoreState {\n    switch (action.variant) {\n      case \"ADD_FILES\": {\n        for (const file of action.files) {\n          files.set(file, {\n            file,\n            progress: 0,\n            status: \"idle\",\n          });\n        }\n\n        if (onFilesChange) {\n          const fileList = Array.from(files.values()).map(\n            (fileState) => fileState.file,\n          );\n          onFilesChange(fileList);\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_FILES\": {\n        for (const file of action.files) {\n          const existingState = files.get(file);\n          if (!existingState) {\n            files.set(file, {\n              file,\n              progress: 0,\n              status: \"idle\",\n            });\n          }\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_PROGRESS\": {\n        const fileState = files.get(action.file);\n        if (fileState) {\n          files.set(action.file, {\n            ...fileState,\n            progress: action.progress,\n            status: \"uploading\",\n          });\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_SUCCESS\": {\n        const fileState = files.get(action.file);\n        if (fileState) {\n          files.set(action.file, {\n            ...fileState,\n            progress: 100,\n            status: \"success\",\n          });\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_ERROR\": {\n        const fileState = files.get(action.file);\n        if (fileState) {\n          files.set(action.file, {\n            ...fileState,\n            error: action.error,\n            status: \"error\",\n          });\n        }\n        return { ...state, files };\n      }\n\n      case \"REMOVE_FILE\": {\n        files.delete(action.file);\n\n        if (onFilesChange) {\n          const fileList = Array.from(files.values()).map(\n            (fileState) => fileState.file,\n          );\n          onFilesChange(fileList);\n        }\n        return { ...state, files };\n      }\n\n      case \"SET_DRAG_OVER\": {\n        return { ...state, dragOver: action.dragOver };\n      }\n\n      case \"SET_INVALID\": {\n        return { ...state, invalid: action.invalid };\n      }\n\n      case \"CLEAR\": {\n        files.clear();\n        if (onFilesChange) {\n          onFilesChange([]);\n        }\n        return { ...state, files, invalid: false };\n      }\n\n      default:\n        return state;\n    }\n  }\n\n  function getState() {\n    return state;\n  }\n\n  function dispatch(action: StoreAction) {\n    state = reducer(state, action);\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n\n  function subscribe(listener: () => void) {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  }\n\n  return { getState, dispatch, subscribe };\n}\n\nconst StoreContext = React.createContext<ReturnType<typeof createStore> | null>(\n  null,\n);\nStoreContext.displayName = ROOT_NAME;\n\nfunction useStoreContext(name: keyof typeof FILE_UPLOAD_ERRORS) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(FILE_UPLOAD_ERRORS[name]);\n  }\n  return context;\n}\n\nfunction useStore<T>(selector: (state: StoreState) => T): T {\n  const store = useStoreContext(ROOT_NAME);\n\n  const lastValueRef = useLazyRef<{ value: T; state: StoreState } | null>(\n    () => null,\n  );\n\n  const getSnapshot = React.useCallback(() => {\n    const state = store.getState();\n    const prevValue = lastValueRef.current;\n\n    if (prevValue && prevValue.state === state) {\n      return prevValue.value;\n    }\n\n    const nextValue = selector(state);\n    lastValueRef.current = { value: nextValue, state };\n    return nextValue;\n  }, [store, selector, lastValueRef]);\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface FileUploadContextValue {\n  inputId: string;\n  dropzoneId: string;\n  listId: string;\n  disabled: boolean;\n  inputRef: React.RefObject<HTMLInputElement | null>;\n  dir: Direction;\n}\n\nconst FileUploadContext = React.createContext<FileUploadContextValue | null>(\n  null,\n);\n\nfunction useFileUploadContext(name: keyof typeof FILE_UPLOAD_ERRORS) {\n  const context = React.useContext(FileUploadContext);\n  if (!context) {\n    throw new Error(FILE_UPLOAD_ERRORS[name]);\n  }\n  return context;\n}\n\ninterface FileUploadRootProps\n  extends Omit<\n    React.ComponentPropsWithoutRef<\"div\">,\n    \"defaultValue\" | \"onChange\"\n  > {\n  value?: File[];\n  defaultValue?: File[];\n  onValueChange?: (files: File[]) => void;\n  onAccept?: (files: File[]) => void;\n  onFileAccept?: (file: File) => void;\n  onFileReject?: (file: File, message: string) => void;\n  onFileValidate?: (file: File) => string | null | undefined;\n  onUpload?: (\n    files: File[],\n    options: {\n      onProgress: (file: File, progress: number) => void;\n      onSuccess: (file: File) => void;\n      onError: (file: File, error: Error) => void;\n    },\n  ) => Promise<void> | void;\n  accept?: string;\n  maxFiles?: number;\n  maxSize?: number;\n  dir?: Direction;\n  name?: string;\n  asChild?: boolean;\n  disabled?: boolean;\n  invalid?: boolean;\n  multiple?: boolean;\n  required?: boolean;\n}\n\nconst FileUploadRoot = React.forwardRef<HTMLDivElement, FileUploadRootProps>(\n  (props, forwardedRef) => {\n    const {\n      value,\n      defaultValue,\n      onValueChange,\n      onAccept,\n      onFileAccept,\n      onFileReject,\n      onFileValidate,\n      onUpload,\n      accept,\n      maxFiles,\n      maxSize,\n      dir: dirProp,\n      name,\n      asChild,\n      disabled = false,\n      invalid = false,\n      multiple = false,\n      required = false,\n      children,\n      className,\n      ...rootProps\n    } = props;\n\n    const id = React.useId();\n    const inputId = React.useId();\n    const dropzoneId = React.useId();\n    const listId = React.useId();\n\n    const dir = useDirection(dirProp);\n    const propsRef = useAsRef(props);\n    const listeners = useLazyRef(() => new Set<() => void>()).current;\n    const files = useLazyRef<Map<File, FileState>>(() => new Map()).current;\n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const isControlled = value !== undefined;\n\n    const store = React.useMemo(\n      () => createStore(listeners, files, onValueChange, invalid),\n      [listeners, files, onValueChange, invalid],\n    );\n\n    const contextValue = React.useMemo<FileUploadContextValue>(\n      () => ({\n        dropzoneId,\n        inputId,\n        listId,\n        dir,\n        disabled,\n        inputRef,\n      }),\n      [dropzoneId, inputId, listId, dir, disabled],\n    );\n\n    React.useEffect(() => {\n      if (isControlled) {\n        store.dispatch({ variant: \"SET_FILES\", files: value });\n      } else if (\n        defaultValue &&\n        defaultValue.length > 0 &&\n        !store.getState().files.size\n      ) {\n        store.dispatch({ variant: \"SET_FILES\", files: defaultValue });\n      }\n    }, [value, defaultValue, isControlled, store]);\n\n    const onFilesChange = React.useCallback(\n      (originalFiles: File[]) => {\n        if (propsRef.current.disabled) return;\n\n        let filesToProcess = [...originalFiles];\n        let invalid = false;\n\n        if (propsRef.current.maxFiles) {\n          const currentCount = store.getState().files.size;\n          const remainingSlotCount = Math.max(\n            0,\n            propsRef.current.maxFiles - currentCount,\n          );\n\n          if (remainingSlotCount < filesToProcess.length) {\n            const rejectedFiles = filesToProcess.slice(remainingSlotCount);\n            invalid = true;\n\n            filesToProcess = filesToProcess.slice(0, remainingSlotCount);\n\n            for (const file of rejectedFiles) {\n              let rejectionMessage = `Maximum ${propsRef.current.maxFiles} files allowed`;\n\n              if (propsRef.current.onFileValidate) {\n                const validationMessage = propsRef.current.onFileValidate(file);\n                if (validationMessage) {\n                  rejectionMessage = validationMessage;\n                }\n              }\n\n              propsRef.current.onFileReject?.(file, rejectionMessage);\n            }\n          }\n        }\n\n        const acceptedFiles: File[] = [];\n        const rejectedFiles: { file: File; message: string }[] = [];\n\n        for (const file of filesToProcess) {\n          let rejected = false;\n          let rejectionMessage = \"\";\n\n          if (propsRef.current.onFileValidate) {\n            const validationMessage = propsRef.current.onFileValidate(file);\n            if (validationMessage) {\n              rejectionMessage = validationMessage;\n              propsRef.current.onFileReject?.(file, rejectionMessage);\n              rejected = true;\n              invalid = true;\n              continue;\n            }\n          }\n\n          if (propsRef.current.accept) {\n            const acceptTypes = propsRef.current.accept\n              .split(\",\")\n              .map((t) => t.trim());\n            const fileType = file.type;\n            const fileExtension = `.${file.name.split(\".\").pop()}`;\n\n            if (\n              !acceptTypes.some(\n                (type) =>\n                  type === fileType ||\n                  type === fileExtension ||\n                  (type.includes(\"/*\") &&\n                    fileType.startsWith(type.replace(\"/*\", \"/\"))),\n              )\n            ) {\n              rejectionMessage = \"File type not accepted\";\n              propsRef.current.onFileReject?.(file, rejectionMessage);\n              rejected = true;\n              invalid = true;\n            }\n          }\n\n          if (\n            propsRef.current.maxSize &&\n            file.size > propsRef.current.maxSize\n          ) {\n            rejectionMessage = \"File too large\";\n            propsRef.current.onFileReject?.(file, rejectionMessage);\n            rejected = true;\n            invalid = true;\n          }\n\n          if (!rejected) {\n            acceptedFiles.push(file);\n          } else {\n            rejectedFiles.push({ file, message: rejectionMessage });\n          }\n        }\n\n        if (invalid) {\n          store.dispatch({ variant: \"SET_INVALID\", invalid });\n          setTimeout(() => {\n            store.dispatch({ variant: \"SET_INVALID\", invalid: false });\n          }, 2000);\n        }\n\n        if (acceptedFiles.length > 0) {\n          store.dispatch({ variant: \"ADD_FILES\", files: acceptedFiles });\n\n          if (isControlled && propsRef.current.onValueChange) {\n            const currentFiles = Array.from(\n              store.getState().files.values(),\n            ).map((f) => f.file);\n            propsRef.current.onValueChange([...currentFiles]);\n          }\n\n          if (propsRef.current.onAccept) {\n            propsRef.current.onAccept(acceptedFiles);\n          }\n\n          for (const file of acceptedFiles) {\n            propsRef.current.onFileAccept?.(file);\n          }\n\n          if (propsRef.current.onUpload) {\n            requestAnimationFrame(() => {\n              onFilesUpload(acceptedFiles);\n            });\n          }\n        }\n      },\n      [store, isControlled, propsRef],\n    );\n\n    const onFilesUpload = React.useCallback(\n      async (files: File[]) => {\n        try {\n          for (const file of files) {\n            store.dispatch({ variant: \"SET_PROGRESS\", file, progress: 0 });\n          }\n\n          if (propsRef.current.onUpload) {\n            await propsRef.current.onUpload(files, {\n              onProgress: (file, progress) => {\n                store.dispatch({\n                  variant: \"SET_PROGRESS\",\n                  file,\n                  progress: Math.min(Math.max(0, progress), 100),\n                });\n              },\n              onSuccess: (file) => {\n                store.dispatch({ variant: \"SET_SUCCESS\", file });\n              },\n              onError: (file, error) => {\n                store.dispatch({\n                  variant: \"SET_ERROR\",\n                  file,\n                  error: error.message ?? \"Upload failed\",\n                });\n              },\n            });\n          } else {\n            for (const file of files) {\n              store.dispatch({ variant: \"SET_SUCCESS\", file });\n            }\n          }\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : \"Upload failed\";\n          for (const file of files) {\n            store.dispatch({\n              variant: \"SET_ERROR\",\n              file,\n              error: errorMessage,\n            });\n          }\n        }\n      },\n      [store, propsRef.current.onUpload],\n    );\n\n    const onInputChange = React.useCallback(\n      (event: React.ChangeEvent<HTMLInputElement>) => {\n        const files = Array.from(event.target.files ?? []);\n        onFilesChange(files);\n        event.target.value = \"\";\n      },\n      [onFilesChange],\n    );\n\n    const RootPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <DirectionContext.Provider value={dir}>\n        <StoreContext.Provider value={store}>\n          <FileUploadContext.Provider value={contextValue}>\n            <RootPrimitive\n              data-disabled={disabled ? \"\" : undefined}\n              data-slot=\"file-upload\"\n              dir={dir}\n              {...rootProps}\n              id={id}\n              ref={forwardedRef}\n              className={cn(\"relative flex flex-col gap-2\", className)}\n            >\n              {children}\n              <input\n                type=\"file\"\n                id={inputId}\n                aria-controls={dropzoneId}\n                ref={inputRef}\n                tabIndex={-1}\n                accept={accept}\n                name={name}\n                disabled={disabled}\n                multiple={multiple}\n                required={required}\n                className=\"sr-only\"\n                onChange={onInputChange}\n              />\n            </RootPrimitive>\n          </FileUploadContext.Provider>\n        </StoreContext.Provider>\n      </DirectionContext.Provider>\n    );\n  },\n);\nFileUploadRoot.displayName = ROOT_NAME;\n\ninterface FileUploadDropzoneProps\n  extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst FileUploadDropzone = React.forwardRef<\n  HTMLDivElement,\n  FileUploadDropzoneProps\n>((props, forwardedRef) => {\n  const { asChild, className, ...dropzoneProps } = props;\n\n  const context = useFileUploadContext(DROPZONE_NAME);\n  const store = useStoreContext(DROPZONE_NAME);\n  const dragOver = useStore((state) => state.dragOver);\n  const invalid = useStore((state) => state.invalid);\n  const propsRef = useAsRef(dropzoneProps);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      propsRef.current?.onClick?.(event);\n\n      if (!event.defaultPrevented) {\n        const target = event.target;\n\n        const isFromTrigger =\n          target instanceof HTMLElement &&\n          target.closest('[data-slot=\"file-upload-trigger\"]');\n\n        if (!isFromTrigger) {\n          context.inputRef.current?.click();\n        }\n      }\n    },\n    [context.inputRef, propsRef],\n  );\n\n  const onDragOver = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      propsRef.current?.onDragOver?.(event);\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n        store.dispatch({ variant: \"SET_DRAG_OVER\", dragOver: true });\n      }\n    },\n    [store, propsRef.current.onDragOver],\n  );\n\n  const onDragEnter = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      propsRef.current?.onDragEnter?.(event);\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n        store.dispatch({ variant: \"SET_DRAG_OVER\", dragOver: true });\n      }\n    },\n    [store, propsRef.current.onDragEnter],\n  );\n\n  const onDragLeave = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      propsRef.current?.onDragLeave?.(event);\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n        store.dispatch({ variant: \"SET_DRAG_OVER\", dragOver: false });\n      }\n    },\n    [store, propsRef.current.onDragLeave],\n  );\n\n  const onDrop = React.useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      propsRef.current?.onDrop?.(event);\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n        store.dispatch({ variant: \"SET_DRAG_OVER\", dragOver: false });\n\n        const files = Array.from(event.dataTransfer.files);\n        const inputElement = context.inputRef.current;\n        if (!inputElement) return;\n\n        const dataTransfer = new DataTransfer();\n        for (const file of files) {\n          dataTransfer.items.add(file);\n        }\n\n        inputElement.files = dataTransfer.files;\n        inputElement.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    },\n    [store, context.inputRef, propsRef.current.onDrop],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      propsRef.current?.onKeyDown?.(event);\n\n      if (\n        !event.defaultPrevented &&\n        (event.key === \"Enter\" || event.key === \" \")\n      ) {\n        event.preventDefault();\n        context.inputRef.current?.click();\n      }\n    },\n    [context.inputRef, propsRef.current.onKeyDown],\n  );\n\n  const DropzonePrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <DropzonePrimitive\n      role=\"region\"\n      id={context.dropzoneId}\n      aria-controls={context.inputId}\n      aria-disabled={context.disabled}\n      aria-invalid={invalid}\n      aria-owns={context.listId}\n      data-disabled={context.disabled ? \"\" : undefined}\n      data-dragging={dragOver ? \"\" : undefined}\n      data-invalid={invalid ? \"\" : undefined}\n      data-slot=\"file-upload-dropzone\"\n      dir={context.dir}\n      {...dropzoneProps}\n      ref={forwardedRef}\n      tabIndex={context.disabled ? undefined : 0}\n      className={cn(\n        \"relative flex select-none flex-col items-center justify-center gap-2 rounded-lg border-2 border-dashed p-6 outline-none transition-colors hover:bg-accent/30 focus-visible:border-ring/50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 data-[disabled]:pointer-events-none data-[dragging]:border-primary\",\n        className,\n      )}\n      onClick={onClick}\n      onDragEnter={onDragEnter}\n      onDragLeave={onDragLeave}\n      onDragOver={onDragOver}\n      onDrop={onDrop}\n      onKeyDown={onKeyDown}\n    />\n  );\n});\nFileUploadDropzone.displayName = DROPZONE_NAME;\n\ninterface FileUploadTriggerProps\n  extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst FileUploadTrigger = React.forwardRef<\n  HTMLButtonElement,\n  FileUploadTriggerProps\n>((props, forwardedRef) => {\n  const { asChild, ...triggerProps } = props;\n  const context = useFileUploadContext(TRIGGER_NAME);\n  const propsRef = useAsRef(triggerProps);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      propsRef.current?.onClick?.(event);\n\n      if (!event.defaultPrevented) {\n        context.inputRef.current?.click();\n      }\n    },\n    [context.inputRef, propsRef.current],\n  );\n\n  const TriggerPrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <TriggerPrimitive\n      type=\"button\"\n      aria-controls={context.inputId}\n      data-disabled={context.disabled ? \"\" : undefined}\n      data-slot=\"file-upload-trigger\"\n      {...triggerProps}\n      ref={forwardedRef}\n      disabled={context.disabled}\n      onClick={onClick}\n    />\n  );\n});\nFileUploadTrigger.displayName = TRIGGER_NAME;\n\ninterface FileUploadListProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  orientation?: \"horizontal\" | \"vertical\";\n  asChild?: boolean;\n  forceMount?: boolean;\n}\n\nconst FileUploadList = React.forwardRef<HTMLDivElement, FileUploadListProps>(\n  (props, forwardedRef) => {\n    const {\n      className,\n      orientation = \"vertical\",\n      asChild,\n      forceMount,\n      ...listProps\n    } = props;\n\n    const context = useFileUploadContext(LIST_NAME);\n\n    const shouldRender =\n      forceMount || useStore((state) => state.files.size > 0);\n\n    if (!shouldRender) return null;\n\n    const ListPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <ListPrimitive\n        role=\"list\"\n        id={context.listId}\n        aria-orientation={orientation}\n        data-orientation={orientation}\n        data-slot=\"file-upload-list\"\n        data-state={shouldRender ? \"active\" : \"inactive\"}\n        dir={context.dir}\n        {...listProps}\n        ref={forwardedRef}\n        className={cn(\n          \"data-[state=inactive]:fade-out-0 data-[state=active]:fade-in-0 data-[state=inactive]:slide-out-to-top-2 data-[state=active]:slide-in-from-top-2 flex flex-col gap-2 data-[state=active]:animate-in data-[state=inactive]:animate-out\",\n          orientation === \"horizontal\" && \"flex-row overflow-x-auto p-1.5\",\n          className,\n        )}\n      />\n    );\n  },\n);\nFileUploadList.displayName = LIST_NAME;\n\ninterface FileUploadItemContextValue {\n  id: string;\n  fileState: FileState | undefined;\n  nameId: string;\n  sizeId: string;\n  statusId: string;\n  messageId: string;\n}\n\nconst FileUploadItemContext =\n  React.createContext<FileUploadItemContextValue | null>(null);\n\nfunction useFileUploadItemContext(name: keyof typeof FILE_UPLOAD_ERRORS) {\n  const context = React.useContext(FileUploadItemContext);\n  if (!context) {\n    throw new Error(FILE_UPLOAD_ERRORS[name]);\n  }\n  return context;\n}\n\ninterface FileUploadItemProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  value: File;\n  asChild?: boolean;\n}\n\nconst FileUploadItem = React.forwardRef<HTMLDivElement, FileUploadItemProps>(\n  (props, forwardedRef) => {\n    const { value, asChild, className, ...itemProps } = props;\n\n    const id = React.useId();\n    const statusId = `${id}-status`;\n    const nameId = `${id}-name`;\n    const sizeId = `${id}-size`;\n    const messageId = `${id}-message`;\n\n    const context = useFileUploadContext(ITEM_NAME);\n    const fileState = useStore((state) => state.files.get(value));\n    const fileCount = useStore((state) => state.files.size);\n    const fileIndex = useStore((state) => {\n      const files = Array.from(state.files.keys());\n      return files.indexOf(value) + 1;\n    });\n\n    const itemContext = React.useMemo(\n      () => ({\n        id,\n        fileState,\n        nameId,\n        sizeId,\n        statusId,\n        messageId,\n      }),\n      [id, fileState, statusId, nameId, sizeId, messageId],\n    );\n\n    if (!fileState) return null;\n\n    const statusText = fileState.error\n      ? `Error: ${fileState.error}`\n      : fileState.status === \"uploading\"\n        ? `Uploading: ${fileState.progress}% complete`\n        : fileState.status === \"success\"\n          ? \"Upload complete\"\n          : \"Ready to upload\";\n\n    const ItemPrimitive = asChild ? Slot : \"div\";\n\n    return (\n      <FileUploadItemContext.Provider value={itemContext}>\n        <ItemPrimitive\n          role=\"listitem\"\n          id={id}\n          aria-setsize={fileCount}\n          aria-posinset={fileIndex}\n          aria-describedby={`${nameId} ${sizeId} ${statusId} ${\n            fileState.error ? messageId : \"\"\n          }`}\n          aria-labelledby={nameId}\n          data-slot=\"file-upload-item\"\n          dir={context.dir}\n          {...itemProps}\n          ref={forwardedRef}\n          className={cn(\n            \"relative flex items-center gap-2.5 rounded-md border p-3 has-[_[data-slot=file-upload-progress]]:flex-col has-[_[data-slot=file-upload-progress]]:items-start\",\n            className,\n          )}\n        >\n          {props.children}\n          <span id={statusId} className=\"sr-only\">\n            {statusText}\n          </span>\n        </ItemPrimitive>\n      </FileUploadItemContext.Provider>\n    );\n  },\n);\nFileUploadItem.displayName = ITEM_NAME;\n\nfunction formatBytes(bytes: number) {\n  if (bytes === 0) return \"0 B\";\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return `${(bytes / 1024 ** i).toFixed(i ? 1 : 0)} ${sizes[i]}`;\n}\n\nfunction getFileIcon(file: File) {\n  const type = file.type;\n  const extension = file.name.split(\".\").pop()?.toLowerCase() || \"\";\n\n  if (type.startsWith(\"video/\")) {\n    return <FileVideoIcon />;\n  }\n\n  if (type.startsWith(\"audio/\")) {\n    return <FileAudioIcon />;\n  }\n\n  if (\n    type.startsWith(\"text/\") ||\n    [\"txt\", \"md\", \"rtf\", \"pdf\"].includes(extension)\n  ) {\n    return <FileTextIcon />;\n  }\n\n  if (\n    [\n      \"html\",\n      \"css\",\n      \"js\",\n      \"jsx\",\n      \"ts\",\n      \"tsx\",\n      \"json\",\n      \"xml\",\n      \"php\",\n      \"py\",\n      \"rb\",\n      \"java\",\n      \"c\",\n      \"cpp\",\n      \"cs\",\n    ].includes(extension)\n  ) {\n    return <FileCodeIcon />;\n  }\n\n  if ([\"zip\", \"rar\", \"7z\", \"tar\", \"gz\", \"bz2\"].includes(extension)) {\n    return <FileArchiveIcon />;\n  }\n\n  if (\n    [\"exe\", \"msi\", \"app\", \"apk\", \"deb\", \"rpm\"].includes(extension) ||\n    type.startsWith(\"application/\")\n  ) {\n    return <FileCogIcon />;\n  }\n\n  return <FileIcon />;\n}\n\ninterface FileUploadItemPreviewProps\n  extends React.ComponentPropsWithoutRef<\"div\"> {\n  render?: (file: File) => React.ReactNode;\n  asChild?: boolean;\n}\n\nconst FileUploadItemPreview = React.forwardRef<\n  HTMLDivElement,\n  FileUploadItemPreviewProps\n>((props, forwardedRef) => {\n  const { render, asChild, children, className, ...previewProps } = props;\n\n  const itemContext = useFileUploadItemContext(ITEM_PREVIEW_NAME);\n\n  const isImage = itemContext.fileState?.file.type.startsWith(\"image/\");\n\n  const onPreviewRender = React.useCallback(\n    (file: File) => {\n      if (render) return render(file);\n\n      if (isImage) {\n        return (\n          <img\n            src={URL.createObjectURL(file)}\n            alt={file.name}\n            className=\"size-full rounded object-cover\"\n            onLoad={(event) => {\n              if (!(event.target instanceof HTMLImageElement)) return;\n              URL.revokeObjectURL(event.target.src);\n            }}\n          />\n        );\n      }\n\n      return getFileIcon(file);\n    },\n    [isImage, render],\n  );\n\n  if (!itemContext.fileState) return null;\n\n  const ItemPreviewPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemPreviewPrimitive\n      aria-labelledby={itemContext.nameId}\n      data-slot=\"file-upload-preview\"\n      {...previewProps}\n      ref={forwardedRef}\n      className={cn(\n        \"relative flex size-10 shrink-0 items-center justify-center rounded-md\",\n        isImage ? \"object-cover\" : \"bg-accent/50 [&>svg]:size-7\",\n        className,\n      )}\n    >\n      {onPreviewRender(itemContext.fileState.file)}\n      {children}\n    </ItemPreviewPrimitive>\n  );\n});\nFileUploadItemPreview.displayName = ITEM_PREVIEW_NAME;\n\ninterface FileUploadItemMetadataProps\n  extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n}\n\nconst FileUploadItemMetadata = React.forwardRef<\n  HTMLDivElement,\n  FileUploadItemMetadataProps\n>((props, forwardedRef) => {\n  const { asChild, children, className, ...metadataProps } = props;\n\n  const context = useFileUploadContext(ITEM_METADATA_NAME);\n  const itemContext = useFileUploadItemContext(ITEM_METADATA_NAME);\n\n  if (!itemContext.fileState) return null;\n\n  const ItemMetadataPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ItemMetadataPrimitive\n      data-slot=\"file-upload-metadata\"\n      dir={context.dir}\n      {...metadataProps}\n      ref={forwardedRef}\n      className={cn(\"flex min-w-0 flex-1 flex-col\", className)}\n    >\n      {children ?? (\n        <>\n          <span\n            id={itemContext.nameId}\n            className=\"truncate font-medium text-sm\"\n          >\n            {itemContext.fileState.file.name}\n          </span>\n          <span\n            id={itemContext.sizeId}\n            className=\"text-muted-foreground text-xs\"\n          >\n            {formatBytes(itemContext.fileState.file.size)}\n          </span>\n          {itemContext.fileState.error && (\n            <span\n              id={itemContext.messageId}\n              className=\"text-destructive text-xs\"\n            >\n              {itemContext.fileState.error}\n            </span>\n          )}\n        </>\n      )}\n    </ItemMetadataPrimitive>\n  );\n});\nFileUploadItemMetadata.displayName = ITEM_METADATA_NAME;\n\ninterface FileUploadItemProgressProps\n  extends React.ComponentPropsWithoutRef<\"div\"> {\n  asChild?: boolean;\n  circular?: boolean;\n  size?: number;\n}\n\nconst FileUploadItemProgress = React.forwardRef<\n  HTMLDivElement,\n  FileUploadItemProgressProps\n>((props, forwardedRef) => {\n  const { circular, size = 40, asChild, className, ...progressProps } = props;\n\n  const itemContext = useFileUploadItemContext(ITEM_PROGRESS_NAME);\n\n  if (!itemContext.fileState) return null;\n\n  const ItemProgressPrimitive = asChild ? Slot : \"div\";\n\n  if (circular) {\n    if (itemContext.fileState.status === \"success\") return null;\n\n    const circumference = 2 * Math.PI * ((size - 4) / 2);\n    const strokeDashoffset =\n      circumference - (itemContext.fileState.progress / 100) * circumference;\n\n    return (\n      <ItemProgressPrimitive\n        role=\"progressbar\"\n        aria-valuemin={0}\n        aria-valuemax={100}\n        aria-valuenow={itemContext.fileState.progress}\n        aria-valuetext={`${itemContext.fileState.progress}%`}\n        aria-labelledby={itemContext.nameId}\n        data-slot=\"file-upload-progress\"\n        {...progressProps}\n        ref={forwardedRef}\n        className={cn(\n          \"-translate-x-1/2 -translate-y-1/2 absolute top-1/2 left-1/2\",\n          className,\n        )}\n      >\n        <svg\n          className=\"rotate-[-90deg] transform\"\n          width={size}\n          height={size}\n          viewBox={`0 0 ${size} ${size}`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n        >\n          <circle\n            className=\"text-primary/20\"\n            strokeWidth=\"2\"\n            cx={size / 2}\n            cy={size / 2}\n            r={(size - 4) / 2}\n          />\n          <circle\n            className=\"text-primary transition-all\"\n            strokeWidth=\"2\"\n            strokeLinecap=\"round\"\n            strokeDasharray={circumference}\n            strokeDashoffset={strokeDashoffset}\n            cx={size / 2}\n            cy={size / 2}\n            r={(size - 4) / 2}\n          />\n        </svg>\n      </ItemProgressPrimitive>\n    );\n  }\n\n  return (\n    <ItemProgressPrimitive\n      role=\"progressbar\"\n      aria-valuemin={0}\n      aria-valuemax={100}\n      aria-valuenow={itemContext.fileState.progress}\n      aria-valuetext={`${itemContext.fileState.progress}%`}\n      aria-labelledby={itemContext.nameId}\n      data-slot=\"file-upload-progress\"\n      {...progressProps}\n      ref={forwardedRef}\n      className={cn(\n        \"relative h-1.5 w-full overflow-hidden rounded-full bg-primary/20\",\n        className,\n      )}\n    >\n      <div\n        className=\"h-full w-full flex-1 bg-primary transition-all\"\n        style={{\n          transform: `translateX(-${100 - itemContext.fileState.progress}%)`,\n        }}\n      />\n    </ItemProgressPrimitive>\n  );\n});\nFileUploadItemProgress.displayName = ITEM_PROGRESS_NAME;\n\ninterface FileUploadItemDeleteProps\n  extends React.ComponentPropsWithoutRef<\"button\"> {\n  asChild?: boolean;\n}\n\nconst FileUploadItemDelete = React.forwardRef<\n  HTMLButtonElement,\n  FileUploadItemDeleteProps\n>((props, forwardedRef) => {\n  const { asChild, ...deleteProps } = props;\n\n  const store = useStoreContext(ITEM_DELETE_NAME);\n  const itemContext = useFileUploadItemContext(ITEM_DELETE_NAME);\n  const propsRef = useAsRef(deleteProps);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      propsRef.current?.onClick?.(event);\n\n      if (!itemContext.fileState) return;\n\n      if (!event.defaultPrevented) {\n        store.dispatch({\n          variant: \"REMOVE_FILE\",\n          file: itemContext.fileState.file,\n        });\n      }\n    },\n    [store, itemContext.fileState, propsRef.current?.onClick],\n  );\n\n  if (!itemContext.fileState) return null;\n\n  const ItemDeletePrimitive = asChild ? Slot : \"button\";\n\n  return (\n    <ItemDeletePrimitive\n      type=\"button\"\n      aria-controls={itemContext.id}\n      aria-describedby={itemContext.nameId}\n      data-slot=\"file-upload-item-delete\"\n      {...deleteProps}\n      ref={forwardedRef}\n      onClick={onClick}\n    />\n  );\n});\nFileUploadItemDelete.displayName = ITEM_DELETE_NAME;\n\nconst FileUpload = FileUploadRoot;\nconst Root = FileUploadRoot;\nconst Trigger = FileUploadTrigger;\nconst Dropzone = FileUploadDropzone;\nconst List = FileUploadList;\nconst Item = FileUploadItem;\nconst ItemPreview = FileUploadItemPreview;\nconst ItemMetadata = FileUploadItemMetadata;\nconst ItemProgress = FileUploadItemProgress;\nconst ItemDelete = FileUploadItemDelete;\n\nexport {\n  FileUpload,\n  FileUploadDropzone,\n  FileUploadTrigger,\n  FileUploadList,\n  FileUploadItem,\n  FileUploadItemPreview,\n  FileUploadItemMetadata,\n  FileUploadItemProgress,\n  FileUploadItemDelete,\n  //\n  Root,\n  Dropzone,\n  Trigger,\n  List,\n  Item,\n  ItemPreview,\n  ItemMetadata,\n  ItemProgress,\n  ItemDelete,\n  useStore as useFileUpload,\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}