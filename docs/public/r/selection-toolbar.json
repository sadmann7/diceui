{
  "name": "selection-toolbar",
  "dependencies": [
    "@floating-ui/react-dom",
    "@radix-ui/react-slot"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/selection-toolbar.tsx",
      "content": "\"use client\";\n\nimport {\n  autoUpdate,\n  flip,\n  type Middleware,\n  offset,\n  type Placement,\n  shift,\n  useFloating,\n} from \"@floating-ui/react-dom\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Button } from \"@/components/ui/button\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\nimport { useAsRef } from \"@/registry/default/hooks/use-as-ref\";\nimport { useIsomorphicLayoutEffect } from \"@/registry/default/hooks/use-isomorphic-layout-effect\";\nimport { useLazyRef } from \"@/registry/default/hooks/use-lazy-ref\";\n\nconst ROOT_NAME = \"SelectionToolbar\";\nconst ITEM_NAME = \"SelectionToolbarItem\";\n\nconst SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"] as const;\nconst ALIGN_OPTIONS = [\"start\", \"center\", \"end\"] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ntype ItemElement = React.ComponentRef<typeof SelectionToolbarItem>;\n\ninterface SelectionRect {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\ninterface StoreState {\n  open: boolean;\n  selectedText: string;\n  selectionRect: SelectionRect | null;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(\n  selector: (state: StoreState) => T,\n  ogStore?: Store | null,\n): T {\n  const contextStore = React.useContext(StoreContext);\n\n  const store = ogStore ?? contextStore;\n\n  if (!store) {\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface SelectionToolbarProps extends DivProps {\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  onSelectionChange?: (text: string) => void;\n  container?: HTMLElement | null;\n  portalContainer?: Element | DocumentFragment | null;\n  sideOffset?: number;\n}\n\nfunction SelectionToolbar(props: SelectionToolbarProps) {\n  const {\n    open: openProp,\n    onOpenChange,\n    onSelectionChange,\n    container: containerProp,\n    portalContainer: portalContainerProp,\n    sideOffset = 8,\n    className,\n    style,\n    ref,\n    asChild,\n    children,\n    ...rootProps\n  } = props;\n\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const stateRef = useLazyRef<StoreState>(() => ({\n    open: openProp ?? false,\n    selectedText: \"\",\n    selectionRect: null,\n  }));\n\n  const propsRef = useAsRef({\n    onOpenChange,\n    onSelectionChange,\n  });\n\n  const store = React.useMemo<Store>(() => {\n    return {\n      subscribe: (callback) => {\n        listenersRef.current.add(callback);\n        return () => listenersRef.current.delete(callback);\n      },\n      getState: () => stateRef.current,\n      setState: (key, value) => {\n        if (Object.is(stateRef.current[key], value)) return;\n\n        if (key === \"open\" && typeof value === \"boolean\") {\n          stateRef.current.open = value;\n          propsRef.current.onOpenChange?.(value);\n        } else if (key === \"selectedText\" && typeof value === \"string\") {\n          stateRef.current.selectedText = value;\n          propsRef.current.onSelectionChange?.(value);\n        } else {\n          stateRef.current[key] = value;\n        }\n\n        store.notify();\n      },\n      notify: () => {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      },\n    };\n  }, [listenersRef, stateRef, propsRef]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (openProp !== undefined) {\n      store.setState(\"open\", openProp);\n    }\n  }, [openProp]);\n\n  const open = useStore((state) => state.open, store);\n  const selectionRect = useStore((state) => state.selectionRect, store);\n\n  const rafRef = React.useRef<number | null>(null);\n\n  const mounted = React.useSyncExternalStore(\n    () => () => {},\n    () => true,\n    () => false,\n  );\n\n  const virtualElement = React.useMemo(() => {\n    if (!selectionRect) return null;\n\n    return {\n      getBoundingClientRect: () => ({\n        x: selectionRect.left,\n        y: selectionRect.top,\n        width: selectionRect.width,\n        height: selectionRect.height,\n        top: selectionRect.top,\n        left: selectionRect.left,\n        right: selectionRect.left + selectionRect.width,\n        bottom: selectionRect.top + selectionRect.height,\n      }),\n    };\n  }, [selectionRect]);\n\n  const transformOrigin = React.useMemo<Middleware>(\n    () => ({\n      name: \"transformOrigin\",\n      fn(data) {\n        const { placement, rects } = data;\n        const [placedSide, placedAlign] =\n          getSideAndAlignFromPlacement(placement);\n        const noArrowAlign = { start: \"0%\", center: \"50%\", end: \"100%\" }[\n          placedAlign\n        ];\n\n        let x = \"\";\n        let y = \"\";\n\n        if (placedSide === \"bottom\") {\n          x = noArrowAlign;\n          y = \"0px\";\n        } else if (placedSide === \"top\") {\n          x = noArrowAlign;\n          y = `${rects.floating.height}px`;\n        } else if (placedSide === \"right\") {\n          x = \"0px\";\n          y = noArrowAlign;\n        } else if (placedSide === \"left\") {\n          x = `${rects.floating.width}px`;\n          y = noArrowAlign;\n        }\n        return { data: { x, y } };\n      },\n    }),\n    [],\n  );\n\n  const { refs, floatingStyles, isPositioned, middlewareData } = useFloating({\n    open: open && !!virtualElement,\n    placement: \"top\",\n    strategy: \"fixed\",\n    middleware: [\n      offset(sideOffset),\n      flip({\n        fallbackPlacements: [\"bottom\", \"top\"],\n        padding: 8,\n      }),\n      shift({\n        padding: 8,\n      }),\n      transformOrigin,\n    ],\n    whileElementsMounted: autoUpdate,\n    elements: {\n      reference: virtualElement,\n    },\n  });\n\n  const composedRef = useComposedRefs(ref);\n\n  const updateSelection = React.useCallback(() => {\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0) {\n      store.setState(\"open\", false);\n      store.setState(\"selectedText\", \"\");\n      store.setState(\"selectionRect\", null);\n      return;\n    }\n\n    const text = selection.toString().trim();\n    if (!text) {\n      store.setState(\"open\", false);\n      store.setState(\"selectedText\", \"\");\n      store.setState(\"selectionRect\", null);\n      return;\n    }\n\n    // Check if selection is within container\n    if (containerProp) {\n      const range = selection.getRangeAt(0);\n      const commonAncestor = range.commonAncestorContainer;\n      const element =\n        commonAncestor.nodeType === Node.ELEMENT_NODE\n          ? (commonAncestor as Element)\n          : commonAncestor.parentElement;\n\n      if (!element || !containerProp.contains(element)) {\n        store.setState(\"open\", false);\n        store.setState(\"selectedText\", \"\");\n        store.setState(\"selectionRect\", null);\n        return;\n      }\n    }\n\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n\n    store.setState(\"selectedText\", text);\n    store.setState(\"selectionRect\", {\n      top: rect.top,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height,\n    });\n    store.setState(\"open\", true);\n  }, [containerProp, store]);\n\n  React.useEffect(() => {\n    const container = containerProp ?? document;\n\n    function onMouseUp() {\n      // Small delay to ensure selection is complete\n      requestAnimationFrame(() => {\n        updateSelection();\n      });\n    }\n\n    function onSelectionChange() {\n      const selection = window.getSelection();\n      if (!selection || !selection.toString().trim()) {\n        store.setState(\"open\", false);\n        store.setState(\"selectedText\", \"\");\n        store.setState(\"selectionRect\", null);\n      }\n    }\n\n    function onScroll() {\n      if (rafRef.current !== null) return;\n      rafRef.current = requestAnimationFrame(() => {\n        if (store.getState().open) {\n          updateSelection();\n        }\n        rafRef.current = null;\n      });\n    }\n\n    container.addEventListener(\"mouseup\", onMouseUp);\n    document.addEventListener(\"selectionchange\", onSelectionChange);\n    window.addEventListener(\"scroll\", onScroll, { passive: true });\n\n    return () => {\n      container.removeEventListener(\"mouseup\", onMouseUp);\n      document.removeEventListener(\"selectionchange\", onSelectionChange);\n      window.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [containerProp, store, updateSelection]);\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    function onMouseDown(event: MouseEvent) {\n      const target = event.target as Node;\n      if (refs.floating.current && !refs.floating.current.contains(target)) {\n        const selection = window.getSelection();\n        if (selection) {\n          selection.removeAllRanges();\n        }\n        store.setState(\"open\", false);\n      }\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (event.key === \"Escape\") {\n        const selection = window.getSelection();\n        if (selection) {\n          selection.removeAllRanges();\n        }\n        store.setState(\"open\", false);\n      }\n    }\n\n    document.addEventListener(\"mousedown\", onMouseDown);\n    document.addEventListener(\"keydown\", onKeyDown);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", onMouseDown);\n      document.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [open, store, refs.floating]);\n\n  const portalContainer =\n    portalContainerProp ?? (mounted ? globalThis.document?.body : null);\n\n  if (!portalContainer || !open) return null;\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StoreContext.Provider value={store}>\n      {ReactDOM.createPortal(\n        <div\n          ref={refs.setFloating}\n          style={{\n            ...floatingStyles,\n            // Keep off-page when measuring to prevent janky initial position\n            transform: isPositioned\n              ? floatingStyles.transform\n              : \"translate(0, -200%)\",\n          }}\n          data-state={isPositioned ? \"positioned\" : \"measuring\"}\n        >\n          <RootPrimitive\n            role=\"toolbar\"\n            aria-label=\"Text formatting toolbar\"\n            data-slot=\"selection-toolbar\"\n            {...rootProps}\n            ref={composedRef}\n            className={cn(\n              \"flex items-center gap-1 rounded-lg border bg-card px-1.5 py-1.5 shadow-lg outline-none\",\n              isPositioned &&\n                \"fade-in-0 zoom-in-95 animate-in duration-200 [animation-timing-function:cubic-bezier(0.16,1,0.3,1)]\",\n              \"motion-reduce:animate-none motion-reduce:transition-none\",\n              className,\n            )}\n            style={{\n              // Set transform origin based on placement for smooth animations\n              transformOrigin: middlewareData.transformOrigin\n                ? `${middlewareData.transformOrigin.x} ${middlewareData.transformOrigin.y}`\n                : undefined,\n              ...style,\n            }}\n          >\n            {children}\n          </RootPrimitive>\n        </div>,\n        portalContainer,\n      )}\n    </StoreContext.Provider>\n  );\n}\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side as Side, align as Align] as const;\n}\n\ninterface SelectionToolbarItemProps\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\n  onSelect?: (text: string, event: Event) => void;\n}\n\nfunction SelectionToolbarItem(props: SelectionToolbarItemProps) {\n  const {\n    onSelect,\n    onClick: onClickProp,\n    className,\n    ref,\n    ...itemProps\n  } = props;\n\n  const store = useStoreContext(ITEM_NAME);\n\n  const propsRef = useAsRef({\n    onSelect,\n    onClick: onClickProp,\n  });\n\n  const itemRef = React.useRef<ItemElement>(null);\n  const composedRef = useComposedRefs(ref, itemRef);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<ItemElement>) => {\n      propsRef.current.onClick?.(event);\n      if (event.defaultPrevented) return;\n\n      const item = itemRef.current;\n      if (!item) return;\n\n      const text = store.getState().selectedText;\n\n      const selectEvent = new CustomEvent(\"selectiontoolbar.select\", {\n        bubbles: true,\n        cancelable: true,\n        detail: { text },\n      });\n\n      item.addEventListener(\n        \"selectiontoolbar.select\",\n        (event) => propsRef.current.onSelect?.(text, event),\n        {\n          once: true,\n        },\n      );\n\n      item.dispatchEvent(selectEvent);\n    },\n    [propsRef, store],\n  );\n\n  return (\n    <Button\n      type=\"button\"\n      data-slot=\"selection-toolbar-item\"\n      variant=\"ghost\"\n      size=\"icon\"\n      {...itemProps}\n      className={cn(\"size-8\", className)}\n      ref={composedRef}\n      onClick={onClick}\n    />\n  );\n}\n\nfunction SelectionToolbarSeparator(props: DivProps) {\n  const { asChild, className, ...separatorProps } = props;\n\n  const SeparatorPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <SeparatorPrimitive\n      role=\"separator\"\n      aria-orientation=\"vertical\"\n      aria-hidden=\"true\"\n      data-slot=\"selection-toolbar-separator\"\n      {...separatorProps}\n      className={cn(\"mx-0.5 h-6 w-px bg-border\", className)}\n    />\n  );\n}\n\nexport {\n  SelectionToolbar,\n  SelectionToolbarItem,\n  SelectionToolbarSeparator,\n  //\n  useStore as useSelectionToolbar,\n  //\n  type SelectionToolbarProps,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}