{
  "name": "action-bar",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/action-bar.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"ActionBar\";\r\nconst ITEM_NAME = \"ActionBarItem\";\r\nconst CLOSE_NAME = \"ActionBarClose\";\r\nconst ITEM_SELECT = \"actionbar.itemSelect\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof ActionBarRoot>;\r\ntype ItemElement = React.ComponentRef<typeof ActionBarItem>;\r\ntype CloseElement = React.ComponentRef<typeof ActionBarClose>;\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\nfunction useAsRef<T>(props: T) {\r\n  const ref = React.useRef<T>(props);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = props;\r\n  });\r\n\r\n  return ref;\r\n}\r\n\r\ninterface ActionBarContextValue {\r\n  onOpenChange?: (open: boolean) => void;\r\n}\r\n\r\nconst ActionBarContext = React.createContext<ActionBarContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useActionBarContext(consumerName: string) {\r\n  const context = React.useContext(ActionBarContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface ActionBarRootProps extends DivProps {\r\n  open?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  align?: \"start\" | \"center\" | \"end\";\r\n  alignOffset?: number;\r\n  side?: \"top\" | \"bottom\";\r\n  sideOffset?: number;\r\n  portalContainer?: Element | DocumentFragment | null;\r\n}\r\n\r\nfunction ActionBarRoot(props: ActionBarRootProps) {\r\n  const {\r\n    open = false,\r\n    onOpenChange,\r\n    onEscapeKeyDown,\r\n    side = \"bottom\",\r\n    alignOffset = 0,\r\n    align = \"center\",\r\n    sideOffset = 16,\r\n    portalContainer: portalContainerProp,\r\n    className,\r\n    style,\r\n    ref,\r\n    asChild,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  const rootRef = React.useRef<RootElement>(null);\r\n  const composedRef = useComposedRefs(ref, rootRef);\r\n\r\n  const propsRef = useAsRef({\r\n    onEscapeKeyDown,\r\n    onOpenChange,\r\n  });\r\n\r\n  React.useLayoutEffect(() => {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    const ownerDocument = rootRef.current?.ownerDocument ?? document;\r\n\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (event.key === \"Escape\") {\r\n        propsRef.current.onEscapeKeyDown?.(event);\r\n        if (!event.defaultPrevented) {\r\n          propsRef.current.onOpenChange?.(false);\r\n        }\r\n      }\r\n    }\r\n\r\n    ownerDocument.addEventListener(\"keydown\", onKeyDown);\r\n    return () => ownerDocument.removeEventListener(\"keydown\", onKeyDown);\r\n  }, [open, propsRef]);\r\n\r\n  const contextValue = React.useMemo<ActionBarContextValue>(\r\n    () => ({\r\n      onOpenChange,\r\n    }),\r\n    [onOpenChange],\r\n  );\r\n\r\n  const portalContainer =\r\n    portalContainerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!portalContainer || !open) return null;\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ActionBarContext.Provider value={contextValue}>\r\n      {ReactDOM.createPortal(\r\n        <RootPrimitive\r\n          data-slot=\"action-bar\"\r\n          data-side={side}\r\n          data-align={align}\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\r\n            \"fixed z-50 flex items-center gap-2 rounded-lg border bg-card px-2 py-1.5 shadow-lg\",\r\n            \"fade-in-0 zoom-in-95 animate-in duration-250 [animation-timing-function:cubic-bezier(0.16,1,0.3,1)]\",\r\n            \"data-[side=bottom]:slide-in-from-bottom-4 data-[side=top]:slide-in-from-top-4\",\r\n            \"motion-reduce:animate-none motion-reduce:transition-none\",\r\n            className,\r\n          )}\r\n          style={{\r\n            [side]: `${sideOffset}px`,\r\n            ...(align === \"center\" && {\r\n              left: \"50%\",\r\n              translate: \"-50% 0\",\r\n            }),\r\n            ...(align === \"start\" && { left: `${alignOffset}px` }),\r\n            ...(align === \"end\" && { right: `${alignOffset}px` }),\r\n            ...style,\r\n          }}\r\n        />,\r\n        portalContainer,\r\n      )}\r\n    </ActionBarContext.Provider>\r\n  );\r\n}\r\n\r\nfunction ActionBarSelection(props: DivProps) {\r\n  const { className, asChild, ...selectionProps } = props;\r\n\r\n  const SelectionPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SelectionPrimitive\r\n      data-slot=\"action-bar-selection\"\r\n      {...selectionProps}\r\n      className={cn(\r\n        \"flex items-center gap-1 rounded-sm border px-2 py-1 font-medium text-sm\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ActionBarItemProps\r\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\r\n  onSelect?: (event: Event) => void;\r\n}\r\n\r\nfunction ActionBarItem(props: ActionBarItemProps) {\r\n  const { onSelect, onClick, ref, ...itemProps } = props;\r\n\r\n  const itemRef = React.useRef<ItemElement>(null);\r\n  const composedRef = useComposedRefs(ref, itemRef);\r\n\r\n  const { onOpenChange } = useActionBarContext(ITEM_NAME);\r\n\r\n  const onItemSelect = React.useCallback(() => {\r\n    const item = itemRef.current;\r\n    if (!item) return;\r\n\r\n    const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n    });\r\n\r\n    item.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), {\r\n      once: true,\r\n    });\r\n\r\n    item.dispatchEvent(itemSelectEvent);\r\n\r\n    if (!itemSelectEvent.defaultPrevented) {\r\n      onOpenChange?.(false);\r\n    }\r\n  }, [onOpenChange, onSelect]);\r\n\r\n  const onItemClick = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (onSelect) {\r\n        onItemSelect();\r\n      }\r\n    },\r\n    [onClick, onSelect, onItemSelect],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"action-bar-item\"\r\n      variant=\"secondary\"\r\n      size=\"sm\"\r\n      {...itemProps}\r\n      ref={composedRef}\r\n      onClick={onItemClick}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ActionBarCloseProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ActionBarClose(props: ActionBarCloseProps) {\r\n  const { asChild, className, onClick, ...closeProps } = props;\r\n\r\n  const { onOpenChange } = useActionBarContext(CLOSE_NAME);\r\n\r\n  const onCloseClick = React.useCallback(\r\n    (event: React.MouseEvent<CloseElement>) => {\r\n      onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      onOpenChange?.(false);\r\n    },\r\n    [onOpenChange, onClick],\r\n  );\r\n\r\n  const ClosePrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <ClosePrimitive\r\n      type=\"button\"\r\n      data-slot=\"action-bar-close\"\r\n      {...closeProps}\r\n      className={cn(\r\n        \"rounded-xs opacity-70 outline-none hover:opacity-100 focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring/50 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-3.5 [&_svg]:pointer-events-none [&_svg]:shrink-0\",\r\n        className,\r\n      )}\r\n      onClick={onCloseClick}\r\n    />\r\n  );\r\n}\r\n\r\nfunction ActionBarSeparator(props: DivProps) {\r\n  const { asChild, className, ...separatorProps } = props;\r\n\r\n  const SeparatorPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SeparatorPrimitive\r\n      role=\"separator\"\r\n      aria-orientation=\"vertical\"\r\n      data-slot=\"action-bar-separator\"\r\n      {...separatorProps}\r\n      className={cn(\r\n        \"in-data-[slot=action-bar-selection]:ml-0.5 h-6 in-data-[slot=action-bar-selection]:h-4 w-px bg-border\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  ActionBarRoot as Root,\r\n  ActionBarSelection as Selection,\r\n  ActionBarItem as Item,\r\n  ActionBarClose as Close,\r\n  ActionBarSeparator as Separator,\r\n  //\r\n  ActionBarRoot as ActionBar,\r\n  ActionBarSelection,\r\n  ActionBarItem,\r\n  ActionBarClose,\r\n  ActionBarSeparator,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/portal.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot, type SlotProps } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\n\r\ninterface PortalProps extends SlotProps {\r\n  container?: Element | DocumentFragment | null;\r\n}\r\n\r\nfunction Portal(props: PortalProps) {\r\n  const { container: containerProp, ...portalProps } = props;\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  React.useLayoutEffect(() => setMounted(true), []);\r\n\r\n  const container =\r\n    containerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!container) return null;\r\n\r\n  return ReactDOM.createPortal(<Slot {...portalProps} />, container);\r\n}\r\n\r\nexport { Portal };\r\n\r\nexport type { PortalProps };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}