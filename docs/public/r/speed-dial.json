{
  "name": "speed-dial",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "class-variance-authority"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "ui/speed-dial.tsx",
      "content": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport * as React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { cn } from \"@/lib/utils\";\n\nconst ROOT_NAME = \"SpeedDial\";\nconst TRIGGER_NAME = \"SpeedDialTrigger\";\nconst CONTENT_NAME = \"SpeedDialContent\";\nconst ITEM_NAME = \"SpeedDialItem\";\nconst ACTION_NAME = \"SpeedDialAction\";\nconst LABEL_NAME = \"SpeedDialLabel\";\n\nconst ACTION_SELECT = \"speeddial.actionSelect\";\nconst INTERACT_OUTSIDE = \"speeddial.interactOutside\";\nconst EVENT_OPTIONS = { bubbles: true, cancelable: true };\n\nconst DEFAULT_GAP = \"0.5rem\";\nconst DEFAULT_OFFSET = \"0.5rem\";\nconst DEFAULT_ITEM_DELAY = 50;\n\ntype Side = \"top\" | \"right\" | \"bottom\" | \"left\";\n\ninterface DivProps extends React.ComponentProps<\"div\"> {\n  asChild?: boolean;\n}\n\ntype RootElement = React.ComponentRef<typeof SpeedDialRoot>;\ntype TriggerElement = React.ComponentRef<typeof SpeedDialTrigger>;\ntype ActionElement = React.ComponentRef<typeof SpeedDialAction>;\n\ninterface InteractOutsideEvent extends CustomEvent {\n  detail: {\n    originalEvent: PointerEvent;\n  };\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T | null>(null);\n\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n\n  return ref as React.RefObject<T>;\n}\n\nfunction getDataState(open: boolean): string {\n  return open ? \"open\" : \"closed\";\n}\n\nfunction getTransformOrigin(side: Side): string {\n  switch (side) {\n    case \"top\":\n      return \"bottom center\";\n    case \"bottom\":\n      return \"top center\";\n    case \"left\":\n      return \"right center\";\n    case \"right\":\n      return \"left center\";\n  }\n}\n\ninterface StoreState {\n  open: boolean;\n}\n\ninterface Store {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => StoreState;\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\n  notify: () => void;\n}\n\nconst StoreContext = React.createContext<Store | null>(null);\n\nfunction useStoreContext(consumerName: string) {\n  const context = React.useContext(StoreContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\nfunction useStore<T>(\n  selector: (state: StoreState) => T,\n  ogStore?: Store | null,\n): T {\n  const contextStore = React.useContext(StoreContext);\n\n  const store = ogStore ?? contextStore;\n\n  if (!store) {\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface NodeData {\n  id: string;\n  ref: React.RefObject<HTMLElement | null>;\n  disabled: boolean;\n}\n\ninterface SpeedDialContextValue {\n  contentId: string;\n  side: Side;\n  onNodeRegister: (node: NodeData) => void;\n  onNodeUnregister: (id: string) => void;\n  getNodes: () => NodeData[];\n}\n\nconst SpeedDialContext = React.createContext<SpeedDialContextValue | null>(\n  null,\n);\n\nfunction useSpeedDialContext(consumerName: string) {\n  const context = React.useContext(SpeedDialContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\n  }\n  return context;\n}\n\ninterface SpeedDialRootProps extends DivProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  onInteractOutside?: (event: InteractOutsideEvent) => void;\n  side?: Side;\n}\n\nfunction SpeedDialRoot(props: SpeedDialRootProps) {\n  const {\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    onPointerDownCapture: onPointerDownCaptureProp,\n    onEscapeKeyDown,\n    onInteractOutside,\n    side = \"top\",\n    asChild,\n    className,\n    ref,\n    ...rootProps\n  } = props;\n\n  const contentId = React.useId();\n  const rootRef = React.useRef<RootElement>(null);\n  const composedRefs = useComposedRefs(ref, rootRef);\n  const nodesRef = React.useRef<Map<string, NodeData>>(new Map());\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n  const stateRef = useLazyRef<StoreState>(() => ({\n    open: openProp ?? defaultOpen ?? false,\n  }));\n  const propsRef = useAsRef({\n    onOpenChange,\n    onEscapeKeyDown,\n    onInteractOutside,\n  });\n\n  const onNodeRegister = React.useCallback((node: NodeData) => {\n    nodesRef.current.set(node.id, node);\n  }, []);\n\n  const onNodeUnregister = React.useCallback((id: string) => {\n    nodesRef.current.delete(id);\n  }, []);\n\n  const getNodes = React.useCallback(() => {\n    return Array.from(nodesRef.current.values())\n      .filter((node) => node.ref.current)\n      .sort((a, b) => {\n        const elementA = a.ref.current;\n        const elementB = b.ref.current;\n        if (!elementA || !elementB) return 0;\n        const position = elementA.compareDocumentPosition(elementB);\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return -1;\n        }\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n          return 1;\n        }\n        return 0;\n      });\n  }, []);\n\n  const store = React.useMemo<Store>(() => {\n    return {\n      subscribe: (cb) => {\n        listenersRef.current.add(cb);\n        return () => listenersRef.current.delete(cb);\n      },\n      getState: () => stateRef.current,\n      setState: (key, value) => {\n        if (Object.is(stateRef.current[key], value)) return;\n\n        if (key === \"open\" && typeof value === \"boolean\") {\n          stateRef.current.open = value;\n          propsRef.current?.onOpenChange?.(value);\n        } else {\n          stateRef.current[key] = value;\n        }\n\n        store.notify();\n      },\n      notify: () => {\n        for (const cb of listenersRef.current) {\n          cb();\n        }\n      },\n    };\n  }, [listenersRef, stateRef, propsRef]);\n\n  const open = useStore((state) => state.open, store);\n\n  useIsomorphicLayoutEffect(() => {\n    if (openProp !== undefined) {\n      store.setState(\"open\", openProp);\n    }\n  }, [openProp, store]);\n\n  const ownerDocument = rootRef.current?.ownerDocument ?? globalThis?.document;\n\n  const isPointerInsideReactTreeRef = React.useRef(false);\n\n  const onPointerDownCapture = React.useCallback(\n    (event: React.PointerEvent<RootElement>) => {\n      onPointerDownCaptureProp?.(event);\n      if (event.defaultPrevented) return;\n\n      const target = event.target as HTMLElement;\n      const nodes = getNodes();\n      const isInteractiveElement = nodes.some((node) =>\n        node.ref.current?.contains(target),\n      );\n\n      isPointerInsideReactTreeRef.current = isInteractiveElement;\n    },\n    [onPointerDownCaptureProp, getNodes],\n  );\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.key === \"Escape\") {\n        propsRef.current?.onEscapeKeyDown?.(event);\n        if (event.defaultPrevented) return;\n\n        store.setState(\"open\", false);\n      }\n\n      if (event.key === \"Tab\") {\n        const focusableElements = getNodes()\n          .filter((node) => !node.disabled)\n          .map((node) => node.ref.current);\n\n        if (focusableElements.length === 0) return;\n\n        const firstElement = focusableElements[0];\n        const lastElement = focusableElements[focusableElements.length - 1];\n        const activeElement = ownerDocument.activeElement;\n\n        if (event.shiftKey) {\n          if (activeElement === firstElement) {\n            store.setState(\"open\", false);\n          }\n        } else {\n          if (activeElement === lastElement) {\n            store.setState(\"open\", false);\n          }\n        }\n      }\n    };\n\n    ownerDocument.addEventListener(\"keydown\", onKeyDown);\n    return () => ownerDocument.removeEventListener(\"keydown\", onKeyDown);\n  }, [open, propsRef, ownerDocument, store, getNodes]);\n\n  const onClickRef = React.useRef<() => void>(() => {});\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    isPointerInsideReactTreeRef.current = false;\n\n    const onPointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const target = event.target as HTMLElement;\n        const isOutside = !rootRef.current?.contains(target);\n\n        function onDismiss() {\n          if (isOutside) {\n            const interactEvent = new CustomEvent(INTERACT_OUTSIDE, {\n              ...EVENT_OPTIONS,\n              detail: { originalEvent: event },\n            }) as InteractOutsideEvent;\n\n            propsRef.current?.onInteractOutside?.(interactEvent);\n            if (interactEvent.defaultPrevented) return;\n          }\n\n          store.setState(\"open\", false);\n        }\n\n        if (event.pointerType === \"touch\") {\n          ownerDocument.removeEventListener(\"click\", onClickRef.current);\n          onClickRef.current = onDismiss;\n          ownerDocument.addEventListener(\"click\", onClickRef.current, {\n            once: true,\n          });\n        } else {\n          onDismiss();\n        }\n      } else {\n        ownerDocument.removeEventListener(\"click\", onClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener(\"pointerdown\", onPointerDown);\n    }, 0);\n\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener(\"pointerdown\", onPointerDown);\n      ownerDocument.removeEventListener(\"click\", onClickRef.current);\n    };\n  }, [open, propsRef, ownerDocument, store]);\n\n  const contextValue = React.useMemo<SpeedDialContextValue>(\n    () => ({\n      contentId,\n      side,\n      onNodeRegister,\n      onNodeUnregister,\n      getNodes,\n    }),\n    [contentId, side, onNodeRegister, onNodeUnregister, getNodes],\n  );\n\n  const RootPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <StoreContext.Provider value={store}>\n      <SpeedDialContext.Provider value={contextValue}>\n        <RootPrimitive\n          data-slot=\"speed-dial\"\n          {...rootProps}\n          ref={composedRefs}\n          className={cn(\"relative flex flex-col items-end\", className)}\n          onPointerDownCapture={onPointerDownCapture}\n        />\n      </SpeedDialContext.Provider>\n    </StoreContext.Provider>\n  );\n}\n\nfunction SpeedDialTrigger(props: React.ComponentProps<typeof Button>) {\n  const {\n    onClick: onClickProp,\n    className,\n    disabled,\n    id,\n    ref,\n    ...triggerProps\n  } = props;\n\n  const store = useStoreContext(TRIGGER_NAME);\n  const { onNodeRegister, onNodeUnregister, contentId } =\n    useSpeedDialContext(TRIGGER_NAME);\n  const open = useStore((state) => state.open);\n\n  const instanceId = React.useId();\n  const triggerId = id ?? instanceId;\n  const triggerRef = React.useRef<TriggerElement>(null);\n  const composedRef = useComposedRefs(ref, triggerRef);\n\n  useIsomorphicLayoutEffect(() => {\n    onNodeRegister({\n      id: triggerId,\n      ref: triggerRef,\n      disabled: !!disabled,\n    });\n\n    return () => {\n      onNodeUnregister(triggerId);\n    };\n  }, [onNodeRegister, onNodeUnregister, triggerId, disabled]);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<TriggerElement>) => {\n      onClickProp?.(event);\n      if (event.defaultPrevented) return;\n\n      store.setState(\"open\", !open);\n    },\n    [onClickProp, store, open],\n  );\n\n  return (\n    <Button\n      type=\"button\"\n      role=\"button\"\n      id={triggerId}\n      aria-haspopup=\"menu\"\n      aria-expanded={open}\n      aria-controls={contentId}\n      data-slot=\"speed-dial-trigger\"\n      data-state={getDataState(open)}\n      size=\"icon\"\n      disabled={disabled}\n      {...triggerProps}\n      ref={composedRef}\n      className={cn(\"size-11 rounded-full\", className)}\n      onClick={onClick}\n    />\n  );\n}\n\nconst SpeedDialItemImplContext = React.createContext<number | null>(null);\n\nfunction useSpeedDialItemImplContext() {\n  return React.useContext(SpeedDialItemImplContext);\n}\n\nconst speedDialContentVariants = cva(\n  \"absolute z-50 flex gap-[var(--speed-dial-gap)]\",\n  {\n    variants: {\n      side: {\n        top: \"right-0 bottom-full mb-[var(--speed-dial-offset)] flex-col-reverse items-end\",\n        bottom:\n          \"top-full right-0 mt-[var(--speed-dial-offset)] flex-col items-end\",\n        left: \"right-full mr-[var(--speed-dial-offset)] flex-row-reverse items-center\",\n        right: \"left-full ml-[var(--speed-dial-offset)] flex-row items-center\",\n      },\n    },\n    defaultVariants: {\n      side: \"top\",\n    },\n  },\n);\n\ninterface SpeedDialContentProps\n  extends DivProps,\n    VariantProps<typeof speedDialContentVariants> {}\n\nfunction SpeedDialContent(props: SpeedDialContentProps) {\n  const { asChild, className, style, children, ...contentProps } = props;\n\n  const open = useStore((state) => state.open);\n  const { contentId, side } = useSpeedDialContext(CONTENT_NAME);\n\n  const orientation =\n    side === \"top\" || side === \"bottom\" ? \"vertical\" : \"horizontal\";\n\n  const ContentPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <ContentPrimitive\n      id={contentId}\n      role=\"menu\"\n      aria-orientation={orientation}\n      data-slot=\"speed-dial-content\"\n      data-orientation={orientation}\n      data-side={side}\n      {...contentProps}\n      className={cn(speedDialContentVariants({ side, className }))}\n      style={\n        {\n          \"--speed-dial-gap\": DEFAULT_GAP,\n          \"--speed-dial-offset\": DEFAULT_OFFSET,\n          \"--speed-dial-transform-origin\": getTransformOrigin(side),\n          ...style,\n        } as React.CSSProperties\n      }\n    >\n      {React.Children.map(children, (child, index) => {\n        if (!React.isValidElement(child)) return child;\n\n        const totalChildren = React.Children.count(children);\n        const delay = open\n          ? index * DEFAULT_ITEM_DELAY\n          : (totalChildren - index - 1) * DEFAULT_ITEM_DELAY;\n\n        return (\n          <SpeedDialItemImplContext.Provider value={delay}>\n            {child}\n          </SpeedDialItemImplContext.Provider>\n        );\n      })}\n    </ContentPrimitive>\n  );\n}\n\nconst speedDialItemVariants = cva(\n  \"flex items-center gap-2 transition-all duration-200 [transform-origin:var(--speed-dial-transform-origin)] [transition-delay:var(--speed-dial-delay)]\",\n  {\n    variants: {\n      side: {\n        top: \"justify-end\",\n        bottom: \"justify-end\",\n        left: \"flex-row-reverse justify-start\",\n        right: \"justify-start\",\n      },\n      open: {\n        true: \"translate-x-0 translate-y-0 scale-100 opacity-100\",\n        false: \"\",\n      },\n    },\n    compoundVariants: [\n      {\n        side: \"top\",\n        open: false,\n        className: \"translate-y-4 scale-0 opacity-0\",\n      },\n      {\n        side: \"bottom\",\n        open: false,\n        className: \"-translate-y-4 scale-0 opacity-0\",\n      },\n      {\n        side: \"left\",\n        open: false,\n        className: \"translate-x-4 scale-0 opacity-0\",\n      },\n      {\n        side: \"right\",\n        open: false,\n        className: \"-translate-x-4 scale-0 opacity-0\",\n      },\n    ],\n    defaultVariants: {\n      side: \"top\",\n      open: false,\n    },\n  },\n);\n\nconst SpeedDialItemContext = React.createContext<string | null>(null);\n\nfunction useSpeedDialItemContext(consumerName: string) {\n  const context = React.useContext(SpeedDialItemContext);\n  if (!context) {\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\n  }\n  return context;\n}\n\nfunction SpeedDialItem(props: DivProps) {\n  const { asChild, className, style, children, ...itemProps } = props;\n\n  const open = useStore((state) => state.open);\n  const { side } = useSpeedDialContext(ITEM_NAME);\n  const delay = useSpeedDialItemImplContext() ?? 0;\n  const labelId = React.useId();\n\n  const ItemPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <SpeedDialItemContext.Provider value={labelId}>\n      <ItemPrimitive\n        role=\"none\"\n        data-slot=\"speed-dial-item\"\n        data-state={getDataState(open)}\n        {...itemProps}\n        className={cn(speedDialItemVariants({ side, open, className }))}\n        style={\n          {\n            \"--speed-dial-delay\": `${delay}ms`,\n            \"--speed-dial-transform-origin\": getTransformOrigin(side),\n            ...style,\n          } as React.CSSProperties\n        }\n      >\n        {children}\n      </ItemPrimitive>\n    </SpeedDialItemContext.Provider>\n  );\n}\n\ninterface SpeedDialActionProps\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\n  onSelect?: (event: Event) => void;\n}\n\nfunction SpeedDialAction(props: SpeedDialActionProps) {\n  const {\n    onSelect,\n    onClick: onClickProp,\n    className,\n    disabled,\n    id,\n    ref,\n    ...actionProps\n  } = props;\n\n  const store = useStoreContext(ACTION_NAME);\n  const { onNodeRegister, onNodeUnregister } = useSpeedDialContext(ACTION_NAME);\n  const labelId = useSpeedDialItemContext(ACTION_NAME);\n\n  const instanceId = React.useId();\n  const actionId = id ?? instanceId;\n  const actionRef = React.useRef<ActionElement>(null);\n  const composedRefs = useComposedRefs(ref, actionRef);\n\n  useIsomorphicLayoutEffect(() => {\n    onNodeRegister({\n      id: actionId,\n      ref: actionRef,\n      disabled: !!disabled,\n    });\n\n    return () => {\n      onNodeUnregister(actionId);\n    };\n  }, [onNodeRegister, onNodeUnregister, actionId, disabled]);\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<ActionElement>) => {\n      onClickProp?.(event);\n      if (event.defaultPrevented) return;\n\n      const action = actionRef.current;\n      if (!action) return;\n\n      const actionSelectEvent = new CustomEvent(ACTION_SELECT, EVENT_OPTIONS);\n\n      action.addEventListener(ACTION_SELECT, (event) => onSelect?.(event), {\n        once: true,\n      });\n\n      action.dispatchEvent(actionSelectEvent);\n      if (actionSelectEvent.defaultPrevented) return;\n\n      store.setState(\"open\", false);\n    },\n    [onClickProp, onSelect, store],\n  );\n\n  return (\n    <Button\n      type=\"button\"\n      role=\"menuitem\"\n      id={actionId}\n      aria-labelledby={labelId}\n      data-slot=\"speed-dial-action\"\n      variant=\"outline\"\n      size=\"icon\"\n      disabled={disabled}\n      ref={composedRefs}\n      {...actionProps}\n      className={cn(\"size-11 shrink-0 rounded-full shadow-md\", className)}\n      onClick={onClick}\n    />\n  );\n}\n\nfunction SpeedDialLabel({ asChild, className, ...props }: DivProps) {\n  const labelId = useSpeedDialItemContext(LABEL_NAME);\n\n  const LabelPrimitive = asChild ? Slot : \"div\";\n\n  return (\n    <LabelPrimitive\n      id={labelId}\n      data-slot=\"speed-dial-label\"\n      className={cn(\n        \"pointer-events-none whitespace-nowrap rounded-md bg-popover px-2 py-1 text-popover-foreground text-sm shadow-md\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\nexport {\n  SpeedDialRoot as Root,\n  SpeedDialTrigger as Trigger,\n  SpeedDialContent as Content,\n  SpeedDialItem as Item,\n  SpeedDialAction as Action,\n  SpeedDialLabel as Label,\n  //\n  SpeedDialRoot as SpeedDial,\n  SpeedDialTrigger,\n  SpeedDialContent,\n  SpeedDialItem,\n  SpeedDialAction,\n  SpeedDialLabel,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}