{
  "name": "key-value",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea"
  ],
  "files": [
    {
      "path": "ui/key-value.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { PlusIcon, XIcon } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/default/components/visually-hidden-input\";\r\n\r\nconst ROOT_NAME = \"KeyValue\";\r\nconst LIST_NAME = \"KeyValueList\";\r\nconst ITEM_NAME = \"KeyValueItem\";\r\nconst KEY_INPUT_NAME = \"KeyValueKeyInput\";\r\nconst VALUE_INPUT_NAME = \"KeyValueValueInput\";\r\nconst REMOVE_NAME = \"KeyValueRemove\";\r\nconst ADD_NAME = \"KeyValueAdd\";\r\nconst ERROR_NAME = \"KeyValueError\";\r\n\r\ntype Orientation = \"vertical\" | \"horizontal\";\r\ntype Field = \"key\" | \"value\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof KeyValueRoot>;\r\ntype KeyInputElement = React.ComponentRef<typeof KeyValueKeyInput>;\r\ntype RemoveElement = React.ComponentRef<typeof KeyValueRemove>;\r\ntype AddElement = React.ComponentRef<typeof KeyValueAdd>;\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window === \"undefined\" ? React.useEffect : React.useLayoutEffect;\r\n\r\nfunction useAsRef<T>(props: T) {\r\n  const ref = React.useRef<T>(props);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = props;\r\n  });\r\n\r\n  return ref;\r\n}\r\n\r\nfunction useLazyRef<T>(fn: () => T) {\r\n  const ref = React.useRef<T | null>(null);\r\n\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nfunction getErrorId(rootId: string, itemId: string, field: Field) {\r\n  return `${rootId}-${itemId}-${field}-error`;\r\n}\r\n\r\nfunction removeQuotes(string: string, shouldStrip: boolean): string {\r\n  if (!shouldStrip) return string;\r\n\r\n  const trimmed = string.trim();\r\n  if (\r\n    (trimmed.startsWith('\"') && trimmed.endsWith('\"')) ||\r\n    (trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\"))\r\n  ) {\r\n    return trimmed.slice(1, -1);\r\n  }\r\n  return trimmed;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => KeyValueState;\r\n  setState: <K extends keyof KeyValueState>(\r\n    key: K,\r\n    value: KeyValueState[K],\r\n  ) => void;\r\n  notify: () => void;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: KeyValueState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface KeyValueItemData {\r\n  id: string;\r\n  key: string;\r\n  value: string;\r\n}\r\n\r\ninterface KeyValueState {\r\n  value: KeyValueItemData[];\r\n  focusedId: string | null;\r\n  errors: Record<string, { key?: string; value?: string }>;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueContextValue {\r\n  rootId: string;\r\n  maxItems?: number;\r\n  minItems: number;\r\n  keyPlaceholder: string;\r\n  valuePlaceholder: string;\r\n  allowDuplicateKeys: boolean;\r\n  enablePaste: boolean;\r\n  trim: boolean;\r\n  stripQuotes: boolean;\r\n  disabled: boolean;\r\n  readOnly: boolean;\r\n  required: boolean;\r\n}\r\n\r\nconst KeyValueContext = React.createContext<KeyValueContextValue | null>(null);\r\n\r\nfunction useKeyValueContext(consumerName: string) {\r\n  const context = React.useContext(KeyValueContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueRootProps extends Omit<DivProps, \"onPaste\" | \"defaultValue\"> {\r\n  id?: string;\r\n  defaultValue?: KeyValueItemData[];\r\n  value?: KeyValueItemData[];\r\n  onValueChange?: (value: KeyValueItemData[]) => void;\r\n  maxItems?: number;\r\n  minItems?: number;\r\n  keyPlaceholder?: string;\r\n  valuePlaceholder?: string;\r\n  name?: string;\r\n  allowDuplicateKeys?: boolean;\r\n  enablePaste?: boolean;\r\n  trim?: boolean;\r\n  stripQuotes?: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  onPaste?: (event: ClipboardEvent, items: KeyValueItemData[]) => void;\r\n  onAdd?: (value: KeyValueItemData) => void;\r\n  onRemove?: (value: KeyValueItemData) => void;\r\n  onKeyValidate?: (\r\n    key: string,\r\n    value: KeyValueItemData[],\r\n  ) => string | undefined;\r\n  onValueValidate?: (\r\n    value: string,\r\n    key: string,\r\n    items: KeyValueItemData[],\r\n  ) => string | undefined;\r\n}\r\n\r\nfunction KeyValueRoot(props: KeyValueRootProps) {\r\n  const { value, defaultValue, onValueChange, ...rootProps } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<KeyValueState>(() => ({\r\n    value: value ??\r\n      defaultValue ?? [{ id: crypto.randomUUID(), key: \"\", value: \"\" }],\r\n    focusedId: null,\r\n    errors: {},\r\n  }));\r\n  const propsRef = useAsRef({ onValueChange });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, val) => {\r\n        if (Object.is(stateRef.current[key], val)) return;\r\n\r\n        if (key === \"value\" && Array.isArray(val)) {\r\n          stateRef.current.value = val as KeyValueItemData[];\r\n          propsRef.current.onValueChange?.(val as KeyValueItemData[]);\r\n        } else {\r\n          stateRef.current[key] = val;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <KeyValueRootImpl {...rootProps} value={value} />\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface KeyValueRootImplProps\r\n  extends Omit<\r\n    KeyValueRootProps,\r\n    | \"defaultValue\"\r\n    | \"onValueChange\"\r\n    | \"onPaste\"\r\n    | \"onAdd\"\r\n    | \"onRemove\"\r\n    | \"onKeyValidate\"\r\n    | \"onValueValidate\"\r\n  > {}\r\n\r\nfunction KeyValueRootImpl(props: KeyValueRootImplProps) {\r\n  const {\r\n    id,\r\n    value: valueProp,\r\n    maxItems,\r\n    minItems = 0,\r\n    keyPlaceholder = \"Key\",\r\n    valuePlaceholder = \"Value\",\r\n    name,\r\n    allowDuplicateKeys = false,\r\n    enablePaste = true,\r\n    trim = true,\r\n    stripQuotes = true,\r\n    disabled = false,\r\n    readOnly = false,\r\n    required = false,\r\n    asChild,\r\n    className,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(\"KeyValueRootImpl\");\r\n\r\n  const value = useStore((state) => state.value);\r\n  const errors = useStore((state) => state.errors);\r\n  const isInvalid = Object.keys(errors).length > 0;\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp, store]);\r\n\r\n  const instanceId = React.useId();\r\n  const rootId = id ?? instanceId;\r\n\r\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\r\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n  const contextValue = React.useMemo<KeyValueContextValue>(\r\n    () => ({\r\n      rootId,\r\n      maxItems,\r\n      minItems,\r\n      keyPlaceholder,\r\n      valuePlaceholder,\r\n      allowDuplicateKeys,\r\n      enablePaste,\r\n      trim,\r\n      stripQuotes,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n    }),\r\n    [\r\n      rootId,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      maxItems,\r\n      minItems,\r\n      keyPlaceholder,\r\n      valuePlaceholder,\r\n      allowDuplicateKeys,\r\n      enablePaste,\r\n      trim,\r\n      stripQuotes,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <>\r\n      <KeyValueContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          id={id}\r\n          data-slot=\"key-value\"\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-invalid={isInvalid ? \"\" : undefined}\r\n          data-readonly={readOnly ? \"\" : undefined}\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\"flex flex-col gap-2\", className)}\r\n        />\r\n      </KeyValueContext.Provider>\r\n      {isFormControl && (\r\n        <VisuallyHiddenInput\r\n          type=\"hidden\"\r\n          control={formTrigger}\r\n          name={name}\r\n          value={value}\r\n          disabled={disabled}\r\n          readOnly={readOnly}\r\n          required={required}\r\n        />\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\ninterface KeyValueListProps extends DivProps {\r\n  orientation?: Orientation;\r\n}\r\n\r\nfunction KeyValueList(props: KeyValueListProps) {\r\n  const { orientation = \"vertical\", asChild, className, ...listProps } = props;\r\n\r\n  const value = useStore((state) => state.value);\r\n\r\n  const ListPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ListPrimitive\r\n      role=\"list\"\r\n      aria-orientation={orientation}\r\n      data-slot=\"key-value-list\"\r\n      data-orientation={orientation}\r\n      {...listProps}\r\n      className={cn(\r\n        \"flex\",\r\n        orientation === \"vertical\" ? \"flex-col gap-2\" : \"flex-row gap-2\",\r\n        className,\r\n      )}\r\n    >\r\n      {value.map((item) => {\r\n        const children = React.Children.toArray(props.children);\r\n        return (\r\n          <KeyValueItemContext.Provider key={item.id} value={item}>\r\n            {children}\r\n          </KeyValueItemContext.Provider>\r\n        );\r\n      })}\r\n    </ListPrimitive>\r\n  );\r\n}\r\n\r\nconst KeyValueItemContext = React.createContext<KeyValueItemData | null>(null);\r\n\r\nfunction useKeyValueItemContext(consumerName: string) {\r\n  const context = React.useContext(KeyValueItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${LIST_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueItemProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueItem(props: KeyValueItemProps) {\r\n  const { asChild, className, ...itemProps } = props;\r\n  const itemData = useKeyValueItemContext(ITEM_NAME);\r\n\r\n  const focusedId = useStore((state) => state.focusedId);\r\n\r\n  const ItemPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <ItemPrimitive\r\n      role=\"listitem\"\r\n      data-slot=\"key-value-item\"\r\n      data-highlighted={focusedId === itemData.id ? \"\" : undefined}\r\n      {...itemProps}\r\n      className={cn(\"flex items-start gap-2\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueKeyInputProps\r\n  extends Omit<React.ComponentProps<\"input\">, \"onPaste\">,\r\n    Pick<KeyValueRootProps, \"onKeyValidate\" | \"onValueValidate\" | \"onPaste\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueKeyInput(props: KeyValueKeyInputProps) {\r\n  const {\r\n    onKeyValidate,\r\n    onValueValidate,\r\n    onChange,\r\n    onPaste,\r\n    asChild,\r\n    disabled,\r\n    readOnly,\r\n    required,\r\n    ...keyInputProps\r\n  } = props;\r\n\r\n  const context = useKeyValueContext(KEY_INPUT_NAME);\r\n  const itemData = useKeyValueItemContext(KEY_INPUT_NAME);\r\n  const store = useStoreContext(KEY_INPUT_NAME);\r\n\r\n  const errors = useStore((state) => state.errors);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isReadOnly = readOnly || context.readOnly;\r\n  const isRequired = required || context.required;\r\n  const isInvalid = errors[itemData.id]?.key !== undefined;\r\n\r\n  const propsRef = useAsRef({\r\n    onKeyValidate,\r\n    onValueValidate,\r\n    onChange,\r\n    onPaste,\r\n  });\r\n\r\n  const onKeyInputChange = React.useCallback(\r\n    (event: React.ChangeEvent<KeyInputElement>) => {\r\n      const state = store.getState();\r\n      const newValue = state.value.map((item) => {\r\n        if (item.id !== itemData.id) return item;\r\n        const updated = { ...item, key: event.target.value };\r\n        if (context.trim) updated.key = updated.key.trim();\r\n        return updated;\r\n      });\r\n\r\n      store.setState(\"value\", newValue);\r\n\r\n      const updatedItemData = newValue.find((item) => item.id === itemData.id);\r\n      if (updatedItemData) {\r\n        const errors: { key?: string; value?: string } = {};\r\n\r\n        if (propsRef.current.onKeyValidate) {\r\n          const keyError = propsRef.current.onKeyValidate(\r\n            updatedItemData.key,\r\n            newValue,\r\n          );\r\n          if (keyError) errors.key = keyError;\r\n        }\r\n\r\n        if (!context.allowDuplicateKeys) {\r\n          const duplicateKey = newValue.find(\r\n            (item) =>\r\n              item.id !== updatedItemData.id &&\r\n              item.key === updatedItemData.key &&\r\n              updatedItemData.key !== \"\",\r\n          );\r\n          if (duplicateKey) {\r\n            errors.key = \"Duplicate key\";\r\n          }\r\n        }\r\n\r\n        if (propsRef.current.onValueValidate) {\r\n          const valueError = propsRef.current.onValueValidate(\r\n            updatedItemData.value,\r\n            updatedItemData.key,\r\n            newValue,\r\n          );\r\n          if (valueError) errors.value = valueError;\r\n        }\r\n\r\n        const newErrorsState = { ...state.errors };\r\n        if (Object.keys(errors).length > 0) {\r\n          newErrorsState[itemData.id] = errors;\r\n        } else {\r\n          delete newErrorsState[itemData.id];\r\n        }\r\n        store.setState(\"errors\", newErrorsState);\r\n      }\r\n\r\n      propsRef.current.onChange?.(event);\r\n    },\r\n    [store, itemData.id, context.trim, context.allowDuplicateKeys, propsRef],\r\n  );\r\n\r\n  const onKeyInputPaste = React.useCallback(\r\n    (event: React.ClipboardEvent<KeyInputElement>) => {\r\n      if (!context.enablePaste) return;\r\n\r\n      const content = event.clipboardData.getData(\"text\");\r\n      const lines = content.split(/\\r?\\n/).filter((line) => line.trim());\r\n\r\n      if (lines.length > 1) {\r\n        event.preventDefault();\r\n\r\n        const parsed: KeyValueItemData[] = [];\r\n\r\n        for (const line of lines) {\r\n          let key = \"\";\r\n          let value = \"\";\r\n\r\n          if (line.includes(\"=\")) {\r\n            const parts = line.split(\"=\");\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = removeQuotes(\r\n              parts.slice(1).join(\"=\").trim(),\r\n              context.stripQuotes,\r\n            );\r\n          } else if (line.includes(\":\")) {\r\n            const parts = line.split(\":\");\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = removeQuotes(\r\n              parts.slice(1).join(\":\").trim(),\r\n              context.stripQuotes,\r\n            );\r\n          } else if (/\\s{2,}|\\t/.test(line)) {\r\n            const parts = line.split(/\\s{2,}|\\t/);\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = removeQuotes(\r\n              parts.slice(1).join(\" \").trim(),\r\n              context.stripQuotes,\r\n            );\r\n          }\r\n\r\n          if (key) {\r\n            parsed.push({ id: crypto.randomUUID(), key, value });\r\n          }\r\n        }\r\n\r\n        if (parsed.length > 0) {\r\n          const state = store.getState();\r\n          const currentIndex = state.value.findIndex(\r\n            (item) => item.id === itemData.id,\r\n          );\r\n\r\n          let newValue: KeyValueItemData[];\r\n          if (itemData.key === \"\" && itemData.value === \"\") {\r\n            newValue = [\r\n              ...state.value.slice(0, currentIndex),\r\n              ...parsed,\r\n              ...state.value.slice(currentIndex + 1),\r\n            ];\r\n          } else {\r\n            newValue = [\r\n              ...state.value.slice(0, currentIndex + 1),\r\n              ...parsed,\r\n              ...state.value.slice(currentIndex + 1),\r\n            ];\r\n          }\r\n\r\n          if (context.maxItems !== undefined) {\r\n            newValue = newValue.slice(0, context.maxItems);\r\n          }\r\n\r\n          store.setState(\"value\", newValue);\r\n\r\n          if (propsRef.current.onPaste) {\r\n            propsRef.current.onPaste(\r\n              event.nativeEvent as unknown as ClipboardEvent,\r\n              parsed,\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [\r\n      context.enablePaste,\r\n      context.maxItems,\r\n      context.stripQuotes,\r\n      store,\r\n      itemData,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const KeyInputPrimitive = asChild ? Slot : Input;\r\n\r\n  return (\r\n    <KeyInputPrimitive\r\n      aria-invalid={isInvalid}\r\n      aria-describedby={\r\n        isInvalid ? getErrorId(context.rootId, itemData.id, \"key\") : undefined\r\n      }\r\n      data-slot=\"key-value-key-input\"\r\n      autoCapitalize=\"off\"\r\n      autoComplete=\"off\"\r\n      autoCorrect=\"off\"\r\n      spellCheck=\"false\"\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      required={isRequired}\r\n      {...keyInputProps}\r\n      placeholder={context.keyPlaceholder}\r\n      value={itemData.key}\r\n      onChange={onKeyInputChange}\r\n      onPaste={onKeyInputPaste}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueValueInputProps\r\n  extends Omit<React.ComponentProps<\"textarea\">, \"rows\">,\r\n    Pick<KeyValueRootProps, \"onKeyValidate\" | \"onValueValidate\"> {\r\n  maxRows?: number;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueValueInput(props: KeyValueValueInputProps) {\r\n  const {\r\n    onKeyValidate,\r\n    onValueValidate,\r\n    onChange,\r\n    asChild,\r\n    disabled,\r\n    readOnly,\r\n    required,\r\n    className,\r\n    maxRows,\r\n    style,\r\n    ...valueInputProps\r\n  } = props;\r\n\r\n  const context = useKeyValueContext(VALUE_INPUT_NAME);\r\n  const itemData = useKeyValueItemContext(VALUE_INPUT_NAME);\r\n  const store = useStoreContext(VALUE_INPUT_NAME);\r\n\r\n  const propsRef = useAsRef({\r\n    onKeyValidate,\r\n    onValueValidate,\r\n    onChange,\r\n  });\r\n  const errors = useStore((state) => state.errors);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isReadOnly = readOnly || context.readOnly;\r\n  const isRequired = required || context.required;\r\n  const isInvalid = errors[itemData.id]?.value !== undefined;\r\n  const maxHeight = maxRows ? `calc(${maxRows} * 1.5em + 1rem)` : undefined;\r\n\r\n  const onValueInputChange = React.useCallback(\r\n    (event: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n      propsRef.current.onChange?.(event);\r\n\r\n      const state = store.getState();\r\n      const newValue = state.value.map((item) => {\r\n        if (item.id !== itemData.id) return item;\r\n        const updated = { ...item, value: event.target.value };\r\n        if (context.trim) updated.value = updated.value.trim();\r\n        return updated;\r\n      });\r\n\r\n      store.setState(\"value\", newValue);\r\n\r\n      const updatedItemData = newValue.find(\r\n        (item: KeyValueItemData) => item.id === itemData.id,\r\n      );\r\n      if (updatedItemData) {\r\n        const errors: { key?: string; value?: string } = {};\r\n\r\n        if (propsRef.current.onKeyValidate) {\r\n          const keyError = propsRef.current.onKeyValidate(\r\n            updatedItemData.key,\r\n            newValue,\r\n          );\r\n          if (keyError) errors.key = keyError;\r\n        }\r\n\r\n        if (!context.allowDuplicateKeys) {\r\n          const duplicateKey = newValue.find(\r\n            (item: KeyValueItemData) =>\r\n              item.id !== updatedItemData.id &&\r\n              item.key === updatedItemData.key &&\r\n              updatedItemData.key !== \"\",\r\n          );\r\n          if (duplicateKey) {\r\n            errors.key = \"Duplicate key\";\r\n          }\r\n        }\r\n\r\n        if (propsRef.current.onValueValidate) {\r\n          const valueError = propsRef.current.onValueValidate(\r\n            updatedItemData.value,\r\n            updatedItemData.key,\r\n            newValue,\r\n          );\r\n          if (valueError) errors.value = valueError;\r\n        }\r\n\r\n        const newErrorsState = { ...state.errors };\r\n        if (Object.keys(errors).length > 0) {\r\n          newErrorsState[itemData.id] = errors;\r\n        } else {\r\n          delete newErrorsState[itemData.id];\r\n        }\r\n        store.setState(\"errors\", newErrorsState);\r\n      }\r\n    },\r\n    [store, itemData.id, context.trim, context.allowDuplicateKeys, propsRef],\r\n  );\r\n\r\n  const ValueInputPrimitive = asChild ? Slot : Textarea;\r\n\r\n  return (\r\n    <ValueInputPrimitive\r\n      aria-invalid={isInvalid}\r\n      aria-describedby={\r\n        isInvalid ? getErrorId(context.rootId, itemData.id, \"value\") : undefined\r\n      }\r\n      data-slot=\"key-value-value-input\"\r\n      autoCapitalize=\"off\"\r\n      autoComplete=\"off\"\r\n      autoCorrect=\"off\"\r\n      spellCheck=\"false\"\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      required={isRequired}\r\n      {...valueInputProps}\r\n      placeholder={context.valuePlaceholder}\r\n      className={cn(\r\n        \"field-sizing-content min-h-9 resize-none\",\r\n        maxRows && \"overflow-y-auto\",\r\n        className,\r\n      )}\r\n      style={{\r\n        ...style,\r\n        ...(maxHeight && { maxHeight }),\r\n      }}\r\n      value={itemData.value}\r\n      onChange={onValueInputChange}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueRemoveProps\r\n  extends React.ComponentProps<typeof Button>,\r\n    Pick<KeyValueRootProps, \"onRemove\"> {}\r\n\r\nfunction KeyValueRemove(props: KeyValueRemoveProps) {\r\n  const { onClick, onRemove, children, ...removeProps } = props;\r\n\r\n  const context = useKeyValueContext(REMOVE_NAME);\r\n  const itemData = useKeyValueItemContext(REMOVE_NAME);\r\n  const store = useStoreContext(REMOVE_NAME);\r\n\r\n  const propsRef = useAsRef({ onClick, onRemove });\r\n  const value = useStore((state) => state.value);\r\n  const isDisabled = context.disabled || value.length <= context.minItems;\r\n\r\n  const onRemoveClick = React.useCallback(\r\n    (event: React.MouseEvent<RemoveElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n\r\n      const state = store.getState();\r\n      if (state.value.length <= context.minItems) return;\r\n\r\n      const itemToRemove = state.value.find((item) => item.id === itemData.id);\r\n      if (!itemToRemove) return;\r\n\r\n      const newValue = state.value.filter((item) => item.id !== itemData.id);\r\n      const newErrors = { ...state.errors };\r\n      delete newErrors[itemData.id];\r\n\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"errors\", newErrors);\r\n\r\n      propsRef.current.onRemove?.(itemToRemove);\r\n    },\r\n    [store, context.minItems, itemData.id, propsRef],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"key-value-remove\"\r\n      variant=\"outline\"\r\n      size=\"icon\"\r\n      disabled={isDisabled}\r\n      {...removeProps}\r\n      onClick={onRemoveClick}\r\n    >\r\n      {children ?? <XIcon />}\r\n    </Button>\r\n  );\r\n}\r\n\r\ninterface KeyValueAddProps\r\n  extends React.ComponentProps<typeof Button>,\r\n    Pick<KeyValueRootProps, \"onAdd\"> {}\r\n\r\nfunction KeyValueAdd(props: KeyValueAddProps) {\r\n  const { onClick, onAdd, children, ...addProps } = props;\r\n\r\n  const context = useKeyValueContext(ADD_NAME);\r\n  const store = useStoreContext(ADD_NAME);\r\n\r\n  const propsRef = useAsRef({ onClick, onAdd });\r\n  const value = useStore((state) => state.value);\r\n  const isDisabled =\r\n    context.disabled ||\r\n    (context.maxItems !== undefined && value.length >= context.maxItems);\r\n\r\n  const onAddClick = React.useCallback(\r\n    (event: React.MouseEvent<AddElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n\r\n      const state = store.getState();\r\n      if (\r\n        context.maxItems !== undefined &&\r\n        state.value.length >= context.maxItems\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const newItem: KeyValueItemData = {\r\n        id: crypto.randomUUID(),\r\n        key: \"\",\r\n        value: \"\",\r\n      };\r\n\r\n      const newValue = [...state.value, newItem];\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"focusedId\", newItem.id);\r\n\r\n      propsRef.current.onAdd?.(newItem);\r\n    },\r\n    [store, context.maxItems, propsRef],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"key-value-add\"\r\n      variant=\"outline\"\r\n      disabled={isDisabled}\r\n      {...addProps}\r\n      onClick={onAddClick}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <PlusIcon />\r\n          Add\r\n        </>\r\n      )}\r\n    </Button>\r\n  );\r\n}\r\n\r\ninterface KeyValueErrorProps extends DivProps {\r\n  field: Field;\r\n}\r\n\r\nfunction KeyValueError(props: KeyValueErrorProps) {\r\n  const { field, asChild, className, ...errorProps } = props;\r\n\r\n  const context = useKeyValueContext(ERROR_NAME);\r\n  const itemData = useKeyValueItemContext(ERROR_NAME);\r\n\r\n  const errors = useStore((state) => state.errors);\r\n  const error = errors[itemData.id]?.[field];\r\n\r\n  if (!error) return null;\r\n\r\n  const ErrorPrimitive = asChild ? Slot : \"span\";\r\n\r\n  return (\r\n    <ErrorPrimitive\r\n      id={getErrorId(context.rootId, itemData.id, field)}\r\n      role=\"alert\"\r\n      {...errorProps}\r\n      className={cn(\"font-medium text-destructive text-sm\", className)}\r\n    >\r\n      {error}\r\n    </ErrorPrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  KeyValueRoot as Root,\r\n  KeyValueList as List,\r\n  KeyValueItem as Item,\r\n  KeyValueKeyInput as KeyInput,\r\n  KeyValueValueInput as ValueInput,\r\n  KeyValueRemove as Remove,\r\n  KeyValueAdd as Add,\r\n  KeyValueError as Error,\r\n  //\r\n  KeyValueRoot as KeyValue,\r\n  KeyValueList,\r\n  KeyValueItem,\r\n  KeyValueKeyInput,\r\n  KeyValueValueInput,\r\n  KeyValueRemove,\r\n  KeyValueAdd,\r\n  KeyValueError,\r\n  //\r\n  useStore as useKeyValueStore,\r\n  //\r\n  type KeyValueItemData,\r\n  type KeyValueRootProps as KeyValueProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\ntype InputValue = string[] | string;\n\ninterface VisuallyHiddenInputProps<T = InputValue>\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"value\" | \"checked\" | \"onReset\"\n  > {\n  value?: T;\n  checked?: boolean;\n  control: HTMLElement | null;\n  bubbles?: boolean;\n}\n\nfunction VisuallyHiddenInput<T = InputValue>(\n  props: VisuallyHiddenInputProps<T>,\n) {\n  const {\n    control,\n    value,\n    checked,\n    bubbles = true,\n    type = \"hidden\",\n    style,\n    ...inputProps\n  } = props;\n\n  const isCheckInput = React.useMemo(\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\n    [type],\n  );\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const prevValueRef = React.useRef<{\n    value: T | boolean | undefined;\n    previous: T | boolean | undefined;\n  }>({\n    value: isCheckInput ? checked : value,\n    previous: isCheckInput ? checked : value,\n  });\n\n  const prevValue = React.useMemo(() => {\n    const currentValue = isCheckInput ? checked : value;\n    if (prevValueRef.current.value !== currentValue) {\n      prevValueRef.current.previous = prevValueRef.current.value;\n      prevValueRef.current.value = currentValue;\n    }\n    return prevValueRef.current.previous;\n  }, [isCheckInput, value, checked]);\n\n  const [controlSize, setControlSize] = React.useState<{\n    width?: number;\n    height?: number;\n  }>({});\n\n  React.useLayoutEffect(() => {\n    if (!control) {\n      setControlSize({});\n      return;\n    }\n\n    setControlSize({\n      width: control.offsetWidth,\n      height: control.offsetHeight,\n    });\n\n    if (typeof window === \"undefined\") return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!Array.isArray(entries) || !entries.length) return;\n\n      const entry = entries[0];\n      if (!entry) return;\n\n      let width: number;\n      let height: number;\n\n      if (\"borderBoxSize\" in entry) {\n        const borderSizeEntry = entry.borderBoxSize;\n        const borderSize = Array.isArray(borderSizeEntry)\n          ? borderSizeEntry[0]\n          : borderSizeEntry;\n        width = borderSize.inlineSize;\n        height = borderSize.blockSize;\n      } else {\n        width = control.offsetWidth;\n        height = control.offsetHeight;\n      }\n\n      setControlSize({ width, height });\n    });\n\n    resizeObserver.observe(control, { box: \"border-box\" });\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [control]);\n\n  React.useEffect(() => {\n    const input = inputRef.current;\n    if (!input) return;\n\n    const inputProto = window.HTMLInputElement.prototype;\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\n    const eventType = isCheckInput ? \"click\" : \"input\";\n    const currentValue = isCheckInput ? checked : value;\n\n    const serializedCurrentValue = isCheckInput\n      ? checked\n      : typeof value === \"object\" && value !== null\n        ? JSON.stringify(value)\n        : value;\n\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\n\n    const setter = descriptor?.set;\n\n    if (prevValue !== currentValue && setter) {\n      const event = new Event(eventType, { bubbles });\n      setter.call(input, serializedCurrentValue);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\n\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\n    return {\n      ...style,\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\n        ? controlSize\n        : {}),\n      border: 0,\n      clip: \"rect(0 0 0 0)\",\n      clipPath: \"inset(50%)\",\n      height: \"1px\",\n      margin: \"-1px\",\n      overflow: \"hidden\",\n      padding: 0,\n      position: \"absolute\",\n      whiteSpace: \"nowrap\",\n      width: \"1px\",\n    };\n  }, [style, controlSize]);\n\n  return (\n    <input\n      type={type}\n      {...inputProps}\n      ref={inputRef}\n      aria-hidden={isCheckInput}\n      tabIndex={-1}\n      defaultChecked={isCheckInput ? checked : undefined}\n      style={composedStyle}\n    />\n  );\n}\n\nexport { VisuallyHiddenInput };\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}